<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>音视跳动科技</title>
  
  <subtitle>传播最前沿的科技知识！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.avdancedu.com/"/>
  <updated>2020-06-29T06:16:06.150Z</updated>
  <id>https://blog.avdancedu.com/</id>
  
  <author>
    <name>音视跳动</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>janus的线程模型</title>
    <link href="https://blog.avdancedu.com/8f43ddc9/"/>
    <id>https://blog.avdancedu.com/8f43ddc9/</id>
    <published>2020-06-29T05:33:58.000Z</published>
    <updated>2020-06-29T06:16:06.150Z</updated>
    
    <content type="html"><![CDATA[<p>我们要想把一个系统搞清楚，首先要把它的线程模型弄明白。比如它是单线程的还是多线程的？如果它是单线程的，那逻辑就比较简单了，像mediasoup就是单进程多实例的模型；如果是多线程的，那它的线程是如何分配的？每个线程的作用是什么？我们必须把这些都要弄清楚才行，否则我们就无法将这个系统彻底搞明白。</p><a id="more"></a><p>在分析 <code>janus</code> 的时候，我们也应尊循上面的原则。因此在分析<code>janus</code>之前，我们先来问几个问题，<code>janus</code>是多线程的模式吗？如果是多线程模式，那它一共有几个线程呢？ 这些线程又分别起什么作用？</p><p>如果我们将上面的问题回答好了，我想我们基本上就将<code>janus</code>的线程模型搞清楚了，搞清了它的线程模型也就撑握了<code>janus</code>的系统大体脉络。</p><h1 id="janus是多线程模式吗？"><a href="#janus是多线程模式吗？" class="headerlink" title="janus是多线程模式吗？"></a>janus是多线程模式吗？</h1><p>其实这个问题非常好回答，通过查看<code>janus</code>的主文件janus.c我们就能知道答案了。在janus.c中我们可以发现下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">GThread *watchdog &#x3D; g_thread_try_new(&quot;timeout watchdog&quot;, &amp;janus_sessions_watchdog, watchdog_loop, &amp;error);</span><br><span class="line">...</span><br><span class="line">GThread *requests_thread &#x3D; g_thread_try_new(&quot;sessions requests&quot;, &amp;janus_transport_requests, NULL, &amp;error);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>janus</code>是基于Linux 的GLIB库开发出来的，因此所有对系统的调用都是使用的GLIB库的API。而<code>g_thread_try_new</code>函数正中GLIB中用来创建线程的，在<code>g_thread_try_new</code>的底层真正调用的是<code>pthread</code>的相关API。</p><p><strong>通这上面的分析，我们可以知道janus是多线程的模式。</strong></p><h1 id="janus一共有几个线程？"><a href="#janus一共有几个线程？" class="headerlink" title="janus一共有几个线程？"></a>janus一共有几个线程？</h1><p>除了我们上面介绍的两个线程外，<code>janus</code>还使用了线程池的概念。在<code>janus</code>的初始化阶段就将线程池创建出来了。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">tasks &#x3D; g_thread_pool_new(janus_transport_task, NULL, -1, FALSE, &amp;error);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>查看<code>g_thread_pool_new</code>API的帮助文档，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GThreadPool *</span><br><span class="line">g_thread_pool_new (GFunc func,</span><br><span class="line">                   gpointer user_data,</span><br><span class="line">                   gint max_threads,</span><br><span class="line">                   gboolean exclusive,</span><br><span class="line">                   GError **error);</span><br></pre></td></tr></table></figure><p>通过这个定义我们可以知道<code>janus</code>创建的线程池时并没有对线程数进制控制。也就是说它可以开出系统可以支持的最大限度的线程个数。<strong>会在高并发时出现性能问题呢？这个还要等我们后面的深入分析才能清楚，目前来说这行代码还是有风险的。</strong></p><p>下面我们总结一下，通过对janus.c文件的分析，我们现在可以知道<code>janus</code>的线程模型是由两个专用线程<code>watchdog</code>、<code>request</code>和一个通用任务线程池构成的。如下图所示：</p><p><img data-src="https://cdn.avdancedu.com/image/article/janus_thread/janus_thread.jpg" alt="janus线程模型"></p><p>了解了<code>janus</code>的线程模型后，下面我们来看一下 <code>janus</code> 每个线程的作用吧。</p><h1 id="每个线程的作用"><a href="#每个线程的作用" class="headerlink" title="每个线程的作用"></a>每个线程的作用</h1><p>通过阅读代码，我们可以了解到这几个线程的主要作用是什么，下面我们来一一介绍一下。</p><p><strong>首先是主线程</strong>，这个线程的主要作用就是初始化的工作。主要包括以下几方面的工作：</p><ul><li>从配置文件中读配置信息，然后根据配置信息进行初始化工作</li><li>启动其它线程</li><li>动态加载plugin</li></ul><p><strong>WatchDog 线程</strong>，通过名子我们基本上就可以清楚它的作用了。它是监控线程，它每隔２秒做一次扫描，查看transport的session是否过期了。如果过期了，则给对应的transport发通知让transport结束处理。需要注意的是，这里的 trasnport代表的是不同协议的接入口，如RabbitMQ、MQTT、HTTP等。</p><p><strong>Request线程</strong>，用于处理接口请求。一般将接口请求分为两大类，文本类请求和命令类请求。如果是文本类请求的，则会启动新线程（从线程池中获取）进行处理；如果是命令的类的，则可以直接处理。当然对于命令类型的Request可能处理上会比较复杂，有可能会分成多个阶段处理，而在每个不同的阶段又会生成新的Request。</p><p><strong>最后一个就是线程池了</strong>，线程池的作用上面我已经介绍了，就是在处理Request时会从线程池中分配线程，然后执行Request任务，任务完成后再回收到线程池里。　</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>通过上面的描述我们可以看到<code>janus</code>的线程模型并不复杂，它启动了两个专门的线程，一个用于处理transport的session是否过期；另一个用于处理Request请求，当收到Request请求后，它又会把请求交给新的线程做延时处理。</p><p>以上我们就将 <code>janus</code> 的线程模型分析完了，读到这里我相信你已经对<code>janus</code>的线程模型有了一个大体的了解了。当然你仍然会很许多疑惑，这只能对照着<code>janus</code>的代码分析才能让你体会的更深刻！</p><p>谢谢！</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门》</a></li><li><a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">《百万级高并发WebRTC流媒体服务器设计与开发》</a></li><li><a href="https://time.geekbang.org/column/intro/207" target="_blank" rel="noopener">《从0打造音视频直播系统》</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们要想把一个系统搞清楚，首先要把它的线程模型弄明白。比如它是单线程的还是多线程的？如果它是单线程的，那逻辑就比较简单了，像mediasoup就是单进程多实例的模型；如果是多线程的，那它的线程是如何分配的？每个线程的作用是什么？我们必须把这些都要弄清楚才行，否则我们就无法将这个系统彻底搞明白。&lt;/p&gt;
    
    </summary>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/categories/WebRTC/"/>
    
    
      <category term="thread" scheme="https://blog.avdancedu.com/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>深入理解janus中的plugin管理</title>
    <link href="https://blog.avdancedu.com/26c3d930/"/>
    <id>https://blog.avdancedu.com/26c3d930/</id>
    <published>2020-06-29T05:05:29.000Z</published>
    <updated>2020-06-29T05:24:24.710Z</updated>
    
    <content type="html"><![CDATA[<p><code>janus</code>中的<code>plugin</code>是其非常重要的一部分内容，今天我们就来对这块内容做一下分析，看看<code>janus</code>是如何实现<code>plugin</code>的，以及它的工作原理是怎样的。</p><a id="more"></a><h2 id="janus的架构模型"><a href="#janus的架构模型" class="headerlink" title="janus的架构模型"></a>janus的架构模型</h2><p><code>janus</code>的最大特色就是可以以插件的方式对业务模块进行管理。比如当你想实现新业务时，按照<code>janus Plugin</code>的要求写一个<code>plugin</code>，然后将它放到指定目录下，这样<code>janus</code>在启动时就可以将它加载到内存中。</p><p>下面这张图是janus的整体架构图：</p><p><img data-src="https://cdn.avdancedu.com/image/article/janus_plugin/janus_plugin.png" alt="janus架构图"></p><p>从上面这张图我们可以看到，<code>janus</code>在设计时被分成了两层，即<code>核心层</code>和<code>插件层</code>。核心层主要用于资源的分配（如线程的启动与分配）、底层事件处理、各种WebRTC协议的实现及处理等；插件层用于业务处理，各种传输类型命令的处理等。</p><p>从中我们可以知道，这样的架构设计及管理方式特别适合变化比较快的业务模型。因为我们可以随时生成一个新的janus插件，并将它加载到内存中。</p><p>OK，了解了<code>janus</code>的架构，我们再来看看janus是如何实现插件管理的吧。</p><h2 id="Linux-系统下动态库的动态加载"><a href="#Linux-系统下动态库的动态加载" class="headerlink" title="Linux 系统下动态库的动态加载"></a>Linux 系统下动态库的动态加载</h2><p>要想真正理解janus的插件管理，我们首先要知道Linux系统是如何动态加载库的，这是我们理解 janus 插件管理的基础。</p><p>在Linux系统中，动态加载库其实很容易，只要用两个API 就可以了，即 <strong>dlopen</strong> 和 <strong>dlsym</strong> 。它们的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;dlfcn.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  path: 被加载到内存中的动态库路径</span><br><span class="line"> *  mode: RTLD_LAZY，用时加载；RTLD_NOW，立即加载；</span><br><span class="line"> *  return: handle，即被加载的动态库的内存地址</span><br><span class="line"> *&#x2F;</span><br><span class="line">void* dlopen(const char* path, int mode);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * handle: dlopen 的返回值</span><br><span class="line"> * symbol: 指向动态库中的符号，如函数，变量等</span><br><span class="line"> * return: 返回在内存中的符号地址</span><br><span class="line"> *&#x2F;</span><br><span class="line">void* dlsym(void* handle, const char* symbol);</span><br></pre></td></tr></table></figure><p>其中，<strong>dlopen</strong> 用于将动态库加载到内存中；<strong>dlsym</strong> 用于查找被加载到内存中的动态库的函数或变量的地址。</p><p>接下来我们就使用这两个API 来演示一下如何在 Linux 系统下动态加载库。</p><p>要想做这个演示，首先我们要写一个动态库。这个动态库特别简单，就一个函数 <strong>add()</strong> ， 用于加法运算。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;源码</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int add(int a, int b)&#123;</span><br><span class="line">  return a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;编译</span><br><span class="line">gcc -shared -o add.so add.c</span><br></pre></td></tr></table></figure><p>通过上面的操作我们就有了一个add.so的动态库。接下来我们再来看看如何使用 <strong>dlopen</strong> 及 <strong>dlsym</strong> 将上面生成的库动态库加载到内存中，并调用它的 <strong>add()</strong> 方法吧。具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include &lt;dlfcn.h&gt;</span><br><span class="line"></span><br><span class="line">typedef int(*FUNC)(int,int);</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])&#123;</span><br><span class="line">  void* handler &#x3D; dlopen(&quot;.&#x2F;add.so&quot;, RTLD_NOW);</span><br><span class="line">  if(!handler)&#123;</span><br><span class="line">    printf(&quot;Failed to load so!\n&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  FUNC func &#x3D; (FUNC)dlsym(handler, &quot;add&quot;);</span><br><span class="line">  int r &#x3D; func(10, 20);</span><br><span class="line">  printf(&quot;the result is : %d\n&quot;, r);</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;编译</span><br><span class="line">gcc -g -o loadso mytest.c</span><br></pre></td></tr></table></figure><p>上面的这段代码是不是很简单？短短的几行代码就向你展示了在 Linux/Mac 系统下动态加载并调用动态库中方法的具体步骤。有了上面的知识，我们再来看janus的实现就很容易理解它是如何做的了。</p><h2 id="janus-加载Plugin"><a href="#janus-加载Plugin" class="headerlink" title="janus 加载Plugin"></a>janus 加载Plugin</h2><p>janus实现加载插件的代码量很大，但核心代码就那么几行，只要我们将核心代码抽取出来，我们就会发现其实它与我们上面讲的代码几乎是一模一样的。下面我们来看看janus 是如何动态加载库的吧。</p><p>为了方便janus专门创建了一个目录用于存放插件。在janus启动时它会遍历该目录，并将目录中的插件一个个动态加载到内存中。经整理后的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>((pluginent = readdir(dir))) &#123;</span><br><span class="line">  ......</span><br><span class="line">  g_snprintf(pluginpath, <span class="number">1024</span>, <span class="string">"%s/%s"</span>, path, pluginent-&gt;d_name);</span><br><span class="line">  <span class="keyword">void</span> *plugin = dlopen(pluginpath, RTLD_NOW |   RTLD_GLOBAL);</span><br><span class="line">  ......</span><br><span class="line">  create_p *create = (create_p*) dlsym(plugin, <span class="string">"create"</span>);</span><br><span class="line">  ......</span><br><span class="line">  janus_plugin *janus_plugin = create();</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的这段核心代码是不是与我们上面 <strong>Linux 系统下动态库的动态加载</strong> 一节介绍的几乎是一样的？所以我们只要把基础知识撑握好了，再看一些复杂的实现时也就不会感觉很难了。</p><p>从上面的代码中我们还可以看到，janus 中的每个插件都实现了create 函数。该函数会返回一个包含多个函数的结构体。这些函数是我们实现janus插件必须要实现的，它们包括:</p><ul><li><code>init()</code>: 该函数是插件的初始化函数，像读取配置文件等操作都应该在这个函数中实现。</li><li><code>destroy()</code>: 插件被关闭的时候被调用</li><li><code>get_api_compatibility()</code>: 该方法只需要返回janus的API版本即可，用于控制不同janus版本是否兼容</li><li><code>get_version()</code>: 返回版本号(例如 3)</li><li><code>get_version_string()</code>: 返回字符串格式的版本号(例如, “v1.0.1”)</li><li><code>get_description()</code>: 返回插件的详细信息</li><li><code>get_name()</code>: 返回插件的短名子</li><li><code>get_package()</code>:返回插件的唯一包标识 (例如., “janus.plugin.myplugin”);</li><li><code>create_session()</code>: 在你和客户端之间创建一个session</li><li><code>handle_message()</code>: 处理对方发送给你的消息</li><li><code>handle_admin_message()</code>: 来自Admin API的消息</li><li><code>setup_media()</code>: 创建socket，建立与客户端<code>peerConnection</code>之间的连接</li><li><code>incoming_rtp()</code>: 接收客户端发过来的<code>rtp</code>包</li><li><code>incoming_rtcp()</code>: 接收客户端发过来的<code>rtcp</code>消息</li><li><code>incoming_data()</code>: 接收客户端通过<code>SCTP DataChannel</code>发过来的数据</li><li><code>data_ready()</code>: 检查数据是否可以通过<code>SCTP DataChannel</code>发送了</li><li><code>slow_link()</code>: 客户端发过来很多<code>NACK</code>，说是此时网络质量变差了</li><li><code>hangup_media()</code>: 客户端关闭了<code>PeerConnection</code></li><li><code>query_session()</code>: 查询在你与客户端之间的<code>session</code>信息</li><li><code>destroy_session()</code>: 销毁<code>session</code></li></ul><p>对于一个插件来讲，上面的方法中除了 <code>incoming_rtp</code> 、<code>incoming_rtcp</code>、<code>incoming_data</code> 可以不实现外，其它的方法都必须实现。只有这样当插件被<code>janus</code>核心层加载之后，才可以被顺利的调用。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我重点向你介绍了<code>janus</code>是如何使用和管理<code>plugin</code>的，同时向你简要的介绍了<code>janus</code>的架构模型以及要实现一个<code>janus</code>插件要实现哪些函数。</p><p>当然，我们这里只是对<code>plugin</code>做了一个大体的讲解，很多细节这里并没有讲到，我会在后面的文档中做更详细的介绍 。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门》</a></li><li><a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">《百万级高并发WebRTC流媒体服务器设计与开发》</a></li><li><a href="https://time.geekbang.org/column/intro/207" target="_blank" rel="noopener">《从0打造音视频直播系统》</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;janus&lt;/code&gt;中的&lt;code&gt;plugin&lt;/code&gt;是其非常重要的一部分内容，今天我们就来对这块内容做一下分析，看看&lt;code&gt;janus&lt;/code&gt;是如何实现&lt;code&gt;plugin&lt;/code&gt;的，以及它的工作原理是怎样的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/categories/WebRTC/"/>
    
    
      <category term="plugin" scheme="https://blog.avdancedu.com/tags/plugin/"/>
    
  </entry>
  
  <entry>
    <title>janus深入分析系列文章</title>
    <link href="https://blog.avdancedu.com/aafa6b93/"/>
    <id>https://blog.avdancedu.com/aafa6b93/</id>
    <published>2020-06-29T02:04:44.000Z</published>
    <updated>2020-06-29T06:21:04.193Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/janus_deep/janus_deep.jpg" alt=""></p><p>说到WebRTC流媒体服务器就不得不提<code>janus</code>，它是WebRTC众多流媒体服务器中的重要一员，其以优越的性能、丰富的功能、灵活的配置而著称。由于工作的原因，最近这段时间一直在分析<code>janus</code>，陆续整理出了我对janus的一些分析，希望这些文章对你了解<code>janus</code>能有所帮助。</p><a id="more"></a><h2 id="janus系列文章"><a href="#janus系列文章" class="headerlink" title="janus系列文章"></a>janus系列文章</h2><p>下面的这些文章是按照<strong>认知</strong>、<strong>使用</strong>、<strong>逐步深入</strong>的顺序做了编排，这种阅读顺序应该会使你更容易理解<code>janus</code>的整个运行机制。</p><ul><li><a href="http://avdancedu.com/947c722a/" target="_blank" rel="noopener">WebRTC流媒体服务器比较</a></li><li><a href="https://avdancedu.com/ed54b3d4/" target="_blank" rel="noopener">音视频会议系统-janus的编译与安装</a></li><li><a href="https://avdancedu.com/fdfe2594/" target="_blank" rel="noopener">janus各文件及目录的作用</a></li><li><a href="https://avdancedu.com/8f43ddc9/" target="_blank" rel="noopener">深入理解janus的线程模型</a></li><li><a href="https://avdancedu.com/26c3d930/" target="_blank" rel="noopener">深入理解janus的插件管理</a></li><li><a href="https://avdancedu.com/bb906872/" target="_blank" rel="noopener">janus的videoroom插件信令实现</a></li><li><a href="https://avdancedu.com/d7281c13/" target="_blank" rel="noopener">janus.js源码分析</a></li><li><a href="https://avdancedu.com/5ae5ee2f/" target="_blank" rel="noopener">janus.js的使用</a></li></ul><p>更深入的文章还在不断整理中，会陆续加到这个系列文章中来。如果你感兴趣也可以将你的分析心得放到这里，与大家一起分享。</p><p>另外，也欢迎大家一起讨论，文中有描述的不清楚的地方也希望大家指正批评！ </p><p>谢谢！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://coding.imooc.com/class/415.html" target="_blank" rel="noopener">音视频系统入门</a></li><li><a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">WebRTC入门与实战</a></li><li><a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">百万级WebRTC流媒体服务器设计与开发</a></li><li><a href="https://time.geekbang.org/column/article/132863" target="_blank" rel="noopener">从0开始打造音视频直播系统</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/janus_deep/janus_deep.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;说到WebRTC流媒体服务器就不得不提&lt;code&gt;janus&lt;/code&gt;，它是WebRTC众多流媒体服务器中的重要一员，其以优越的性能、丰富的功能、灵活的配置而著称。由于工作的原因，最近这段时间一直在分析&lt;code&gt;janus&lt;/code&gt;，陆续整理出了我对janus的一些分析，希望这些文章对你了解&lt;code&gt;janus&lt;/code&gt;能有所帮助。&lt;/p&gt;
    
    </summary>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/categories/WebRTC/"/>
    
    
      <category term="janus" scheme="https://blog.avdancedu.com/tags/janus/"/>
    
  </entry>
  
  <entry>
    <title>janus各文件及目录的作用</title>
    <link href="https://blog.avdancedu.com/fdfe2594/"/>
    <id>https://blog.avdancedu.com/fdfe2594/</id>
    <published>2020-06-28T11:57:29.000Z</published>
    <updated>2020-06-29T05:31:43.573Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/janus_file/janus_arch.jpg" alt="janus架构图"></p><p>在<a href="https://avdancedu.com/ed54b3d4/" target="_blank" rel="noopener">《音视频会议系统-janus的安装与布署》</a>一文中我已经向你介绍了如何布署<code>janus</code>，今天我们再来了解一下<code>janus</code>的源码，看看<code>janus</code>包括哪些文件以及它们所起的作用是什么。</p><a id="more"></a><h2 id="下载-janus-源码"><a href="#下载-janus-源码" class="headerlink" title="下载 janus 源码"></a>下载 janus 源码</h2><p><code>janus</code>源码可以在<a href="https://github.com/meetecho/janus-gateway" target="_blank" rel="noopener">这里</a>找到，执行下面命令就可将其下载下来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;meetecho&#x2F;janus-gateway.git</span><br><span class="line">cd janus-gateway</span><br></pre></td></tr></table></figure><h2 id="janus各源码文件的作用"><a href="#janus各源码文件的作用" class="headerlink" title="janus各源码文件的作用"></a>janus各源码文件的作用</h2><p>下载好<code>janus</code>源码后，你可以看到<code>janus</code>目录下有很多文件，这里我列出了比较重要的几个文件，下面来说明一下它们起所的作用是什么。目录列表如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">events           # 主要用于各种事件消息的分析</span><br><span class="line">plugins          # 各种业务插件，所有的业务应用都在这里实现</span><br><span class="line">transports       # 用于处理各种网络信令，HTTP、WebSocket、MQTT等</span><br><span class="line">docs             <span class="meta"># janus的文档，它是通过 Doxygen 生成的，janus的文档还是很全面的</span></span><br><span class="line">html             # Web端的Demo都放在这里</span><br><span class="line">rtcp.h           # RTCP 是RTP的控制协议</span><br><span class="line">rtcp.c           # RTCP 协议的具体实现</span><br><span class="line">rtp.c            # RTP协议的实现，它用于传输音视频数据</span><br><span class="line">rtp.h            # RTP 协议的头文件</span><br><span class="line">rtpsrtp.h        # SRTP 协议</span><br><span class="line">sctp.c           # SCTP 协议的实现</span><br><span class="line">sctp.h           # SCTP 协议的头文件</span><br><span class="line">sdp.c            # SDP 协议的实现</span><br><span class="line">sdp.h            # SDP 协议的头文件</span><br><span class="line">sdp-utils.c      # 处理 SDP 的常用工具</span><br><span class="line">sdp-utils.h</span><br><span class="line">test             # 测试文件所在目录</span><br><span class="line">record.c         <span class="meta"># janus的录制功能在该文件中实现</span></span><br><span class="line">record.h</span><br><span class="line">ice.c            <span class="meta"># janus 使用 libnice 实现 ICE 功能，该文件是对libnice库的封装</span></span><br><span class="line">ice.h</span><br><span class="line">janus.c          # 该文件是janus的主框架程序，里边做了很多事儿</span><br><span class="line">janus.h</span><br><span class="line"><span class="built_in">log</span>.c            # 日志</span><br><span class="line"><span class="built_in">log</span>.h</span><br><span class="line">dtls-bio.c       # DTLS 中 BIO 的实现</span><br><span class="line">dtls-bio.h</span><br><span class="line">dtls.c           # DTLS 协议实现</span><br><span class="line">dtls.h</span><br><span class="line">events.c         # 配合events插件与janus core连接用的</span><br><span class="line">events.h</span><br></pre></td></tr></table></figure><p>对于上面的文件我们可能将它们分成几大类：</p><ul><li>业务插件，<code>plugins</code>目录下的所有文件都属于该类，其主要作用是实现不同的业务逻辑的服务端，如<code>echotest</code>、<code>videoroom</code>、<code>videocall</code>等。</li><li>事件分析，<code>events</code>目录下的所有文件以及<code>events.c|h</code>，其作用是收集事件消息，做分析使用。这个功能只能高级用户才会用，对于一般用户来说可以不关注它。</li><li>协议，包括 <code>rtp.c|h</code>、<code>rtcp.c|h</code>、<code>rtpsrtp.h</code>、<code>stcp.c|h</code>、<code>sdp.c|h</code>、<code>dtls.c|h</code>、<code>dtls-bio.c|h</code>，这些都是用于处理不同协议的，每个文件都比较独利。</li><li>日志，包括 <code>log.c|h</code>，这个应该一眼就可以看出来。</li><li>浏览器Demo，<code>html</code>目录中的所有文件，主要包括一些demo程序，如videoroom、echotest等。</li><li>信令传输，<code>transports</code>目录下的文件属于该类，作用是接收不同传输协议发送过来的消息，并使用同样的协议将响应消息返回。</li><li>数据传输，<code>ice.c|h</code>，它是对<code>libnice</code>库的封装，用于媒体数据的传输。</li><li>janus核心，<code>janus.c|h</code>，这是<code>janus</code>中最核心的文件，程序的启动，插件的加载，数据的流转都是通过它来实现的。</li></ul><p>在上面几个类别中， <strong>janus核心</strong>、<strong>数据传输</strong>、<strong>信令传输</strong>、<strong>业务插件</strong>、<strong>浏览器Demo</strong> 中的代码是比较重要的，所以是你在阅读代码时需要重点看的内容。由于<strong>信令传输</strong>、<strong>业务插件</strong>、<strong>浏览器Demo</strong>都是目录，里边还包括了很多文件，所以下面我们再来看看这三个目录中都包括了那些文件。</p><h3 id="信令传输"><a href="#信令传输" class="headerlink" title="信令传输"></a>信令传输</h3><p>进入到 <code>transports</code> 目录，你会它有以下几个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">transport.h             # 定义了&#96;信令传输&#96;插件的接口</span><br><span class="line">transport.c             # 定义了几个通用的释放资源的函数</span><br><span class="line">janus_http.c            # HTTP 接口，默认使用的接口</span><br><span class="line">janus_mqtt.c            # MQTT 接口，编译时需要明确指定才会编入janus</span><br><span class="line">janus_pfunix.c          # UNIX 接口</span><br><span class="line">janus_nanomsg.c         # NanoMSG 接口</span><br><span class="line">janus_rabbitmq.c        # RabbitMQ 接口</span><br><span class="line">janus_websockets.c      # Websocket 接口</span><br></pre></td></tr></table></figure><p><code>janus</code>支持的信令接口方式还是蛮全的，这是它的一大优势。用户可以选择自己喜欢的接入方式进行接入。通过上面的描述你应该很容易判断出每个文件的作用，你对那个感兴趣就可以专门看那个文件。默认情况下<code>janus</code>使用的是HTTP接口，因此该接口也是最成熟的。</p><h3 id="业务插件"><a href="#业务插件" class="headerlink" title="业务插件"></a>业务插件</h3><p><code>janus</code>支持很多业务插件，这对于很多用户来说也是一个非常棒的特点，我们来看一下它都支持那些插件吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">plugin.h                # 定义了业务插件的接口</span><br><span class="line">plugin.c                # 实现了一些公用的释放资源的函数</span><br><span class="line">janus_echotest.c        # 回显业务插件</span><br><span class="line">janus_videocall.c       # 1:1视频通讯业务插件</span><br><span class="line">janus_videoroom.c       # 会议业务插件</span><br><span class="line">janus_textroom.c        # 文本聊天室插件</span><br><span class="line">janus_streaming.c       # 传输直接流插件，可以播放视频文件，或其它的RTP数据流</span><br><span class="line">streams</span><br><span class="line">janus_recordplay.c      # 录制回放业务插件</span><br><span class="line">recordings</span><br><span class="line">janus_sip.c             # sip 业务插件，主要用于与电话业务的互通</span><br><span class="line">janus_nosip.c           # 包含sip信令业务插件，用它可以中转RTP数据</span><br><span class="line">janus_audiobridge.c     # 音频会议插件</span><br><span class="line">janus_voicemail.c       # 语言信箱业务插件</span><br><span class="line">janus_lua.c             # lua 语言开发插件</span><br><span class="line">janus_lua_extra.h</span><br><span class="line">janus_lua_extra.c</span><br><span class="line">janus_lua_data.h</span><br><span class="line">lua</span><br><span class="line">janus_duktape.c         # duktape语言插件</span><br><span class="line">janus_duktape_extra.h</span><br><span class="line">janus_duktape_extra.c</span><br><span class="line">janus_duktape_data.h</span><br><span class="line">duktape</span><br><span class="line">duktape-deps</span><br></pre></td></tr></table></figure><p>通过上面的文件列表，我们看到<code>janus</code>支持的插件可真不少，有会议视会议的、1：1通话的、SIP、RTP、流…等等。这些插件几乎含盖的所有的业务场景。对于用户来话，要以根据自己的需求选择上面的业务插件进行修改即可完成自己的业务了。</p><p>最后我们再来看看客户端 Demo。</p><h3 id="HTML-Demo"><a href="#HTML-Demo" class="headerlink" title="HTML Demo"></a>HTML Demo</h3><p>在<code>janus</code>的html目录中有很多文件，其中大部分文件是与上面<code>业务插件</code>中的内容是对应的。也就是说一个业务插件对应一个HTML Demo。所以这块的内容大家自己看一下就可以了。我就不在这里一一列出来了。</p><p>通过上面的描述，我们大体上可以知道<code>janus</code>的实现并不是特别复杂。它实现了RTP/RTCP、SRTP、SCTP、DTLS/DTLS-BIO、SDP 等 WebRTC 必要的协议，而对于数据的传输则是使用<code>libnice</code> 库，并通过<code>ice.c|h</code>对libnice 做了一层封装。</p><p>除此之外，它所有的业务层都是以<code>plugin</code>的方式实现的，这对于后面的业务拓展有很大的优势。当我们要实现一个新业务时，只要按照 plugin 的规则进行开发就好了，非常简单。</p><p>另外，janus是用纯C实现的，并且使用了Linux社区丰常优秀的库<code>glib</code>(注意不是glibc)，这个库的性能非常好，对于在Linux 下开发的同学来说对它应该十分熟悉。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过本文，你应该对<code>janus</code>的源码有了一个大体功能的了解。由于<code>WebRTC</code>使用了很多的协议（如 RTP/RTCP、DTLS、SDP等），因此作为服务端的<code>janus</code>也必须实现这些协议，这样才能与<code>WebRTC</code>进行通信。</p><p>对于<code>janus</code>使用的这些协议可能很多同学会觉得一脸懵B，不知道其中的原理和作用，如果你对这块感兴趣的话，可以去看我的网课<a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门》</a>，在课程里我对这些协议都做了详细介绍。</p><p>如果你有一定基础的话，现在应该知道<code>janus</code>的实现并不是特别复杂，但它的架构设计还是很值得借鉴的，尤其是<code>plugin</code>的设计方案。</p><p>今天我只是对<code>janus</code>做个初步分析，后面会对它的一些性能做下详细分析，静请期待！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门》</a></li><li><a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">《百万级高并发WebRTC流媒体服务器设计与开发》</a></li><li><a href="https://time.geekbang.org/column/intro/207" target="_blank" rel="noopener">《从0打造音视频直播系统》</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/janus_file/janus_arch.jpg&quot; alt=&quot;janus架构图&quot;&gt;&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://avdancedu.com/ed54b3d4/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《音视频会议系统-janus的安装与布署》&lt;/a&gt;一文中我已经向你介绍了如何布署&lt;code&gt;janus&lt;/code&gt;，今天我们再来了解一下&lt;code&gt;janus&lt;/code&gt;的源码，看看&lt;code&gt;janus&lt;/code&gt;包括哪些文件以及它们所起的作用是什么。&lt;/p&gt;
    
    </summary>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/categories/WebRTC/"/>
    
    
      <category term="janus" scheme="https://blog.avdancedu.com/tags/janus/"/>
    
  </entry>
  
  <entry>
    <title>音视频会议系统-janus的编译与布署</title>
    <link href="https://blog.avdancedu.com/ed54b3d4/"/>
    <id>https://blog.avdancedu.com/ed54b3d4/</id>
    <published>2020-06-28T11:13:12.000Z</published>
    <updated>2020-06-29T04:13:49.754Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/janus_deploy/janus.jpg" alt=""></p><p>说到WebRTC流媒体服务器就不得不提janus。说实话我以前对这款流媒体服务器并没有进行特别深入的研究，不过2019年10月我有幸作为声网RTC大会 Workshop 分会场的主讲嘉宾及串场人与janus的创始人<strong>Lorenzo Miniero</strong>有了一次深入交流，从中了解到janus的强大，因此决定有时间一定要对janus做下深入分析。</p><a id="more"></a><p><img data-src="https://cdn.avdancedu.com/image/article/janus_deploy/agora.jpg" alt="声网RTC大会"></p><p>正好前段时间忙完了手头的一些工作，终于可以有时间来对janus做详细研究了，而本篇则是对janus分析的第一篇文章。</p><p>下面我们就来看一下如何在一台 Ubuntu 系统下安装布署 janus。</p><h1 id="janus的布署方法"><a href="#janus的布署方法" class="headerlink" title="janus的布署方法"></a>janus的布署方法</h1><p>不得不说janus提供的文档还是非常全面的，如果你英文比较好的话，完全可以按它的文档进行操作。但对于一些新手来说，通过阅读本文可以让你快速的在本机搭建出janus Demo，所以本文对你仍然是非常有意义的。</p><h2 id="布署环境"><a href="#布署环境" class="headerlink" title="布署环境"></a>布署环境</h2><p>janus的官方文档建议你把它安装在Linux系统上，可以是 Ubuntu、CentOS等。当然你也可以在MacOS上安装它，而文档中明确说明它不支持Ｗindows系统，因此千万不要再在Windows上浪费时间了。</p><p>对于我来说，我一直比较倾向于使用Ubuntu系统，最主要的原因是安装依赖包比较方便。如果你是Linux新手，我更是强烈推建你使用Ubuntu，这样可以让你更快速入门Linux。而CentOS安装依赖包则会麻烦得多，虽然它也提供yum（类似Ubuntu中的apt）工具，但有很多库都必须通过源码编译的方式安装，这样很繁琐。</p><p>今天我们就使用<strong>Ubuntu系统</strong>作为janus的布署环境，而且这个环境是一台<strong>本地主机</strong>，而不是云主机，这样可以大大减少很多不必要的麻烦。</p><h2 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h2><p>在我们正式布署janus之前，需要先在Ubuntu系统上安装上必要的依赖包。在Ubuntu上安装依赖包非常方便，只要执行下面的命令就好了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libmicrohttpd-dev libjansson-dev \</span><br><span class="line">       libssl-dev libsofia-sip-ua-dev libglib2.0-dev libopus-dev \</span><br><span class="line">       libogg-dev libcurl4-openssl-dev liblua5.3-ev libconfig-dev\</span><br><span class="line">       pkg-config gengetopt libtool automake libscrtp-dev \</span><br><span class="line">               libwebsockets-dev  librabbitmq-dev libnanomsg-dev libnice-dev \</span><br><span class="line">               gtk-doc-tools doxygen graphviz</span><br></pre></td></tr></table></figure><p>除了以上这些可以通过 apt工具安装的依赖包外，还有一个依赖库是必须通过源码安装的，它就是libsrtp库。</p><p>libsrtp库的主要作用是对数据进行加密。之所以要通过源码安装，是因为在apt源上的libsrtp库没有将ssl库编译上，而janus又需要使ssl库对数据做最终的加密，所以我们只能使用源码的方式安装了。具体操作步骤如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;cisco&#x2F;libsrtp&#x2F;archive&#x2F;v2.2.0.tar.gz</span><br><span class="line">tar xfv v2.2.0.tar.gz</span><br><span class="line">cd libsrtp-2.2.0</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr --enable-openssl</span><br><span class="line">make shared_library &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure><h2 id="编译安装janus"><a href="#编译安装janus" class="headerlink" title="编译安装janus"></a>编译安装janus</h2><p>布署环境搭建好之后，编译安装janus还是非常简单的，就按下面的三步执行就好了：</p><ul><li>下载 janus 源码</li><li>执行 ./configure 生成 Makefile 文件</li><li>执行 make -j 4 &amp; sudo make install</li></ul><p>首先我们来看看如何下载janus的源码，操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;meetecho&#x2F;janus-gateway.git</span><br><span class="line">cd janus-gateway</span><br></pre></td></tr></table></figure><p>源码下载好后，执行./configure就可以生成Makefile文件了。但需要注意的是，在执行./configure之前，先要执行autogen.sh脚本，这样才能生成./configure文件。具体操作步骤如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;autogen.sh</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;janus</span><br></pre></td></tr></table></figure><p>当./configure执行完成后，Makefile文件就生成了，紧接着我们要开始编译安装 janus 了。按下面的执行步骤操作就好了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make -j 4</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>通过上面的步骤，我们就将janus编译好并成功安装了。</p><h1 id="启动janus"><a href="#启动janus" class="headerlink" title="启动janus"></a>启动janus</h1><p>安装好janus 后，启动它非常容易，但在启动之前，我们还要为它准备好配置文件。</p><p>janus在启动时会分析配置文件，然后按照配置文件中的信息启动加载对应的模块。该如何构建配置文件呢？对于初学janus的新手来说，看到janus有一堆的参数，在构造配置文件时可能就有点懵了。</p><p>不过janus已经为我们想好了解决方案，就是从它的配置文件模板中拷贝一份作为janus的配置文件。其中最简单的就是将 janus.jcfg.sample作为配置文件即可。具体操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;installdir&gt;&#x2F;etc&#x2F;janus&#x2F;</span><br><span class="line">cp janus.jcfg.sample janus.jcfg</span><br></pre></td></tr></table></figure><p>有了janus配置文件之后，我们就可以直接启动janus了，执行如下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;janus</span><br></pre></td></tr></table></figure><p>OK，到目前为止，我们就已经将janus启动好了。此时，如果有用户连接janus的话，你就可以从终端上看到对应的连接信息。</p><p>上面的启动方式非常适合于我们观察和调试janus，但如果你想让它像服务器一样一直运行，则需要让janus到Linux系统的后台运行。这该如何实现呢？其实操作也很简单，只要执行下面的命令就好了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;janus &amp;</span><br></pre></td></tr></table></figure><h1 id="janus-Demo的布署"><a href="#janus-Demo的布署" class="headerlink" title="janus Demo的布署"></a>janus Demo的布署</h1><p>通过上面的步骤我们已经将janus网关布署好了，但此时janus Demo还无法使用，我们还必须搭建一台WebServer，将janus Demo 客户端发布出来才行。</p><p>关于WebServer的搭建方法我这里就不做详细介绍了，大家应该在网上都可以找到方法，比如使用 nginx、nodejs、Apache、Tomcat等都是可以的。</p><p>当WebServer搭建好后，将/usr/local/janus/share/janus/demo目录中的内容全部拷贝到WebServer的发布目录下即可，这样我们就大功告成了！</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>通过上面的描述，我们就将如何搭建janus Demo的步骤向你做了详细的介绍，让你知道了如何在Ubuntu下搭建janus服务，又该如何将janus Demo布署好。总结起来就是以下三步：</p><ul><li>安装依赖包</li><li>编译安装janus</li><li>布署WebServer，并将 janus Demo 代码放到 WebServer发布目录下</li></ul><p>需要注意的是，我这里提供的方法只适用于本机，如果你想在云服务器上布署 janus的话，还有其它一些工作要做。对于这一点，我在这里就不做详细论述了，有兴趣的同学可以去参考我在慕课网的课程。</p><p>谢谢！</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">《百万级高并发WebRTC流媒体服务器设计与开发》</a></li><li><a href="https://time.geekbang.org/column/intro/207" target="_blank" rel="noopener">《从0打造音视频直播系统》</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/janus_deploy/janus.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;说到WebRTC流媒体服务器就不得不提janus。说实话我以前对这款流媒体服务器并没有进行特别深入的研究，不过2019年10月我有幸作为声网RTC大会 Workshop 分会场的主讲嘉宾及串场人与janus的创始人&lt;strong&gt;Lorenzo Miniero&lt;/strong&gt;有了一次深入交流，从中了解到janus的强大，因此决定有时间一定要对janus做下深入分析。&lt;/p&gt;
    
    </summary>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/categories/WebRTC/"/>
    
    
      <category term="janus" scheme="https://blog.avdancedu.com/tags/janus/"/>
    
  </entry>
  
  <entry>
    <title>正确理解glib main loop</title>
    <link href="https://blog.avdancedu.com/40f49286/"/>
    <id>https://blog.avdancedu.com/40f49286/</id>
    <published>2020-06-26T15:08:55.000Z</published>
    <updated>2020-06-27T10:07:29.817Z</updated>
    
    <content type="html"><![CDATA[<p>我想应该很多人都不太了解<code>glib</code>库，只有那些长时间在Linux系统上搞开发的同学才知道这个库。但即便知道有这么一个库，使用它的人也少之又少。</p><p><code>glib</code>库是<code>Linux</code>系统下极重要的一个<code>C</code>语言开发的开源库，Linux系统下很多开具都是以它为基础的，比如说<code>GTK</code>、<code>gstreamer</code>以及我向大家介绍的<code>janus</code>程序。</p><a id="more"></a><p><code>glib</code>库涉及的内容很多，今天我主要给大家介绍一下<code>glib</code>中的<code>main loop</code>机制。实际<code>glib</code>的<code>main loop</code>在它的官方文档中有清晰的说明，地址在<a href="https://developer.gnome.org/glib/stable/glib-The-Main-Event-Loop.html#g-main-loop-new" target="_blank" rel="noopener">这里</a>大家可以自己阅读一下。</p><h2 id="什么是Main-Loop"><a href="#什么是Main-Loop" class="headerlink" title="什么是Main Loop"></a>什么是Main Loop</h2><p>实际上，<code>GLib</code>的<code>Main Loop</code>就是对 <code>select</code>、<code>pool</code>、<code>epoll</code>的封装。它可以处理不同类型的<code>源</code>，像文件描述符（普通文件、管道、socket)和超时。新的事件源类型可以通过<code>g_source_attach</code>添加到<code>Main Loop</code>上。</p><p>为了可以在不同的线程中处理不同的<code>源</code>集，每个<code>源</code>都与一个<code>GMainContext</code>相关。一个<code>GMainContext</code>只能运行在一个线程中，但<code>源</code>是可以跨线程的。在GMainContext或内置GSource上运行的所有函数都是线程安全的。</p><p>每个<code>源</code>都有没一个优先级，默认是<code>G_PRIORITY_DEFAULT</code>，也就是0。小于0的值有更高的优先权。高优先级的<code>源</code>总是优先于低优先级的<code>源</code>得到处理。</p><p>idle函数也能添加到<code>MainLoop</code>中，当没有任何更高优先级的事件需要处理时就会执行它。</p><p><code>GMainLoop</code>表示一个主循环。它由<code>g_main_loop_new</code>函数创建。添加了初始化事件源后，就可以调用<code>g_main_loop_run()</code>函数了。该函数会持续的检测每个事件源是否有新事件，然后处理这些新事件。当不需要处理事件时，可以调用<code>g_main_loop_quit()</code>退出<code>main loop</code>。</p><h2 id="如何创建一个新的事件源"><a href="#如何创建一个新的事件源" class="headerlink" title="如何创建一个新的事件源"></a>如何创建一个新的事件<code>源</code></h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我想应该很多人都不太了解&lt;code&gt;glib&lt;/code&gt;库，只有那些长时间在Linux系统上搞开发的同学才知道这个库。但即便知道有这么一个库，使用它的人也少之又少。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;glib&lt;/code&gt;库是&lt;code&gt;Linux&lt;/code&gt;系统下极重要的一个&lt;code&gt;C&lt;/code&gt;语言开发的开源库，Linux系统下很多开具都是以它为基础的，比如说&lt;code&gt;GTK&lt;/code&gt;、&lt;code&gt;gstreamer&lt;/code&gt;以及我向大家介绍的&lt;code&gt;janus&lt;/code&gt;程序。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="glib" scheme="https://blog.avdancedu.com/tags/glib/"/>
    
  </entry>
  
  <entry>
    <title>janus.js的使用</title>
    <link href="https://blog.avdancedu.com/5ae5ee2f/"/>
    <id>https://blog.avdancedu.com/5ae5ee2f/</id>
    <published>2020-06-24T12:48:27.000Z</published>
    <updated>2020-06-29T05:30:35.457Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/janus_jscall/jscall.jpg" alt=""></p><p>之前我在<a href="https://avdancedu.com/d7281c13/" target="_blank" rel="noopener">《janus前端核心库源码分析》</a>一文中已经向你详细分析了<code>janus.js</code>文件的实现，但对于大多同学来说，知道如何使用它才是最重要的。那具体我们该如何使用它呢？janus中的<code>videoroomtest.js</code>是一个不错的例子，今天就来分析一下<code>videoroomtest.js</code>，看看它是是如何使用<code>janus.js</code>的。</p><a id="more"></a><p>通过分析<code>videoroomtest.js</code>文件，你会发现使用<code>janus.js</code>的步骤很简单，只要下面三步即可：</p><ul><li>初始化<code>janus.js</code></li><li>创建<code>Janus</code>对象</li><li>attach 音视频流</li></ul><p>下面我就按上面的顺序向你逐一介绍<code>videoroomtest.js</code>是如何使用<code>janus.js</code>的。</p><h2 id="janus的初始化"><a href="#janus的初始化" class="headerlink" title="janus的初始化"></a>janus的初始化</h2><p>我们使用<code>janus.js</code>之前，第一步就是调用<code>Janus</code>的<code>类</code>方法<code>init</code>来初始化<code>janus.js</code>。方法的原型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Janus.init &#x3D; function(options)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>init</code>方法需要一个<code>JSON</code>格式的输入参数，它包括两个<code>域</code>: <code>debug</code>和一个回调函数<code>callback</code>。这样当<code>init</code>执行完成后，就可以通过<code>callback</code>将结果返回到应用层了。<code>videoroomtest.js</code>调用<code>Janus.init</code>的代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Janus.init(</span><br><span class="line">            &#123;</span><br><span class="line">                debug: &quot;all&quot;,</span><br><span class="line">                callback: function()&#123;...&#125;</span><br><span class="line">            &#125;</span><br><span class="line">          );</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面的代码非常简单，关键的一点是我们要知道传入的参数是<code>JSON</code> 格式的，它有两个域<code>debug</code>和<code>callback</code>即可。知道如何调用了，接下来我们再来看看<code>init</code>函数的实现。</p><p><code>janus.js</code>的<code>init</code>方法实现了什么功能呢？我们把<code>Janus.init</code>方法中的主干逻辑抽取出来，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Janus.init &#x3D; function(options) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if(Janus.initDone) &#123;</span><br><span class="line">        options.callback();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ...</span><br><span class="line">        Janus.initDone &#x3D; true;</span><br><span class="line">        options.callback();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中的<code>initDone</code>表示的是之前是否初始化过<code>janus.js</code>？而<code>options</code>是<code>init</code>方法的输入参数，通过它可以回调应用层。通过上面的代码我们可以知道<code>init</code>方法的功能其实蛮简单的，就是将<code>initDone</code>置位，并回调应用层。</p><p>接下来我们看一下<code>init</code>回调应用层后，在应用层又做了什么事儿。 输入参数<code>options</code>的<code>callback</code>方法在<code>videoroomtest.js</code>中是一个<code>匿名函数</code>，其主干逻辑代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">callback: function() &#123;</span><br><span class="line">    $(&#39;#start&#39;).one(&#39;click&#39;, function() &#123; ... &#125; )</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>正如你上面看到的，<code>callback</code>函数只有一行关键代码，即给<code>start</code> 键钮绑定了一个<code>click</code>方法。当用户点击<code>start</code>时执行该方法。那么应用层在<code>start</code>方法中又做了哪些事儿呢？</p><h2 id="创建Janus对象"><a href="#创建Janus对象" class="headerlink" title="创建Janus对象"></a>创建Janus对象</h2><p>下面的代码就是<code>start</code>方法的主逻辑，从中我们可以知道<code>start</code>方法中完成了使用<code>janus.js</code>的第二个关键步骤，即创建<code>Janus</code>对象。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">if(!Janus.isWebrtcSupported()) &#123;</span><br><span class="line">    ...</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">janus &#x3D; new Janus(</span><br><span class="line">                    &#123;</span><br><span class="line">                        server: server,</span><br><span class="line">                        success: function() &#123; ... &#125;,</span><br><span class="line">                        error: function(error) &#123; ... &#125;,</span><br><span class="line">                        destroyed: function() &#123; ... &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                 );</span><br></pre></td></tr></table></figure><p>在该方法中首先判断<code>浏览器</code>是否支持<code>WebRTC</code>，如果不支持则直接退出，否则创建<code>Janus</code>对象。在创建<code>Janus</code>对象时，需要给它传入了一个<code>JSON</code>格式的参数，该<code>JSON</code>对象包括以下几个<code>域</code>：</p><ul><li>server，Janus服务器地址</li><li>success，连接成功后执行的回调函数</li><li>error，连接失败后执行的回调函数</li><li>destroyed，连接销毁时的回调函数</li></ul><p>在上述几个<code>域</code>中，最关键的是<code>success</code>回调函数。它的含义是当Janus对象创建成功后，回调该函数到应用层。但对于这个回调函的详细介绍我们先<code>暂时</code>放一放，现在我们先来看看创建<code>Janus</code>对象时都做了哪些事儿，然后再来分析<code>success</code>回调函数。</p><p>Janus类的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function Janus(gatewayCallbacks) &#123;</span><br><span class="line">    ...</span><br><span class="line">    createSession(gatewayCallbacks);</span><br><span class="line">    ...</span><br><span class="line">    this.attach &#x3D; function(callbacks) &#123; createHandle(callbacks); &#125;;</span><br><span class="line">    function handleEvent(json, skipTimeout) &#123; ... &#125;;</span><br><span class="line">    function keepAlive() &#123;&#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建Session</span><br><span class="line">    function createSession(callbacks) &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F;与服务器相连</span><br><span class="line">        Janus.httpAPICall(server,</span><br><span class="line">                          &#123;</span><br><span class="line">                            ...</span><br><span class="line">                            &#x2F;&#x2F;处理服务器发过来的消息</span><br><span class="line">                            success: handleEvent(...)&#123; ... &#125;;</span><br><span class="line">                            ...</span><br><span class="line">                          &#125;);</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;绑定媒体流</span><br><span class="line">    function createHandle(callbacks) &#123;...&#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>通过上面的代码我们可以知道，在创建<code>Janus</code>对象时它会调用<code>createSession</code>函数。而在<code>createSession</code>函数内部会通过<code>Janus</code>的<code>类</code>方法<code>httpAPICall</code>与服务端建立<code>HTTP</code>连接。连接建立成功后，会回调<code>success</code>函数，也就是类中的<code>handleEvent</code>方法。</p><p><code>handleEvent</code>的功能我在<a href="https://avdancedu.com/d7281c13/" target="_blank" rel="noopener">《janus前端核心库源码分析》</a>一文中已经介绍过，它用于处理服务端发来的消息，并根据不同的消息类型做不同的逻辑处理。</p><p>现在我们可以总结一下创建<code>Janus</code>对象所做的事儿啦，其实就两件事儿：一与<code>janus</code>服务器建立连接(HTTP/WebSocket/…)；二处理<code>janus</code>服务器发来的各种消息。</p><p>接下来我们再来讨论一下<code>Janus</code>对象创建成功后，回调<code>success</code>干了些什么吧！</p><h2 id="attach-绑定媒体流"><a href="#attach-绑定媒体流" class="headerlink" title="attach 绑定媒体流"></a>attach 绑定媒体流</h2><p>正如上面所说，<code>Janus</code>创建成功后会回调输入参数中的<code>success</code>函数。这个函数<code>特别重要</code>，下面我们来看看在该函数中实现了什么逻辑吧。</p><p>实际上，<code>success</code> 回调函数做的事儿也很简单，只是调用了 <code>janus.attach</code> 方法，<strong>而attach正是我们使用janus.js的第三步</strong>。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">success: function() &#123;</span><br><span class="line">    janus.attach(</span><br><span class="line">                    &#123;</span><br><span class="line">                        plugin: &quot;janus.plugin.videoroom&quot;,</span><br><span class="line">                        opaqueId: opaqueId,</span><br><span class="line">                        success: function(pluginHandle) &#123; ... &#125;,</span><br><span class="line">                        error: function(error) &#123; ... &#125;,</span><br><span class="line">                        consentDialog: function(on) &#123; ... &#125;,</span><br><span class="line">                        iceState: function(state) &#123; ... &#125;,</span><br><span class="line">                        mediaState: function(medium, on) &#123; ... &#125;,</span><br><span class="line">                        webrtcState: function(on) &#123; ... &#125;,</span><br><span class="line">                        onmessage: function(msg, jsep) &#123; ... &#125;,</span><br><span class="line">                        onlocalstream: function(stream) &#123; ... &#125;,</span><br><span class="line">                        onremotestream: function(stream) &#123; ... &#125;,</span><br><span class="line">                        oncleanup: function() &#123; ... &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，该方法的作用在<a href="https://avdancedu.com/d7281c13/" target="_blank" rel="noopener">《janus前端核心库源码分析》</a>一文中也已经做过介绍，该方法可以让浏览器与服务端的<code>videoroom插件</code>绑定，以便获取媒体流。</p><blockquote><p>这里<code>绑定</code>的真实含义是建立WEBRTC连接。</p></blockquote><p>在调用<code>attach</code>方法时，也要传一个<code>JSON</code>格式的对象。在该对像包含了很多属性，这些属性的含义如下：</p><ul><li>plugin，要绑定的<code>janus</code>插件，这里要绑定插件为<code>janus.plugin.videoroom</code>。</li><li>opaqueId，一个随机值，插件的唯一ID。</li><li>success，<code>attach</code>方法执行成功后的回调函数。</li><li>error，<code>attach</code>方法执行失败后的回调函数。</li><li>consentDialog,</li><li>iceState，可以通过该函数更新ICE状态。在<code>videoroomtest.js</code>中没有做任何处理。</li><li>mediaState，可以通过该函数更新媒体状态。该方法也没有做任你可事儿。</li><li>webrtcState，更改WebRTC状态的回调函数。</li><li>onmessage，收到事件消自己的回调函数。</li><li>onlocalstream，收到本地流时的回调函数。</li><li>onremotestream，收到远端流时的回调函数。</li><li>oncleanup，销毁时的回调函数。</li></ul><p>在上面属性中，比较关键的是<code>success</code>、<code>webrtceState</code>、<code>onmessage</code>、<code>onlocalstream</code>和<code>onremotestream</code> 。这几个属性都是回调函数，在不同的情况下<code>janus.js</code>会调不同的回调函数。下面我们就对这几个回调函数做一下详细分析。</p><h3 id="success回调函数"><a href="#success回调函数" class="headerlink" title="success回调函数"></a>success回调函数</h3><p>当调用<code>attach</code>方法成功与<code>janus</code>服务器<code>插件</code>绑定之后，<code>janus.js</code>会回调<code>success</code>函数。代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">this.attach &#x3D; function(callbacks) &#123; createHandle(callbacks); &#125;;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">function createHandle(callbacks) &#123;</span><br><span class="line">    ...</span><br><span class="line">    Janus.httpAPICall( server + &quot;&#x2F;&quot; + sessionId,</span><br><span class="line">                       &#123;</span><br><span class="line">                            verb: &#39;POST&#39;,</span><br><span class="line">                            withCredentials: withCredentials,</span><br><span class="line">                            body: request,</span><br><span class="line">                            success: function() &#123;</span><br><span class="line">                                var pluginHandle &#x3D; &#123; ... &#125;;</span><br><span class="line">                                callbacks.success(pluginHandle);</span><br><span class="line">                            &#125;,</span><br><span class="line">                            error: function() &#123; ... &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                     );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面代码的执行过程如下，<code>janus.js</code>向<code>janus</code>服务器发送<code>attach</code>请求，服务器收到<code>attach</code>请求后进行处理，然后根据处理结果返回<code>success</code>或<code>error</code>。如果浏览器收到的是服务器返回的<code>success</code>响应，那么就会回调<code>success</code>函数。</p><p>接下来我们看一下<code>success</code>回调到应用层<code>videoroomtest.js</code>后做了哪些事儿吧! 代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">janus.attach(</span><br><span class="line">                &#123;</span><br><span class="line">                    ...</span><br><span class="line">                    success: function(pluginHandle) &#123;</span><br><span class="line">                                ...</span><br><span class="line">                                sfutest &#x3D; pluginHandle;</span><br><span class="line">                                ...</span><br><span class="line">                             &#125;</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>从上面的代码中我们可以看到，应用层<code>success</code>的逻辑非常简单，只是将<code>janus.js</code>层创建的<code>pluginHanle</code>保存起来以备后用，剩下的其它的一些代码是与界面相关的，我们这里就不介绍了。</p><h3 id="onmessage"><a href="#onmessage" class="headerlink" title="onmessage"></a>onmessage</h3><p><code>onmessagee</code>实现的是对<code>janus</code>服务端返回事件的处理逻辑。我们依然还是先看看在<code>janus.js</code>中是如何调用该函数的。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function handleEvent(json, skipTimeout) &#123;</span><br><span class="line">    ...</span><br><span class="line">    else if(json[&quot;janus&quot;] &#x3D;&#x3D;&#x3D; &quot;event&quot;) &#123;</span><br><span class="line">        ...</span><br><span class="line">        var sender &#x3D; json[&quot;sender&quot;];</span><br><span class="line">        var pluginHandle &#x3D; pluginHandles[sender];</span><br><span class="line">        ...</span><br><span class="line">        var plugindata &#x3D; json[&quot;plugindata&quot;];</span><br><span class="line">        ...</span><br><span class="line">        var jsep &#x3D; json[&quot;jsep&quot;];</span><br><span class="line">        var callback &#x3D; pluginHandle.onmessage;</span><br><span class="line">        if(callback) &#123;</span><br><span class="line">            callback(data, jsep);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是<code>janus.js</code>中的<code>handleEvent</code>函数的主逻辑，当<code>janus.js</code>收到janus服务端发来的<code>event</code>事件后，从中取出必要的信息，然后调用<code>pluginHandle.onmessage</code>方法回调应用层。</p><p>应用层的<code>onmessage</code>函数<code>非常重要</code>，可以说它是应用层最<code>核心的代码</code>。它根据从janus服务端收到的不同消息类型做不同的逻辑处理，其主逻辑框架如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">onmessage: function(msg, jsep) &#123;</span><br><span class="line">            var event &#x3D; msg[&quot;videoroom&quot;];</span><br><span class="line">            if(event) &#123;</span><br><span class="line">                if(event &#x3D;&#x3D;&#x3D; &quot;joined&quot;) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                    publishOwnFeed(true);</span><br><span class="line">                    ...</span><br><span class="line">                &#125; else if(event &#x3D;&#x3D;&#x3D; &quot;destroyed&quot;) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                &#125; else if(event &#x3D;&#x3D;&#x3D; &quot;event&quot;) &#123;</span><br><span class="line">                    if(msg[&quot;publishers&quot;]) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125; else if(msg[&quot;leaving&quot;]) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125; else if(msg[&quot;unpublished&quot;]) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125;else if(msg[&quot;error&quot;]) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(jsep) &#123;</span><br><span class="line">                ...</span><br><span class="line">                sfutest.handleRemoteJsep(&#123; jsep: jsep &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>通过上面的代码我们可以看到，消息包括以下3种：</p><ul><li>joined，表示作为<code>发布者</code>加入成功</li><li>destroyed, 表示用户成功<code>销毁</code>房间</li><li>event，子事件，<code>event</code>又有四个子事件：<ul><li>publishers，发布者列表</li><li>leaving，有用户离开了</li><li>unpublished，用户取消发布流</li><li>error，出错</li></ul></li></ul><p>在<code>onmessage</code>函数中会对3种事件消息做处理，下面我们分别对这几个事件消息做一下分析。</p><h4 id="joined-事件"><a href="#joined-事件" class="headerlink" title="joined 事件"></a>joined 事件</h4><p><code>joined</code>消息的含义我在<a href="https://avdancedu.com/bb906872/" target="_blank" rel="noopener">《janus的videoroom插件》</a>一文中已经向你做过介绍了，即当你作为<code>发布者</code>加入到房间里时，如果成功则会收到<code>joined</code>事件消息。</p><p>此时你可以从该消息中取出<code>publishers</code>列表，该列表中的每一个<code>publisher</code>都是会中的一个<code>发布者</code>(或称为一路流）。由于<code>发布者</code>也是房间的<code>订阅者</code>，所以你应该订阅每个<code>发布者</code>的媒体流，因此你要与列表中的每个<code>publisher</code>进行一次<code>媒体协商</code>，并进行<code>attach</code>。这样就可以接收<code>发布者</code>的媒体流啦。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">if(event &#x3D;&#x3D;&#x3D; &quot;joined&quot;) &#123;</span><br><span class="line">    ...</span><br><span class="line">    publishOwnFeed(true); &#x2F;&#x2F;创建 Offer</span><br><span class="line">    if(msg[&quot;publishers&quot;]) &#123;</span><br><span class="line">        var list &#x3D; msg[&quot;publishers&quot;];</span><br><span class="line">        for(var f in list) &#123;</span><br><span class="line">            var id &#x3D; list[f][&quot;id&quot;];</span><br><span class="line">            var display &#x3D; list[f][&quot;display&quot;];</span><br><span class="line">            var audio &#x3D; list[f][&quot;audio_codec&quot;];</span><br><span class="line">            var video &#x3D; list[f][&quot;video_codec&quot;];</span><br><span class="line">            newRemoteFeed(id, display, audio, video); &#x2F;&#x2F;attach插件，并向插件发送 join 消息</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>从代码中我们可以看到，因为它是一个<code>发布者</code>所以它首先执行<code>publishOwnFeed(true)</code>创建<code>Offer</code>与janus服务端作媒体协商。之后遍历<code>publishers</code>列表，取出每个<code>publisher</code>执行<code>newRemoteFeed</code>方法，在该方法中又会调用<code>attach</code>方法获取其它<code>发布者</code>的媒体流。</p><h4 id="publishers-事件"><a href="#publishers-事件" class="headerlink" title="publishers 事件"></a>publishers 事件</h4><p>当有<code>发布者</code>加入到房间后，房间内的所有<code>订阅者</code>都会收到<code>publishers</code>事件消息。浏览器收到该消息后，应该对消息中的每个未绑定的<code>publisher</code>都进行<code>attach</code>操作，这样就可以接收<code>发布者</code>的媒体流了。 其主逻辑代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">if(msg[&quot;publishers&quot;]) &#123;</span><br><span class="line">    var list &#x3D; msg[&quot;publishers&quot;];</span><br><span class="line">    for(var f in list) &#123;</span><br><span class="line">        var id &#x3D; list[f][&quot;id&quot;];</span><br><span class="line">        var display &#x3D; list[f][&quot;display&quot;];</span><br><span class="line">        var audio &#x3D; list[f][&quot;audio_codec&quot;];</span><br><span class="line">        var video &#x3D; list[f][&quot;video_codec&quot;];</span><br><span class="line">        newRemoteFeed(id, display, audio, video);&#x2F;&#x2F;attach插件</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这段代码与<code>joined</code>消息的处理逻辑几乎是一样的，只不过<code>订阅者</code>此时不需要与janus服务器进行媒体协商，所以它没有调用<code>publishOwnFeed</code>方法，其它的逻辑都是一样的了。</p><h4 id="leaving-unpublished-事件"><a href="#leaving-unpublished-事件" class="headerlink" title="leaving/unpublished 事件"></a>leaving/unpublished 事件</h4><p>当一个<code>发布者</code>取消发布时，janus会向房间内的其它用户发送<code>unpublished</code>消息。另外，当有用户离开房间时，janus会给房间内的其它人发送<code>leaving</code>消息。另外，如果离开的用户是一个<code>发布者</code>的话，它同时也会发<code>unpublished</code>消息，所以这里我们将两个消息放在一起讨论。</p><p>这两个消息处理的核心逻辑如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">var remoteFeed &#x3D; null;</span><br><span class="line">for(var i&#x3D;1; i&lt;6; i++) &#123;</span><br><span class="line">    if(feeds[i] &amp;&amp; feeds[i].rfid &#x3D;&#x3D; unpublished) &#123;</span><br><span class="line">        remoteFeed &#x3D; feeds[i];</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(remoteFeed !&#x3D; null) &#123;</span><br><span class="line">    ...</span><br><span class="line">    feeds[remoteFeed.rfindex] &#x3D; null;</span><br><span class="line">    remoteFeed.detach();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面这段代码有点不太好理解，我这里解释一下你就清楚了。首先我们来看看循环中的固定数字<code>6</code>，表示什么含义呢？实际上我在<a href="https://avdancedu.com/bb906872/" target="_blank" rel="noopener">《janus的videoroom插件》</a>一文中有解释过，在janus中一个房间内最多可以支持<code>6</code>路流，这个<code>6</code>表过的正是这个意思。所以当收到<code>leaving</code>和<code>unpublished</code>消息时，客户端会遍历全局变量<code>feeds</code>(保存所有订阅的流），如果在<code>feeds</code>中找到了该流，则需要与该流进行<code>detach</code>操作。</p><p>现在我们再读这段代码时是不是就理解它要表达的意思了呢？</p><h3 id="onlocalstream-消息"><a href="#onlocalstream-消息" class="headerlink" title="onlocalstream 消息"></a>onlocalstream 消息</h3><p>当收到<code>onlocalstream</code>消息时，说明本地流已经准备就绪了，此时我们需要让本地流的视频在浏览器里显示出来。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">onlocalstream: function(stream) &#123;</span><br><span class="line">    mystream &#x3D; stream;</span><br><span class="line">    ...</span><br><span class="line">    Janus.attachMediaStream($(&#39;#myvideo&#39;).get(0), stream);</span><br><span class="line">    $(&quot;#myvideo&quot;).get(0).muted &#x3D; &quot;muted&quot;;</span><br><span class="line">    ...</span><br><span class="line">    var videoTracks &#x3D; stream.getVideoTracks();&#125;</span><br><span class="line">    &#x2F;&#x2F;显示video标签</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这段代码的含议非常简单了，就是获取本地址，然后从<code>HTML</code>中拿到一个<code>video</code>标签，最后将<code>video</code>与本地流绑定到一起，这样就可以看到捕获的本地视频了。</p><h3 id="onremotestream-消息"><a href="#onremotestream-消息" class="headerlink" title="onremotestream 消息"></a>onremotestream 消息</h3><p><code>onremotestream</code>消息与<code>onlocalstream</code>是类似的，只不过它表示的是远端的视频流。当收到远端的视频流时，我们也同样在本地创建一个<code>video</code>，然后将远端视频流与<code>video</code>绑定即可。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我向你详细介绍了janus中的<code>videoroom</code>是如何使用<code>janus.js</code>文件的，其总的步骤是先调用<code>Janus.init</code>方法进行初始化；然后创建<code>Janus</code>对象，即与janus服务器建立连接，并接收来自服务器端的消息; 最后调用<code>attach</code>与业务服务器绑定，再根据消息进行推流或拉流。</p><p>总的来看，使用<code>janus.js</code>库大大减轻了我们开发<code>webrtc</code>应用程序的工作量，提高了工作效率。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://avdancedu.com/bb906872/" target="_blank" rel="noopener">《janus的videoroom插件》</a><br><a href="https://avdancedu.com/d7281c13/" target="_blank" rel="noopener">《janus前端核心库源码分析》</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/janus_jscall/jscall.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;之前我在&lt;a href=&quot;https://avdancedu.com/d7281c13/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《janus前端核心库源码分析》&lt;/a&gt;一文中已经向你详细分析了&lt;code&gt;janus.js&lt;/code&gt;文件的实现，但对于大多同学来说，知道如何使用它才是最重要的。那具体我们该如何使用它呢？janus中的&lt;code&gt;videoroomtest.js&lt;/code&gt;是一个不错的例子，今天就来分析一下&lt;code&gt;videoroomtest.js&lt;/code&gt;，看看它是是如何使用&lt;code&gt;janus.js&lt;/code&gt;的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/categories/WebRTC/"/>
    
    
      <category term="janus" scheme="https://blog.avdancedu.com/tags/janus/"/>
    
  </entry>
  
  <entry>
    <title>音视频学习路线图</title>
    <link href="https://blog.avdancedu.com/12dc77f9/"/>
    <id>https://blog.avdancedu.com/12dc77f9/</id>
    <published>2020-06-23T01:41:26.000Z</published>
    <updated>2020-06-23T15:12:25.597Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/av_path/av_learn_path.jpg" alt=""></p><p>这是我制订的一个<a href="https://coding.imooc.com/learningpath/route?pathId=39" target="_blank" rel="noopener">音视频学习线路图</a>，希望对学习音视频的同学能所有帮助!</p><p>从2018年制作第一门音视频课<a href="https://coding.imooc.com/class/279.html" target="_blank" rel="noopener">《ffmpeg精讲》</a>开始，到今年3月我已经陆续录制了4门与音视频相关的课程和一个专栏，分别是<a href="https://coding.imooc.com/class/415.html" target="_blank" rel="noopener">《音视频系统入门》</a>、<a href="https://coding.imooc.com/class/279.html" target="_blank" rel="noopener">《ffmpeg精讲》</a>、<a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门与实战》</a>、<a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">《百万级WebRTC流媒体服务器》</a>以及<a href="https://time.geekbang.org/column/article/107916" target="_blank" rel="noopener">《从0开始打造音视频直播系统》</a>，他们基本覆盖了音视频从入门到高阶的所有内容。</p><a id="more"></a><p>如果你对音视频感兴趣的话，可以根据自己的情况选择自己感兴趣的课程学习，当然也可以按照下面的路线图进行学习，</p><p>首先是<a href="https://coding.imooc.com/class/415.html" target="_blank" rel="noopener">《音视频系统入门》</a>，这门课是学习音视频至关重要的课程，是所有其它课程的基础。如果你之前对音视频没有任何概念，或者基础不牢的话，建议先从这门课开始学起。这门课讲解了最基本的音视频知识，如音频三要素、PCM、AAC编码、YUV、H264编码原理、音视频数据采集、FLV/RTMP、可商用的RTMP流媒体服务器等知识。课程中包括了大量实战，而且是手把手带你一行一行代码写起，特别适合于新入门的同学。这门课的知识是每个搞音视频研发的同学必须 100% 撑握的内容，很多音视频面试题也是考的这部分内容。</p><p>学完<a href="https://coding.imooc.com/class/415.html" target="_blank" rel="noopener">《音视频系统入门》</a>之后，你可以继续学习高阶的<a href="https://coding.imooc.com/class/279.html" target="_blank" rel="noopener">《ffmpeg精讲》</a>，这门课详细讲解了ffmpeg的运行机制，重点讲解了音视频同步，音视频线程的协作等。并通过这些知识实现了一个播放器内核。如果你的工作是做音视频编辑(如音视频的裁剪、音视拆分合并等）、音视频的编解码、音视频播放器研发的工作，那这门课就特别适合你。</p><p>当然，如果你想做实时互动直播（如音视频会议、在线教育）产品，那么WebRTC是你必须要学习的内容。WebRTC现在越来越强大，强大到你通过浏览器编写几行代码就可能实现1对1的实时通信。因此你可以选择学习<a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门与实战》</a> 和<a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">《百万级WebRTC流媒体服务器》</a>。 这两门课一门是讲解客户端的一门是讲解服务端的。</p><p><a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门与实战》</a>讲解了WebRTC的工作原理，如如何采集音视频，媒体协商，以及理底层的ICE、P2P、DTLS-SRTP、RTP/RTCP、STUN等，但其侧重点还是教你如何使用WebRTC库实现实时通信。在这门课中实现了浏览器端、Android、iOS三个端。并且三个端之间都可以彼此进行 1对1 的实时通信。</p><p>另一门课<a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">《百万级WebRTC流媒体服务器》</a>是讲解WebRTC流媒体服务器的高阶课程，这门课里面详细讲解了如何在Linux上开发高并发流媒体服务器，讲解了信号处理、多进程/多线程、select/poll/epoll/libevent/libev异步事件处理机制等，并重点对性能最好的WebRTC流媒体服务器<code>mediasoup</code>做了深入剖析。相信学完这门课后你去应聘相关的工作时，技术上已经不会有任何问题了。甚至是各大厂争抢的人才。</p><p>上面的视频课都是针对于某一方面做的重点讲解，但如果你想对整个音视频技术做全面了解，并且对更愿意阅读文字的话，阅读我的专栏 <a href="https://time.geekbang.org/column/article/107916" target="_blank" rel="noopener">《从0开始打造音视频直播系统》</a>是个不错的选择。专栏中我对上面所有的内容做了概括性的讲解，如 WebRTC的使用、WebRTC流媒体服务器的分析、传统RTMP直播技术以及各种播放器都做了讲解。如果你对音视频各方面知识都有了一定的了解，建议你再读一下这个专栏，它会对你的音视频知识做一个系统的梳理，从而让你对音视频的认知更上一个台阶。</p><p><img data-src="https://cdn.avdancedu.com/image/article/av_path/path.jpg" alt="音视频知识图谱"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/av_path/av_learn_path.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这是我制订的一个&lt;a href=&quot;https://coding.imooc.com/learningpath/route?pathId=39&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;音视频学习线路图&lt;/a&gt;，希望对学习音视频的同学能所有帮助!&lt;/p&gt;
&lt;p&gt;从2018年制作第一门音视频课&lt;a href=&quot;https://coding.imooc.com/class/279.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《ffmpeg精讲》&lt;/a&gt;开始，到今年3月我已经陆续录制了4门与音视频相关的课程和一个专栏，分别是&lt;a href=&quot;https://coding.imooc.com/class/415.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《音视频系统入门》&lt;/a&gt;、&lt;a href=&quot;https://coding.imooc.com/class/279.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《ffmpeg精讲》&lt;/a&gt;、&lt;a href=&quot;https://coding.imooc.com/class/329.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《WebRTC入门与实战》&lt;/a&gt;、&lt;a href=&quot;https://coding.imooc.com/class/387.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《百万级WebRTC流媒体服务器》&lt;/a&gt;以及&lt;a href=&quot;https://time.geekbang.org/column/article/107916&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《从0开始打造音视频直播系统》&lt;/a&gt;，他们基本覆盖了音视频从入门到高阶的所有内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="音视频" scheme="https://blog.avdancedu.com/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="https://blog.avdancedu.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>janus的videoroom插件</title>
    <link href="https://blog.avdancedu.com/bb906872/"/>
    <id>https://blog.avdancedu.com/bb906872/</id>
    <published>2020-06-19T16:04:10.000Z</published>
    <updated>2020-06-29T05:31:16.443Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/videoroom/videoroom.jpg" alt="videoroom"></p><p>在Janus的众多插件中，大家最感兴趣的恐怕就是<code>VideoRoom</code>插件了。因为它实现的是一个音视频会议的场景，这正是大多数同学所需要的。而且在Janus众多的插件中<code>VideoRoom</code>应该也是最复杂的一个，如果你们撑握了它，再去看其它插件的实现就容易多了。</p><p>在<code>VideoRoom</code>中，包括了很多API，这些API是我们打开<code>VideoRoom</code>的一把钥匙，所以本文的重点就是讲解这些API。我相信当你把这些API都撑握之后，再去看<code>VideoRoom</code>插件的代码时就会更加游刃有余了。</p><a id="more"></a><h2 id="VideoRoom插件"><a href="#VideoRoom插件" class="headerlink" title="VideoRoom插件"></a>VideoRoom插件</h2><p><code>VideoRoom</code>是Janus的一个插件，实现了一个SFU（Selective Forwarding Unit）型的音视频会议。如果你从数据转发的角度看，也可以把它认为是一个音视频<code>路由器</code>。</p><p><code>VideoRoom</code>实现的音视频会议是基于<code>发布/订阅</code>模式。每个<code>参与方</code>都可以发布自己的实时音视频流，因此它可以实现几种不同的场景，比如泛娱乐化直播或多人的实时互动产品(如音视频会议、在线教育小班课等）。</p><p>考虑到此插件允许一个<code>参与方</code>可以打开多个WebRTC <code>PeerConnection</code>（如每个<code>参与方</code>可以有1个用于推流的<code>PeerConnection</code>和N个拉流的<code>PeerConnection</code>），所以每个<code>参与方</code>需要为订阅不同的流<code>attach</code>到<code>VideoRoom</code>插件几次(每<code>attach</code>一次就会生成一个<code>Handle</code>，每个<code>Handle</code>就是一个上下文)。</p><p>因此，对于每个<code>参与方</code>至少要有一个<code>Handle</code>用于管理与插件的关系（如加入一个房间，离开一个房间，静音/取消静音，发布，接收事件）。</p><p>每当<code>参与方</code>需要订阅另一个参与方发布的音视频流时，它需要创建一个新的<code>Handle</code>。新创建的<code>Handle</code>在逻辑上属于<strong>“从”</strong><code>Handle</code>，它不能像<strong>“主”</strong><code>Handle</code>一样可以做取消房间静音这样的操作。因此，<strong>从</strong><code>Handle</code>唯一目的是提供一个上下文，在该上下文中创建一个<code>recvonly</code>类型的<code>PeerConnection</code>来订阅发布者的音视频流。</p><p>通过上面的描述我们可以知道，主Handle用于管理，而从Handle用于订阅音视频流。</p><blockquote><p>注意，现在<code>WebRTC</code>已经实现了SSRC复用（Unified Plan），这意味着你可以使用相同的<code>Janus Handle</code> 和<code>PeerConnection</code>同时接收多路音视频流。</p></blockquote><p>VideoRoom插件功能非常强大，也很灵活，它有很多的配置项，你可以通过<code>conf/janus.plugin.videoroom.jcfg</code>来修改它们。当然Janus也支持动态API修改配置，如通过API创建房间等。</p><p>要增加更多房间或修改现有房间信息，你可以向Janus发送下面格式的请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">room- &lt;唯一的房间ID&gt;：&#123;</span><br><span class="line">        description &#x3D; 房间的描述信息</span><br><span class="line">        is_private &#x3D; true | false（是否是私有房间? 如果创建的是私有房间，则无法通过list指令进行查看）</span><br><span class="line">        secret &#x3D; &lt;可选项，操作房间所需的密码，如果设置了，则像做销毁房间这样的操作时你要带上它才行&gt;</span><br><span class="line">        PIN &#x3D; &lt;可选项，加入会议房间的密码&gt;</span><br><span class="line">        require_pvtid &#x3D; true | false（是否订阅音视频流时，需要提供一个与发布者相关的有效private_id， 默认为false）</span><br><span class="line">        publishers &#x3D;  &lt;房间内发布者的最大数&gt;（例如，一个视频会议可以有6个发布者，而广播只有一个，默认&#x3D; 3）</span><br><span class="line">        bitrate &#x3D; &lt;房间里发布者发送数据的最大比特率&gt;（例如128000）</span><br><span class="line">        fir_freq &#x3D; &lt;向发布者发送FIR指令的频率&gt;（0 &#x3D;禁用）</span><br><span class="line">        audiocodec &#x3D; opus | g722 | pcmu | pcma | isac32 | isac16（发布者可以使用的音频编解码器列表，默认为opus。编码器按优先顺序以逗号分隔）</span><br><span class="line">        videocodec &#x3D; vp8 | vp9 | h264 | av1 | h265（发布者可以使用的视频编解码器列表，默认为vp8。可以按优先级顺序用逗号分隔，例如，vp9，vp8，h264）</span><br><span class="line">        vp9_profile &#x3D; VP9首选的profile(&quot;2&quot; 表示 &quot;profile-id &#x3D; 2&quot; ）</span><br><span class="line">        h264_profile &#x3D; H.264首选的profile（&quot;42e01f&quot; 表示 &quot;profile-level-id &#x3D; 42e01f&quot; ）</span><br><span class="line">        opus_fec &#x3D; true | false（是否使用带内FEC；仅适用于Opus，默认为false）</span><br><span class="line">        video_svc &#x3D; true | false（是否启用SVC支持；仅适用于VP9，默认为false）</span><br><span class="line">        audiolevel_ext &#x3D; true | false（对于发布者是否使用RTP扩展ssrc-audio-level？默认为 true）</span><br><span class="line">        audiolevel_event &#x3D; true | false（是否将audiolevel事件发送给其他用户）</span><br><span class="line">        audio_active_packets &#x3D; 100（音频保活包个数，默认值&#x3D; 100，2秒）</span><br><span class="line">        audio_level_average &#x3D; 25（音频音量级别的平均值，127 &#x3D;静音，0 &#x3D;&#39;太大声&#39;，默认&#x3D; 25）</span><br><span class="line">        videoorient_ext &#x3D; true | false（发布者是否使用RTP扩展video-orientation? 默认&#x3D; true）</span><br><span class="line">        playoutdelay_ext &#x3D; true | false（发布者是否使用RTP扩展playout-delay? 默认&#x3D; true）</span><br><span class="line">        transport_wide_cc_ext &#x3D; true | false（发布者是否使用RTP扩展 transport-wide-cc? 默认&#x3D; true）</span><br><span class="line">        record &#x3D; true | false（该房间是否启录制？默认&#x3D; false）</span><br><span class="line">        rec_dir &#x3D; &lt;启用录制后，录制文件存放的目录&gt;</span><br><span class="line">        lock_record &#x3D; true | false（是否锁定录制状态? 默认&#x3D; false）</span><br><span class="line">        notify_joining &#x3D; true | false（可选，当有新的参与方加入房音后，是否通知房间里的所有参与者?</span><br><span class="line">                                       Videoroom插件默认仅通知发布者，启用此功能可能会导致额外的通知传输。</span><br><span class="line">                                       该功能与require_pvtid一起启用时，对管理员管理仅收听的参与者特别有用。默认&#x3D; false）</span><br><span class="line">        require_e2ee &#x3D; true | false（是否启用端到端加密? 默认&#x3D; false）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Video-Room-可以使用的API"><a href="#Video-Room-可以使用的API" class="headerlink" title="Video Room 可以使用的API"></a>Video Room 可以使用的API</h2><p><code>VideoRoom</code> 插件支持很多API。这些API中，一些是同步请求，一些则是异步请求。但无论是同步还是异步请求，当遇到无效的JSON格式或无效的请求时，都使用同步进行错误响应。</p><p>接下来，我们首先看看都有那些同步请求API。<code>create</code>，<code>destroy</code>，<code>edit</code>，<code>exists</code>，<code>list</code>，<code>allowed</code>，<code>kick</code>和<code>listparticipants</code>是同步请求API。<code>create</code>允许您动态创建一个新的音视频房间；<code>edit</code>允许您动态编辑房间的属性（例如 修改PIN码）；<code>destroy</code>首先释放视频资源，然后踢除房间里的所有用户，最后销毁音视频房间；<code>exists</code>检查指定的音视频房间是否存在；<code>list</code>列出所有有效的音视频房间; <code>listparticipants</code>列出指定房间中所有激活的参与者及其详细信息。</p><p>异步请求API有：<code>join</code>，<code>joinandconfigure</code>，<code>configure</code>，<code>publish</code>，<code>unpublish</code>，<code>start</code>，<code>pause</code>，<code>switch</code>和<code>leave</code>。<code>join</code>允许你加入指定的音视频房间；<code>configure</code>可用于修改某些属性（例如，比特率范围）；<code>joinandconfigure</code>的含义是将前两个请求合并为一个请求（该请求仅适用于发布者）；<code>publish</code>发布媒体流给所有订阅者; <code>unpublish</code>正好与<code>publish</code>相反；<code>start</code>允许你开始接收订阅的媒体流；<code>pause</code>暂停发送媒体流；<code>switch</code>更改指定<code>PeerConnection</code>的媒体源（例如，你正在看A，现在改为看B），但无需为此创建新的Handle；<code>leave</code>离开视频房间。</p><p>下面咱们对上面提到的API做一下详细分析，首先看一下<code>create</code>API，它用于创建新的音视频房间，其格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;create&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;可选，房间ID。如果不填，则由插件随机生成&gt;，</span><br><span class="line">        &quot;permanent&quot;：&lt;true | false，是否创建永久房间，默认&#x3D; false&gt;，</span><br><span class="line">        &quot;description&quot;：&quot;&lt;可选，房间的名称&gt;&quot;，</span><br><span class="line">        &quot;secret&quot;：&quot;&lt;可选，编辑&#x2F;销毁房间时用的密码&gt;&quot;，</span><br><span class="line">        &quot;pin&quot;：&quot;&lt;可选，加入房间的密码&gt;&quot;，</span><br><span class="line">        &quot;is_private&quot;：&lt;true | false，是否是私有房间？如果是私有房间则不会出现在房间列表中&gt;，</span><br><span class="line">        &quot;allowed&quot;：[可选，用户加入房间的token数组]，</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的说明已经非常清楚了，这里我就不做简赘述了。</p><p>如果<code>create</code>成功，则会返回<code>created</code>响应，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：“created&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;permanent&quot;：&lt;是否是创建的永久房间？是则为true，否则为false&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，如果你请求创建一个永久房间，但<code>permanet</code>返回的是false，很可能是因为权限的问题导致的。</p></blockquote><p>如果<code>create</code>请求失败，则返回错误信息，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;error_code&quot;：&lt;错误码，每个错误码的含义需要看插件实现代码中的宏定义&gt;，</span><br><span class="line">        &quot;error&quot;：&quot;&lt;错误描述字符串&gt;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里需要注意的是，所有请求的错误响应格式都与上面一样。</p></blockquote><p>默认情况下，所有用户都可以创建房间，但你可以通过在<code>VideoRoom</code>插件的配置文件中增加<code>admin_key</code>项来限制此功能。此时，只有带了正确的<code>admin_key</code>值的<code>create</code>请求才能成功创建房间。你也可以选择将此功能扩展到RTP转发，只转发受信任的客户端的RTP包。</p><p>房间创建好后，您可以用<code>edit</code>API编辑其中的部分（但不是全部）属性。<code>edit</code>允许你修改房间描述，密码，PIN码以及是否为私有。但你将无法修改他的静态属性，例如房间ID，采样率，与扩展相关的内容等。如果你有兴趣更改ACL，还需要查看<code>allowed</code>是否允许。</p><p>一个<code>edit</code>请求格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;edit&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;secret&quot;：&quot;&lt;房间密码&gt;&quot;，</span><br><span class="line">        &quot;new_description&quot;：&quot;&lt;房间的新名称，可选&gt;&quot;，</span><br><span class="line">        &quot;new_secret&quot;：&quot;&lt;房间的新密码，可选&gt;&quot;，</span><br><span class="line">        &quot;new_pin&quot;：&quot;&lt;新PIN码，可选&gt;&quot;，</span><br><span class="line">        &quot;new_is_private&quot;：&lt;true | false，房间是否为私有房间?&gt;，</span><br><span class="line">        &quot;new_require_pvtid&quot;：&lt;true | false，房间是否要求订阅者提供private_id&gt;，</span><br><span class="line">        &quot;new_bitrate&quot;：&lt;比特率&gt;，</span><br><span class="line">        &quot;new_fir_freq&quot;：&lt;发送PLI请求关键帧的时间间隔&gt;，</span><br><span class="line">        &quot;new_publishers&quot;：&lt;房间里发布者的最大数&gt;，</span><br><span class="line">        &quot;new_lock_record&quot;：&lt;true | false，如否可以改变录制状态&gt;，</span><br><span class="line">        &quot;permanent&quot;：&lt;true | false，该房间是否是永久房间？默认&#x3D; false&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>edit</code>请求成功，刚收到<code>edited</code>响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;edited&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们来看看<code>destroy</code>API，无论你是通过动态创建的还是静态创建的房间，均可使用<code>destroy</code>销毁它，其格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;destroy&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;secret&quot;：&quot;&lt;房间密码&gt;&quot;，</span><br><span class="line">        &quot;permanent&quot;：&lt;true | false，是否是永久房间，默认&#x3D; false&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功销毁房间后将收到<code>destroyed</code>响应，其格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;destroyed&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>销毁房间后，在房间内的所有参与者都会收到<code>destroyed</code>事件，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;destroyed&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Janus中还提供了<code>exists</code>API，来检查房间是否存在，该请求的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;exists&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求成功将收到success响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：“success&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        “exists&quot;：&lt;true | false 房间是否存在&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>allowed</code>API可以打开/关闭对令牌的检测，它还可以增加/删除允许的用户，其请求格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;allowed&quot;，</span><br><span class="line">        &quot;secret&quot;：&quot;&lt;房间密码，如果已配置，则是必需的&gt;&quot;，</span><br><span class="line">        &quot;action&quot;：&quot;enable | disable | add | remove&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;allowed&quot;：[</span><br><span class="line">                &#x2F;&#x2F;字符串数组</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功请求将返回success响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：“success&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        “allowed&quot;：[</span><br><span class="line">                &#x2F;&#x2F;更新后完整的令牌列表</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你是房间管理员（即你创建了该房间并可以加密访问），则你可以使用<code>kick</code>API踢除房间内的用户。</p><blockquote><p>注意，这只会将用户踢出房间，但并不能阻止他们重新加入。要禁止他们加入，你需要先从授权用户列表中删除他们（请参阅allowed请求），然后再将其踢掉。<code>kick</code>请求的格式如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;kick&quot;，</span><br><span class="line">        &quot;secret&quot;：&quot;&lt;房间密码&gt;&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;id&quot;：&lt;被踢用户ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求成功将收到success响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;success&quot;，</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你还可以通过<code>list</code>API获取可用房间的列表（不包括配置或创建为私有的房间），其格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：“list&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求成功将返回success响应，响应中会带有有效的房间列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：“成功&quot;，</span><br><span class="line">        &quot;rooms&quot;：[&#x2F;&#x2F;房间对象数组</span><br><span class="line">                &#123;&#x2F;&#x2F; 第一个房间</span><br><span class="line">                        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">                        &quot;description&quot;：&quot;&lt;房间名称&gt;&quot;，</span><br><span class="line">                        &quot;pin_required&quot;：&lt;true | false，是否需要输入PIN吗才能加入此房间&gt;，</span><br><span class="line">                        &quot;max_publishers&quot;：&lt;房间内发布者最大数量，&gt;</span><br><span class="line">                        &quot;bitrate&quot;：&lt;发布者使用的（通过REMB）比特率上限&gt;，</span><br><span class="line">                        &quot;bitrate_cap&quot;：&lt;true | false，上述上限是否可以动态更改?&gt;，</span><br><span class="line">                        &quot;fir_freq&quot;：&lt;发送PLI&#x2F;FIR请求关键帧的时间间隔&gt;，</span><br><span class="line">                        &quot;audiocodec&quot;：&quot;&lt;音频编解码器列表，每个编码器以逗号分隔&gt;&quot;，</span><br><span class="line">                        &quot;videocodec&quot;：&quot;&lt;视频编解码器列表，每个编码器以逗号分隔&gt;&quot;，</span><br><span class="line">                        &quot;record&quot;：&lt;true | false，是否打开了录制功能&gt;，</span><br><span class="line">                        &quot;record_dir&quot;：&quot;&lt;如果开启了录掉，.mjr文件保存的路径&gt;&quot;，</span><br><span class="line">                        &quot;lock_record&quot;：&lt;true | false，是否只能通过密码才能更改房间记录状态&gt;，</span><br><span class="line">                        &quot;num_participants&quot;：&lt;房间内参与人的个数&gt;</span><br><span class="line">                &#125;，</span><br><span class="line">                &#x2F;&#x2F;其他房间</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，你要获取特定房间中的参与者列表，可以使用<code>listparticipants</code>请求，其格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;listparticipants&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求成功将返回一个<code>participants</code>响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;participants&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        “participants&quot;：[&#x2F;&#x2F;参与者对象的数组</span><br><span class="line">                &#123;&#x2F;&#x2F;参与者＃1</span><br><span class="line">                        &quot;id&quot;：&lt;用户ID&gt;，</span><br><span class="line">                        &quot;display&quot;：&quot;&lt;用户名；可选&gt;&quot;，</span><br><span class="line">                        &quot;publisher&quot;：&quot;&lt;true | false，用户是否是房间的发布者&gt;&quot;，</span><br><span class="line">                        &quot;talking&quot;：&lt;true | false，用户是否可以说话（仅当使用音频级别时）&gt;</span><br><span class="line">                &#125;，</span><br><span class="line">                &#x2F;&#x2F;其他参与者</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是Janus中的同步API。异步API都是与<code>参与者</code>有关，即<code>参与者</code>如何发布，订阅或管理他们正在发送或接收的媒体流。</p><h2 id="VideoRoom-发布者"><a href="#VideoRoom-发布者" class="headerlink" title="VideoRoom 发布者"></a>VideoRoom 发布者</h2><p>在VideoRoom中，<code>发布者</code>是指那些能够在房间中发布<code>媒体流</code>的参与者。</p><p>当你以<code>发布者</code>的身份加入到房间里时，您应该发送<code>join</code>请求，并且将ptype设置为<code>publisher</code>。请求的具体格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;join&quot;，</span><br><span class="line">        &quot;ptype&quot;：&quot;pbulisher&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;id&quot;：&lt;发布者ID；可选，如果缺少，将由插件选择&gt;，</span><br><span class="line">        &quot;display&quot;：&quot;&lt;发布者名称；可选&gt;&quot;，</span><br><span class="line">        &quot;token&quot;：&quot;&lt;邀请令牌，如果房间有ACL时需要该字段；可选&gt;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>join</code>请求成功将收到<code>joined</code>事件，其中包含当前激活的<code>发布者</code>列表，以及任选的<code>参加者</code>列表。<code>joined</code>事件格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;joined&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;description&quot;：&lt;房间名，如果有的话&gt;，</span><br><span class="line">        &quot;id&quot;：&lt;用户ID&gt;，</span><br><span class="line">        &quot;private_id&quot;：&lt;与参与者相关联的不同唯一ID；打算是私人的&gt;，</span><br><span class="line">        “publishers&quot;：[</span><br><span class="line">                &#123;</span><br><span class="line">                        &quot;id&quot;：&lt;活动发布者＃1的唯一ID&gt;，</span><br><span class="line">                        &quot;display&quot;：&quot;&lt;发布者＃1的名称，如果有的话&gt;&quot;，</span><br><span class="line">                        &quot;audio_codec&quot;：&quot;&lt;发布者＃1使用的音频编解码器，如果有的话&gt;&quot;，</span><br><span class="line">                        &quot;video_codec&quot;：&quot;&lt;发布者＃1使用的视频编解码器，如果有的话&gt;&quot;，</span><br><span class="line">                        &quot;simulcast&quot;：&quot;&lt;如果发布者使用simulcast，则为true（仅VP8和H.264）&gt;&quot;，</span><br><span class="line">                        &quot;talking&quot;：&lt;true | false，发布者开启语音聊天（仅在使用音频级别的情况下）&gt;，</span><br><span class="line">                &#125;，</span><br><span class="line">                &#x2F;&#x2F;其他活跃的发布者</span><br><span class="line">        ]，</span><br><span class="line">        &quot;attendees&quot;：[&#x2F;&#x2F;仅当房间的notify_joining设置为TRUE时存在</span><br><span class="line">                &#123;</span><br><span class="line">                        &quot;id&quot;：&lt;与会者＃1的唯一ID&gt;，</span><br><span class="line">                        &quot;display&quot;：&quot;&lt;与会者＃1的名称，如果有的话&gt;&quot;</span><br><span class="line">                &#125;，</span><br><span class="line">                &#x2F;&#x2F;其他参加者</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，如果房间中当前没有人，则<code>发布者</code>列表为空。上面格式中的<code>private_id</code>属性只有在用户订阅时才起作用。</p></blockquote><p>对于房间里的订阅者来说，会收到<code>event</code>通知。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        “joining&quot;：&#123;</span><br><span class="line">                &quot;id&quot;：&lt;参与者ID&gt;，</span><br><span class="line">                &quot;display&quot;：&quot;&lt;参与者名称&gt;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你想成为<code>发布者</code>，则发送<code>publish</code>请求。该请求必须跟着一个<code>JSEP SDP Offer</code>，用于协商新的<code>PeerConnection</code>。插件会将其与房间配置进行匹配（例如，确保房间中使用协商的编解码器），并使用<code>JSEP SDP answer</code>进行答复从而完成<code>PeerConnection</code>的设置。建立<code>PeerConnection</code>后，发布者立即处于活动状态，其他参与者就可以订阅它发布的流啦。</p><p><code>publish</code>请求格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;publish&quot;，</span><br><span class="line">        &quot;audio&quot;：&lt;true | false，是否应该转发音频；默认为true&gt;，</span><br><span class="line">        &quot;video&quot;：&lt;true | false，是否应该转发视频；默认为true&gt;，</span><br><span class="line">        &quot;data&quot;：&lt;true | false，是否应该转发数据；默认为true&gt;，</span><br><span class="line">        &quot;audiocodec&quot;：&quot;&lt;在协商协议中首选的音频编解码器；可选&gt;&quot;，</span><br><span class="line">        &quot;videocodec&quot;：&quot;&lt;在协商协议中首选的视频编解码器；可选&gt;&quot;，</span><br><span class="line">        &quot;bitrate&quot;：&lt;通过REMB返回的比特率上限；可选，如果存在则覆盖全局房间值&gt;，</span><br><span class="line">        &quot;record&quot;：&lt;true | false，是否应该记录此发布者；可选&gt;</span><br><span class="line">        &quot;filename&quot;：&quot;&lt;录制文件名；可选&gt;&quot;，</span><br><span class="line">        &quot;display&quot;：&quot;&lt;用户名称；可选&gt;&quot;，</span><br><span class="line">        &quot;audio_level_average&quot;：&quot;&lt;音频音量平均值，此设置覆盖房间的audio_level_average；可选&gt;&quot;，</span><br><span class="line">        &quot;audio_active_packets&quot;：&quot;&lt;音频保活包数，此设置覆盖房间audio_active_packets；可选&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此请求应该与发布者的<code>JSEP SDP Offer</code>一起提供，插件收到此消息后，将协商与之匹配的<code>JSEP SDP Answer</code>。如果成功，<code>configured</code>事件将被返回，其格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;configured&quot;：“ok&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该事件将与准备好的<code>JSEP SDP Answer</code>一起发送给客户端。</p><p>你也可以用<code>configure</code>请求代替<code>publish</code>。两者的功能在<code>发布</code>上是等效的，但从语义的角度来看，<code>publish</code>是发布时要发送的正确消息。<code>configure</code>请求也可以用于更新发布者会话的某些属性，在这种情况下，就不能用<code>publish</code>请求了。</p><blockquote><p>需要注意的是，如果用户已经发送过<code>publish</code>了，再发送<code>publish</code>将导致失败。</p></blockquote><p>其实，您可以将<code>join</code>和<code>publish</code>两个API合并为一个API请求。比如你一开始以<code>参与者</code>的身份加入，随后变为<code>发布者</code>，这时你就可以将他们合并。你可以使用<code>joinandconfigure</code>请求来做到这一点，该请求将这两个请求（join与publish)结合在一起。如果成功，则响应一个<code>joined</code>事件，并且将<code>JSEP SDP Answer</code>一起发送出去。</p><p>一旦<code>PeerConnection</code>设置成功，且发布者处于激活状态，<code>event</code>就会被发向房间中的所有<code>参与者</code>。其格式如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        “publishers&quot;：[</span><br><span class="line">                &#123;</span><br><span class="line">                        &quot;id&quot;：&lt;新发布者的唯一ID&gt;，</span><br><span class="line">                        &quot;display&quot;：&quot;&lt;新发布者的名称，如果有的话&gt;&quot;，</span><br><span class="line">                        &quot;audio_codec&quot;：&quot;&lt;新布者使用的音频编解码器，如果有的话&gt;&quot;，</span><br><span class="line">                        &quot;video_codec&quot;：&quot;&lt;新发布使用的视频编解码器，如果有的话&gt;&quot;，</span><br><span class="line">                        &quot;simulcast&quot;：&quot;&lt;如果发布者使用simucast，则为true（仅VP8和H.264）&gt;&quot;，</span><br><span class="line">                        &quot;talking&quot;：&lt;true | false，发布者是否在讲话（仅在使用音频级别的情况下）&gt;，</span><br><span class="line">                &#125;</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要停止发布并删除相关的<code>PeerConnection</code>，可以使用该<code>unpublish</code>请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：“unpublish&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当插件收到这条请求后，它会删除对应的<code>PeerConnection</code>，并将发布者从活动列表中删除。如果成功，响应如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        “unpublish&quot;：“ok&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>PeerConnection</code>删除后，插件还将向所有其他<code>参与者</code>通知该流不再可用的消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;unpublished&quot;：&lt;发布者的ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，不光收到<code>unpublish</code>消息会触发上面的事件通知，其实无论什么情况下，只要<code>发布者</code>提供的流消失了（例如，句柄已关闭或用户失去连接），都会发同样的<code>事件</code>。此外，你可以使用同一句柄的上下文多次执行<code>发布</code>或<code>取消发布</code>操作。</p></blockquote><p>正如我们上面讲过的，你可以使用<code>configure</code>请求调整发布者会话的某些属性。该请求的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;configure&quot;，</span><br><span class="line">        &quot;audio&quot;：&lt;true | false，取决于是否应该转发音频；默认为true&gt;，</span><br><span class="line">        &quot;video&quot;：&lt;true | false，取决于是否应该转发视频；默认为true&gt;，</span><br><span class="line">        &quot;data&quot;：&lt;true | false，取决于是否应该转发数据；默认为true&gt;，</span><br><span class="line">        &quot;bitrate&quot;：&lt;比特率上限；可选，如果存在则覆盖全局房间值（除非设置了bitrate_cap）&gt;，</span><br><span class="line">        &quot;keyframe&quot;：&lt;true | false，是否向发布者发送关键帧请求&gt;，</span><br><span class="line">        &quot;record&quot;：&lt;true | false，是否开启录制；可选&gt;</span><br><span class="line">        &quot;filename&quot;：&quot;&lt;如果开启了录制，指明录制路径&#x2F;文件；可选&gt;&quot;，</span><br><span class="line">        &quot;display&quot;：&quot;&lt;用户名称；可选&gt;&quot;，</span><br><span class="line">        &quot;audio_active_packets&quot;：&quot;&lt;音频保活包个数，audio_active_packets；可选&gt;&quot;，</span><br><span class="line">        &quot;audio_level_average&quot;：&quot;&lt;音频音量平均值，audio_level_average；可选&gt;&quot;，</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>configure</code>基本上与<code>publish</code>的属性相同。这就是为什么两个请求都可以用来开始发布的原因。如果<code>configure</code>成功，则返回<code>configured</code>事件，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;configured&quot;：“ok&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当发送<code>configure</code>请求RTP扩展<code>ssrc-audio-level</code>时，如果<code>audiolevel_event</code>设置为true ，则可能会向所有发布者发送一些临时事件。这些事件将具有以下格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&lt;&quot;talking&quot;|&quot;stopped-talking&quot;，是否发布者开始或停止发言&gt;，</span><br><span class="line">        &quot;room&quot;：&lt;房间的唯一ID&gt;，</span><br><span class="line">        &quot;id&quot;：&lt;发布者的唯一ID&gt;，</span><br><span class="line">        &quot;audio-level-dBov-avg&quot;：&lt;音平音量的平均值，127 &#x3D;静音，0 &#x3D;&#39;太大声&#39;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>VideoRoom</code>插件的主要目的是从WebRTC源(发布者)获取媒体，并将其转发到WebRTC目的地（订阅者），但实际上存在几种方案，可以将媒体转发给外部（不一定与WebRTC兼容）组件。例如，用于媒体处理，外部录制，转码，级联等等。<code>rtp_forward</code>顾名思义，就是将发布者发送的RTP包（普通或加密）实时转发到远程后端。</p><p>您可以使用<code>rtp_forward</code>请求为现有发布者添加新的RTP转发器，其格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;rtp_forward&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;publisher_id&quot;：&lt;发布者ID&gt;，</span><br><span class="line">        &quot;host&quot;：&quot;&lt;将RTP和数据包转发到的host主机IP地址&gt;&quot;，</span><br><span class="line">        &quot;host_family&quot;：&quot;&lt;ipv4 | ipv6，使用IPv4还是IPv6；默认情况下，无论我们得到什么&gt;&quot;，</span><br><span class="line">        &quot;audio_port&quot;：&lt;音频RTP数据包转发到的端口&gt;，</span><br><span class="line">        &quot;audio_ssrc&quot;：&lt;音频SSRC，用于流式传输；可选&gt;</span><br><span class="line">        &quot;audio_pt&quot;：&lt;音频有效负载类型；可选&gt;</span><br><span class="line">        &quot;audio_rtcp_port&quot;：&lt;接收方接收音频RTCP反馈端口；可选，当前未用于音频&gt;，</span><br><span class="line">        &quot;video_port&quot;：&lt;将视频RTP数据包转发到的端口&gt;，</span><br><span class="line">        &quot;video_ssrc&quot;：&lt;视频 SSRC；可选&gt;</span><br><span class="line">        &quot;video_pt&quot;：&lt;视频有效载荷类型；可选&gt;</span><br><span class="line">        &quot;video_rtcp_port&quot;：&lt;接收方接收视频RTCP反馈端口；可选&gt;</span><br><span class="line">        &quot;video_port_2&quot;：&lt;如果simulcast，则视频第二个的RTP数据端口&gt;，</span><br><span class="line">        &quot;video_ssrc_2&quot;：&lt;如果simulcast，则视频第二个的SSRC；可选&gt;</span><br><span class="line">        &quot;video_pt_2&quot;：&lt;如果simulcast，则视频第二个的有效载荷类型；可选&gt;</span><br><span class="line">        &quot;video_port_3&quot;：&lt;如果simulcast，则视频第三个RTP数据包端口&gt;，</span><br><span class="line">        &quot;video_ssrc_3&quot;：&lt;如果simulcast，则视频第三个SSRC；可选&gt;</span><br><span class="line">        &quot;video_pt_3&quot;：&lt;如果simulcast，则视频第三个的有效载荷类型；可选&gt;</span><br><span class="line">        &quot;data_port&quot;：&lt;数据通道消息端口&gt;，</span><br><span class="line">        &quot;srtp_suite&quot;：&lt;身份验证标签的长度（32或80）；可选&gt;</span><br><span class="line">        &quot;srtp_crypto&quot;：&quot;&lt;用作加密的密钥（如SDES中的base64编码的密钥；可选&gt;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，如上所述，如果您配置了admin_key属性，则在请求中也需要提供它，否则未授权的请求将被拒绝。默认情况下，没有对rtp_forward进行限制。</p></blockquote><p>如果请求成功则返回<code>rtp_forward</code>响应，其中格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;rtp_forward&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;publisher_id&quot;：&lt;发布者ID&gt;</span><br><span class="line">        &quot;rtp_stream&quot;：&#123;</span><br><span class="line">                &quot;host&quot;：&quot;&lt;接收流的主机IP，如果未解析，则与请求相同&gt;&quot;，</span><br><span class="line">                &quot;audio&quot;：&lt;音频RTP端口，与请求相同（如果已配置）&gt;，</span><br><span class="line">                &quot;audio_rtcp&quot;：&lt;音频RTCP端口，与请求相同（如果已配置）&gt;，</span><br><span class="line">                &quot;audio_stream_id&quot;：&lt;分配给音频RTP转发器的唯一数字ID，如果有的话，&gt;</span><br><span class="line">                &quot;video&quot;：&lt;视频RTP端口，与请求相同（如果已配置）&gt;，</span><br><span class="line">                &quot;video_rtcp&quot;：&lt;视频RTCP端口，如果配置，则与请求相同，&gt;</span><br><span class="line">                &quot;video_stream_id&quot;：&lt;分配给主视频RTP转发器的唯一数字ID，如果有的话，&gt;</span><br><span class="line">                &quot;video_2&quot;：&lt;第二个视频端口，与请求相同（如果已配置）&gt;，</span><br><span class="line">                &quot;video_stream_id_2&quot;：&lt;分配给第二层视频RTP转发器的唯一数字ID，如果有的话，&gt;</span><br><span class="line">                &quot;video_3&quot;：&lt;第三个视频端口，与请求相同（如果已配置）&gt;，</span><br><span class="line">                &quot;video_stream_id_3&quot;：&lt;分配给第三个视频RTP转发器的唯一数字ID，如果有，&gt;</span><br><span class="line">                &quot;data&quot;：&lt;数据端口，与请求相同（如果已配置）&gt;，</span><br><span class="line">                &quot;data_stream_id&quot;：&lt;分配给数据通道消息转发器的唯一数字ID（如果有）&gt;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要停止以前创建的RTP转发器，可以使用<code>stop_rtp_forward</code>请求，其格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;stop_rtp_forward&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;publisher_id&quot;：&lt;发布者ID&gt;，</span><br><span class="line">        &quot;stream_id&quot;：&lt;RTP转发器ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求成功，则返回<code>stop_rtp_forward</code>响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;stop_rtp_forward&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;publisher_id&quot;：&lt;发布者ID，与请求相同，&gt;</span><br><span class="line">        &quot;stream_id&quot;：&lt;流ID，与请求相同&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要获取特定房间中所有转发器的列表，可以使用<code>listforwarders</code>请求，其格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;listforwarders&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间的唯一数字ID&gt;，</span><br><span class="line">        &quot;secret&quot;：&quot;&lt;房间密码；如果已配置，则是必需的&gt;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求成功，则返回forwarders响应，其中包括RTP转发器列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;forwarders&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间的唯一ID&gt;，</span><br><span class="line">        &quot;rtp_forwarders&quot;：[&#x2F;&#x2F;具有RTP转发器的发布者数组</span><br><span class="line">                &#123;&#x2F;&#x2F;发布者＃1</span><br><span class="line">                        &quot;publisher_id&quot;：&lt;发布者＃1的唯一数字ID&gt;，</span><br><span class="line">                        &quot;rtp_forwarders&quot;：[&#x2F;&#x2F; RTP转发器数组</span><br><span class="line">                                &#123;&#x2F;&#x2F; RTP转发器＃1</span><br><span class="line">                                        &quot;audio_stream_id&quot;：&lt;音频RTP转发器的唯一ID，如果有的话&gt;，</span><br><span class="line">                                        &quot;video_stream_id&quot;：&lt;视频RTP转发器的唯一ID，如果有的话&gt;，</span><br><span class="line">                                        &quot;data_stream_id&quot;：&lt;数据通道消息转发器的唯一ID（如果有）&gt;，</span><br><span class="line">                                        &quot;ip&quot;：&quot;&lt;接收端IP&gt;&quot;，</span><br><span class="line">                                        &quot;port&quot;：&lt;接收端端口&gt;，</span><br><span class="line">                                        &quot;rtcp_port&quot;：&lt;接收端RTCP端口，如果有的话&gt;，</span><br><span class="line">                                        &quot;ssrc&quot;：&lt;转发器正在使用的SSRC，如果有的话&gt;，</span><br><span class="line">                                        &quot;pt&quot;：&lt;转发器正在使用的有效负载类型&gt;，</span><br><span class="line">                                        &quot;substream&quot;：&lt;视频子流，如果有&gt;，</span><br><span class="line">                                        &quot;srtp&quot;：&lt;true | false，RTP流是否已加密&gt;</span><br><span class="line">                                &#125;，</span><br><span class="line">                                &#x2F;&#x2F;此发布者的其他转发器</span><br><span class="line">                        ]，</span><br><span class="line">                &#125;，</span><br><span class="line">                &#x2F;&#x2F;其他发布者</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在会议进行期间启用或禁用录制，您可以使用<code>enable_recording</code>请求，该请求的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;enable_recording&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;secret&quot;：&quot;&lt;房间密码；如果已配置，则是必需的&gt;&quot;</span><br><span class="line">        &quot;record&quot;：&lt;true | false，是否自动记录此会议室中的参与者&gt;，</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，参与者通常也可以通过configure请求来更改自己的录制状态：这样做是为了获得最大的灵活性，您可能希望单独记录一些流，而不是全局或自动记录一些内容，到特定文件。就是说，如果你希望确保在启用全局录制后参与者不能停止其录制，或者在不应该录制该会议室的情况下启动它，那么您应该确保在创建会议室时使用lock_record属性，将其设置为true。这样，只有在提供了房间密码的情况下，才能更改录制状态，从而确保只有管理员才能执行此操作。</p></blockquote><p>最后，您可以使用<code>leave</code>请求离开会议室。如果您是会议室中的活动发布者，这也将隐式取消你的发布。该leave请求如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;leave&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果成功，响应将如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;leaving&quot;：&quot;ok&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他参与者将收到”leaving”事件，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;leaving：&lt;离开的参与者的唯一ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您是活跃的发布者，则其他用户也将收到相应的<code>unpublish</code>事件，以通知他们该流不再可用。如果您只是潜伏而不是发布者，则其他参与者将仅收到”leave”事件。</p><h2 id="VideoRoom-订阅者"><a href="#VideoRoom-订阅者" class="headerlink" title="VideoRoom 订阅者"></a>VideoRoom 订阅者</h2><p>订阅者在加入房间时，join请求的ptype属性应该设置为<code>subscriber</code>，并指定要订阅的确切的媒体流。该请求的确切语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;join&quot;，</span><br><span class="line">        &quot;ptype&quot;：&quot;subscriber&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;feed&quot;：&lt;发布者ID；强制性&gt;，</span><br><span class="line">        &quot;private_id&quot;：&lt;发起此请求的用户ID；可选的，除非房间配置要求&gt;</span><br><span class="line">        &quot;close_pc&quot;：&lt;true | false，发布者离开时是否应自动关闭PeerConnection；默认为true&gt;，</span><br><span class="line">        &quot;audio&quot;：&lt;true | false，是否转发音频；默认为true&gt;，</span><br><span class="line">        &quot;video&quot;：&lt;true | false，是否转发视频；默认为true&gt;，</span><br><span class="line">        &quot;data&quot;：&lt;true | false，是否转发数据；默认为true&gt;，</span><br><span class="line">        &quot;offer_audio&quot;：&lt;true | false; 是否应该协商音频；如果发布者的音频&gt;，默认为true</span><br><span class="line">        &quot;offer_video&quot;：&lt;true | false; 是否应该协商视频；如果发布者的视频&gt;，默认为true</span><br><span class="line">        &quot;offer_data&quot;：&lt;true | false; 是否应该协商数据通道；如果发布者的datachannels&gt;为默认值，则为true</span><br><span class="line">        &quot;substream&quot;：&lt;启用了simulcast情况下，要接收的子流（0-2）；可选&gt;</span><br><span class="line">        &quot;temporal&quot;：&lt;启用simulcast情况下，要接收的时间层（0-2）；可选&gt;</span><br><span class="line">        &quot;fallback&quot;：&lt;多少时间（在我们这里，默认为250000）没有接收到数据包将使我们下降到下面的子流&gt;，</span><br><span class="line">        &quot;spatial_layer&quot;：&lt;启用VP9-SVC时要接收的空间层（0-2）；可选&gt;</span><br><span class="line">        &quot;temporal_layer&quot;：&lt;启用VP9-SVC时要接收的时间层（0-2）；可选&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如您所见，只要指定好要订阅的发布者ID，并在需要时指定好<code>private_id</code>(订阅者ID)，其它的都可以不设置。不过请求中的<code>offer_audio</code>，<code>offer_video</code>和<code>offer_data</code>特别有意思，你可以通过它们订阅媒体的一个子集(音频\视频\数据）。</p><p>默认情况下，发送<code>join</code>请求时会导致插件层创建<code>SDP Offer</code>，用以协商发布者提供那些媒体。此外，如果发布者发布的是<code>simulcast</code>或<code>VP9 SVC</code>，那么你还可以订阅你感兴趣的子流，例如，获得最佳质量的中间质量。更有意思的是，你可以使用<code>configure</code>请求随时动态更改这些设置。</p><p>上面的请求如果成功，将生成一个新的<code>JSEP SDP Offer</code>，并伴随一个attached事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;attached&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;feed&quot;：&lt;发布者ID&gt;，</span><br><span class="line">        &quot;display&quot;：&quot;&lt;发布者的名称，如果有的话&gt;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此阶段，为了完成<code>PeerConnection</code>的设置，订阅者应将<code>JSEP SDP Answer</code>发送回插件。此操作是通过<code>start</code>请求来完成的，在这种情况下，请求必须与<code>JSEP SDP Answer</code>相关联，但是不需要任何参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：“start&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果成功，此请求将返回一个started事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;started&quot;：&quot;ok&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成此操作后，所需要做的就是等待WebRTC <code>PeerConnection</code>建立成功。一旦<code>PeerConnection</code>建立成功，Streaming插件就可以开始向订阅的观众转发媒体了。</p><blockquote><p>注意，在需要重新协商（例如出于ICE重启目的）的情况下，您也可以使用我们刚经历的相同步骤（watch请求，然后插件创建<code>JSEP Offer</code>，最后客户端发送<code>start</code>请求和<code>JSEP Answer</code>）。</p></blockquote><p>作为<code>订阅者</code>，您可以发送<code>pause</code>临时暂停或发送<code>start</code>恢复整个媒体的传送（在这种情况下，不附带任何JSEP SDP Answer）。因为上下文中已经有了相关信息，所以不需要重新进行协商。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;pause&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;start&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，它们会分别导致paused和started事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;paused&quot;：&quot;ok&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;started&quot;：&quot;ok&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>configure</code>请求可以对<code>订阅</code>做更多深入操作。该请求允许<code>订阅者</code>动态更改与媒体订阅有关的某些属性，<code>configure</code>请求的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;configure&quot;，</span><br><span class="line">        &quot;audio&quot;：&lt;true | false，是否应该转发音频；可选&gt;</span><br><span class="line">        &quot;video&quot;：&lt;true | false，是否应该转发视频；可选&gt;</span><br><span class="line">        &quot;data&quot;：&lt;true | false，是否转发数据；可选&gt;</span><br><span class="line">        &quot;substream&quot;：&lt;启用simulcast情况下，要接收的子流（0-2）；可选&gt;</span><br><span class="line">        &quot;temporal&quot;：&lt;启用simulcast，要接收的时间层（0-2）；可选&gt;</span><br><span class="line">        &quot;fallback&quot;：&lt;多少时间（在我们这里，默认为250000）没有接收到数据包将使我们下降到下面的子流&gt;，</span><br><span class="line">        &quot;spatial_layer&quot;：&lt;启用VP9-SVC时要接收的空间层（0-2）；可选&gt;</span><br><span class="line">        &quot;temporal_layer&quot;：&lt;启用VP9-SVC时要接收的时间层（0-2）；可选&gt;</span><br><span class="line">        &quot;audio_level_average&quot;：&quot;&lt;如果提供，将覆盖此用户的房间audio_level_average；可选&gt;&quot;，</span><br><span class="line">        &quot;audio_active_packets&quot;：&quot;&lt;如果提供，将覆盖此用户的房间audio_active_packets；可选&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你所看到的audio，video和data属性可以用作媒体级的暂停/恢复功能，而pause与start只是简单地暂停/恢复所有数据流。</p><p>下面来说说<code>switch</code>，switch 请求格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;switch&quot;，</span><br><span class="line">        &quot;feed&quot;：&lt;要切换到的新发布者的唯一ID；强制性&gt;，</span><br><span class="line">        &quot;audio&quot;：&lt;true | false，取决于是否应该中继音频；可选&gt;</span><br><span class="line">        &quot;video&quot;：&lt;true | false，取决于是否应该中继视频；可选&gt;</span><br><span class="line">        &quot;data&quot;：&lt;true | false，取决于是否应该中继数据通道消息；可选&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果成功，您将退订之前的发布者，然后订阅新的发布者。确认切换成功的事件如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;switched&quot;：&quot;ok&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;id&quot;：&lt;新发布者的唯一ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，要停止订阅并删除相关的PeerConnection，可以使用该leave请求。由于上下文是隐式的，因此不需要其他参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;leave&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果成功，该插件将尝试拆除PeerConnection，并发送回一个left事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;left&quot;：&quot;ok&quot;，</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>VideoRoom</code>插件是Janus的一个特别重要的插件，对于该插件的理解对于我们理解整个Janus有至关重要的意义。本文说细分析了<code>VideoRoom</code>插件中所有的信令，大体上我们可以将它们人成两在类，一类是房间管理信令，另一类是用户信令。</p><p>这些信令设计的非常巧妙，对我们研发自己的SFU会议系统是一个很好的借鉴。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://avdancedu.com/947c722a/" target="_blank" rel="noopener">多人实时互动之各WebRTC流媒体服务器比较</a><br><a href="https://avdancedu.com/d7281c13/" target="_blank" rel="noopener">janus前端核心库源码分析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/videoroom/videoroom.jpg&quot; alt=&quot;videoroom&quot;&gt;&lt;/p&gt;
&lt;p&gt;在Janus的众多插件中，大家最感兴趣的恐怕就是&lt;code&gt;VideoRoom&lt;/code&gt;插件了。因为它实现的是一个音视频会议的场景，这正是大多数同学所需要的。而且在Janus众多的插件中&lt;code&gt;VideoRoom&lt;/code&gt;应该也是最复杂的一个，如果你们撑握了它，再去看其它插件的实现就容易多了。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;VideoRoom&lt;/code&gt;中，包括了很多API，这些API是我们打开&lt;code&gt;VideoRoom&lt;/code&gt;的一把钥匙，所以本文的重点就是讲解这些API。我相信当你把这些API都撑握之后，再去看&lt;code&gt;VideoRoom&lt;/code&gt;插件的代码时就会更加游刃有余了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/categories/WebRTC/"/>
    
    
      <category term="videoroom" scheme="https://blog.avdancedu.com/tags/videoroom/"/>
    
  </entry>
  
  <entry>
    <title>WebRTC常见问题</title>
    <link href="https://blog.avdancedu.com/af19ebea/"/>
    <id>https://blog.avdancedu.com/af19ebea/</id>
    <published>2020-06-16T09:29:19.000Z</published>
    <updated>2020-06-16T16:41:09.992Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DTLS-SRTP-与-DTLS-的区别"><a href="#DTLS-SRTP-与-DTLS-的区别" class="headerlink" title="DTLS-SRTP 与 DTLS 的区别"></a>DTLS-SRTP 与 DTLS 的区别</h2><p>DTLS用于数据加密，它是从 TLS 发展而来。 TLS用于TCP，而DTLS用于UDP。<br>DTLS-SRTP 只用户握手，交换<code>fingerprint</code>和密钥，真正的加密由SRTP来完成。</p><h2 id="是否开启-DTLS-SRTP"><a href="#是否开启-DTLS-SRTP" class="headerlink" title="是否开启 DTLS-SRTP"></a>是否开启 DTLS-SRTP</h2><p>在创建PeerConnection时设置<code>DtlsSrtpKeyAgreement</code>参数可以关闭/打开 DTLS-SRTP<br><a href="https://groups.google.com/forum/#!topic/discuss-webrtc/t8XT0IxoHgw" target="_blank" rel="noopener">discuss-webrtc</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;DTLS-SRTP-与-DTLS-的区别&quot;&gt;&lt;a href=&quot;#DTLS-SRTP-与-DTLS-的区别&quot; class=&quot;headerlink&quot; title=&quot;DTLS-SRTP 与 DTLS 的区别&quot;&gt;&lt;/a&gt;DTLS-SRTP 与 DTLS 的区别&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/categories/WebRTC/"/>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/tags/WebRTC/"/>
    
  </entry>
  
  <entry>
    <title>janus前端核心库源码分析</title>
    <link href="https://blog.avdancedu.com/d7281c13/"/>
    <id>https://blog.avdancedu.com/d7281c13/</id>
    <published>2020-06-15T03:13:31.000Z</published>
    <updated>2020-06-29T05:29:06.821Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/janus_js/janus_logo.jpg" alt=""></p><p>Hello,大家好！今天我们继续来分析janus。相信现在大家应该对<a href="https://janus.conf.meetecho.com/" target="_blank" rel="noopener">janus</a> 都比较熟悉了，它是一套完整的音视频会议系统，包括了WebRTC流媒体服务器和客户端API两大部分。</p><p>其中，客户端又包括Android、iOS以及浏览器端。今天我们要分析的内容就是浏览器端中的<code>janus.js</code>文件。之所以要分析它，是因为它是浏览器端最关键的一个文件，了解了它我们基本上就将浏览器端的逻辑全部撑握了。</p><p>从大的方面说，<code>janus.js</code>主要完成两方面的事儿。一是封装了浏览器与janus流媒体服务器之间的业务接口，使得在浏览器端开发音视频会议系统变得特别简单；二是对WebRTC的API做了封装，这样用户不用再理会WebRTC底层API该何使用了。</p><p>总之一句话，就是大大的减了少JS用户使用janus的难度。</p><a id="more"></a><p>在阅读本文之前你应该已经熟悉了JavaScript语法，且对浏览器下调用WebRTC的API十分精通，否则你应该先去补齐相关知识再来阅读本文。 这里有一些参考资料仅供参考：<a href="https://avdancedu.com/18fc7df1/" target="_blank" rel="noopener">《js类的探究》</a>，在这篇文章中有介绍ES5与ES6之间的区别。<a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门与实战课程》</a>，该课程详细讲解了在浏览器下该如何使用WebRTC。</p><p>下面我们开始<code>janus.js</code>源码分析。</p><h2 id="核心类Janus"><a href="#核心类Janus" class="headerlink" title="核心类Janus"></a>核心类Janus</h2><p>对于<code>janus</code>源码的目录结构我已经在之前的文章中向你介绍过了，如果你还没看过，可以到<a href="https://avdancedu.com/fdfe2594/" target="_blank" rel="noopener">这里</a>看一下。通过目录结构我们可以知道，<code>janus.js</code>就在<code>janus</code>源码的<code>html</code>目录下。</p><p>大体浏览一下<code>janus.js</code>你会发现，整个文件有3000多行代码，但只有一个<code>类</code>，即<code>Janus</code>类。该类中实现了很多方法，然而核心代码量并不大，经抽丝拨茧，你会发现下面几个方法是比较关键的。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">function Janus(gatewayCallbacks) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建一个Session，私有方法</span><br><span class="line">    function createSession(callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;消毁Session，私有方法</span><br><span class="line">    function destroySession(callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;用于处理Janus信令</span><br><span class="line">    function eventHandler()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;信令事件处理函数，私有方法</span><br><span class="line">    function handleEvent(json, skipTimeout);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;发送消息，私有方法</span><br><span class="line">    function sendMessage(handleId, callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建插件处理函数，私有方法</span><br><span class="line">    function createHandle(callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;消毁插件处理方法</span><br><span class="line">    function destroyHandle(handleId, callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;发送candidate，私有方法</span><br><span class="line">    function sendTrickleCandidate(handleId, candidate);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建PC</span><br><span class="line">    function streamsDone(handleId, jsep, media, callbacks, stream);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;准备WebRTC</span><br><span class="line">    function prepareWebrtc(handleId, offer, callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;接收远端的SDP，并设备远端描述符</span><br><span class="line">    function prepareWebrtcPeer(handleId, callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建Offer</span><br><span class="line">    function createOffer(handleId, media, callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建answer</span><br><span class="line">    function createAnswer(handleId, media, callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;发送SDP</span><br><span class="line">    function sendSDP(handleId, callbacks);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对上面的这些方法，我们可以按类别将其划分成以下几类：</p><ul><li><p>Session相关</p><ul><li>createSession</li><li>destorySession</li></ul></li><li><p>信令处理</p><ul><li>handleEvent</li><li>eventHandler</li><li>sendMessage</li></ul></li><li><p>Plugin相关</p><ul><li>createHandle</li><li>destoryHandle</li></ul></li><li><p>WebRTC相关</p><ul><li>prepareWebrtc</li><li>prepareWebrtcPeer</li><li>createOffer</li><li>createAnswer</li><li>sendSDP</li><li>streamDone</li></ul></li></ul><p>接下来，我们就对这几个函数做下详细介绍，整体的介绍思路是：首先介绍一下它的主要功能是什么，然后再讨论一下它是怎么实现的。</p><h2 id="Session-相关"><a href="#Session-相关" class="headerlink" title="Session 相关"></a>Session 相关</h2><p>首先我们来看看 <code>Session</code> 的作用是什么。<code>Session</code>表示的是一个客户端与<code>janus</code>服务器之间建立的一个<code>信令通道</code>。janus客户端与服务器之间就是通过这个<code>信令通道</code>传输信令的。</p><p>Session是如何创建的呢？下面我们就来看一下<code>createSession</code>函数的处理逻辑。在<code>createSession</code>中，首先创建了一个JSON对象<code>request</code>，该对象中包括了以下几个信息：</p><ul><li>janus，代表一个信令，<code>create</code>表示要创建一个<code>session</code>。</li><li>token，唯一标识，用于鉴权。</li><li>apisecret，API调用码密，用于安全访问。</li></ul><p><code>request</code>对象构建好后，<code>createSession</code>函数会根据server地址的类型(如ws://、http://）判断是使用 websocket 接口还是使用 HTTP RESTFUL接口。判断逻辑如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">if(!server &amp;&amp; Janus.isArray(servers)) &#123;</span><br><span class="line">    &#x2F;&#x2F; We still need to find a working server from the list we were given</span><br><span class="line">    server &#x3D; servers[serversIndex];</span><br><span class="line">    if(server.indexOf(&quot;ws&quot;) &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">        websockets &#x3D; true;</span><br><span class="line">        Janus.log(&quot;Server #&quot; + (serversIndex+1) + &quot;: trying WebSockets to contact Janus (&quot; + server + &quot;)&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        websockets &#x3D; false;</span><br><span class="line">        Janus.log(&quot;Server #&quot; + (serversIndex+1) + &quot;: trying REST API to contact Janus (&quot; + server + &quot;)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果<code>createSession</code>判断server使用的是<code>websocket</code>接口，它就会走到<code>websocket</code>的处理逻辑分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(websockets)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个分支中，首先通过<code>Janus.newWebSocket</code>方法与server（janus服务器）建立连接。然后向websocket注册侦听事件，当websocket接收到不同的事件后就跳到对应事件的处理函数中执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">ws &#x3D; Janus.newWebSocket(server, &#39;janus-protocol&#39;);</span><br><span class="line">wsHandlers &#x3D; &#123;</span><br><span class="line">    &#39;error&#39;: ...,</span><br><span class="line">    &#39;open&#39;: ...,</span><br><span class="line">    &#39;message&#39;: ...,</span><br><span class="line">    &#39;close&#39;: ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(var eventName in wsHandlers) &#123;</span><br><span class="line">    ws.addEventListener(eventName, wsHandlers[eventName]);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在上代码中，注册到 websocket 中的 open 和 message 事件特别重要。websocket收到<code>open</code>事件说明与janus服务器之间已经成功建立了连接，此时我们就可以将之前准备好的 <code>request</code> 发送出去了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">transactions[transaction] &#x3D; function()...;</span><br><span class="line">ws.send(JSON.stringify(request));</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>当websocket连接创建好后，<code>janus.js</code>首先在transctons中创建一个新的<code>transaction</code>，然后将之前准备好的request发送给服务器。</p><blockquote><p>这里需要注意的是transaction，它表示一个事务或称之为上下文，当一件事儿由多个步骤多阶段组合完成时，我们一般都使用这种设计方案。</p></blockquote><p>服务端收到消息后进行逻辑处理，之后通过上面建立的连接将处理结果返回给<code>janus.js</code>，此时就会触发我们上面注册的<code>message</code>事件。在message事件中，对所有接收到的服务端的消息都由<code>handleEvent</code>函数进行处理。对于该函数我们后面还会做详细介绍，这里就不过多讲解了。</p><p>至此，<code>createSession</code> 函数的主要作用我们就分析完了，而<code>destorySession</code>是<code>createSession</code>的反函数，用于销毁<code>createSession</code>创建的资源，大家自己去看代码就好了，我这里不再做过多描述了。</p><p>接下来我们来看一下<code>janus.js</code>是如何处理从服务端接收到的信令的。</p><h2 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h2><p>上面讲解<code>Session</code>的创建时，我已经向你介绍了janus默认提供了两种传输信令的接口，即<code>websocket</code>处<code>http</code>。janus会根所用户访问地址的协议头来自动判断使用那种协议进行信令的传输。</p><p>对于服务端来讲，这两种接口的实现是在<code>janus</code>源码目录下的 <code>transports</code> 目录下，对应的实现文件为janus_websockets.c和janus_http.c文件，通过文件名我们也可以知道他们分别是websocket和http接口的实现了。</p><blockquote><p>当然janus不光支持这两种接口，它还支持好几种接口，但需要你手工配置。如果你不进行任何配置的话，它默认只支持这两种接口。</p></blockquote><p>下面是<code>janus</code>信令处理的简化架构图，我们通过这张图先从整体上了解一下janus是如何处理信令的。</p><p><img data-src="https://cdn.avdancedu.com/image/article/janus_js/janus_command.jpg" alt=""></p><p>上图将janus分成了两大部分，服务端和客户端。我们分别来介绍一下，首先来看看服务端的处理过程。</p><h3 id="服务端接收消息"><a href="#服务端接收消息" class="headerlink" title="服务端接收消息"></a>服务端接收消息</h3><p>通过上图我们可以看到，janus服务端的信令处理是由<code>transports</code>完成的，<code>transports</code>中包括很多插件，图中展示的<code>websocket</code>和<code>http</code>就是其中的两个。</p><p>这两个<code>transport</code>插件是在janus服务启动时加载起来的。以websocket插件为例，当该插件被加载后，websocket服务随即开启。此时，<code>janus.js</code>(JS客户端）就可以向该websocket服务发送消息了，同时<code>janus.js</code>也可以通过websocket连接接收来自服务端的信息。</p><p>当在服务端通过<code>websocket</code>收到消息后，最终会调用janus_websockets.c中的<code>janus_websockets_common_callback</code>方法将收到的消息传给janus core。janus core 收到消息后再根据消息类型做相应的处理。关于这块的逻辑我们先暂时放一放，待以有时间了我再说细介绍。</p><p>接下来我们再看客户端<code>janus.js</code>是如何处理的。</p><h3 id="客户端接收消息"><a href="#客户端接收消息" class="headerlink" title="客户端接收消息"></a>客户端接收消息</h3><p>客户端是如何处理消息的呢？我们还是从<code>Session</code>创建之后讲起。在<code>创建Session</code>一节中我已经介绍了，janus在websocket上侦听了<code>message</code>事件，每当websocket收到服务端发来的消息时，就会触发该事件。</p><p><code>janus.js</code>对该事件的处理方法是也比较简单，不管三七二十一直接将event中带来的数据交收<code>handleEvent</code>处理。<code>handleEvent</code>又是如何做的呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function handleEvent(json, skipTimeout) &#123;</span><br><span class="line">  ...</span><br><span class="line">  if(json[&quot;janus&quot;] &#x3D;&#x3D;&#x3D; &quot;keepalive&quot;) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; else if(json[&quot;janus&quot;] &#x3D;&#x3D;&#x3D; &quot;ack&quot;) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; else if(json[&quot;janus&quot;] &#x3D;&#x3D;&#x3D; &quot;success&quot;) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; else if(...</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>handleEvent</code>处理逻辑就如上面所示，对消息类型做判断，根据不同的类型做不同的处理。它能处理的消息包括以下几种:</p><ul><li>keepalive，心跳消息。</li><li>ack，确认消息。也就是说之前客户端发送了一个信令给服务端，服务端收到之后给客户端回了一个<code>ack</code>，确认服务端已经收到该消息了。</li><li>success，消息处理成功。该消息与 ack 消息是类似的，当服务器完成了客户端的命令后会返回该消息。</li><li>trickle，收集<code>候选者</code>用的消息。里边存放着 candidate，janus.js收到该消息后，需要将Candidate解析出来。</li><li>webrtcup，表示一个peer上线了，此时要找到以应的业务插件（plugin）做业务处理。</li><li>hangup，用户挂断，找到对应的plugin，进行挂断操作。</li><li>detached，某个插件要求与Janus Core之间断开连接。</li><li>media，开始或停信媒体流。</li><li>slowlink，限流？</li><li>error，错误消息</li><li>event，插件发磅的事件消息。</li><li>timeout，超时。</li></ul><p>对于janus.js来讲，上面这些消息有些是不需要再做处理的，有些是需要修改状态的，还有一些是与业务插件有关的，需要交由<code>pluginHandle</code>做进一步处理。 关于<code>pluginHandle</code>后面我们再做介绍。</p><p>以上就是janus客户端对从服务端接收到的消息的处理过程。当然在你阅读代码时还会看到<code>eventHandler</code>函数，这个函数是对handleEvent函数简单的封装，用在http接口上。由于websocket接口是长连接，所以直接使用的handleEvent函数，我们清楚这两个函数的联系与区别就OK了。</p><h3 id="客户端发送消息"><a href="#客户端发送消息" class="headerlink" title="客户端发送消息"></a>客户端发送消息</h3><p>上面我们主要介绍了从服务端来的消息janus是如何处理的，那客户端是如何发送消息的呢？</p><p>在<code>janus.js</code>中为上层应用封装了一个发送消息的方法，即<code>config.send()</code>。这个函数实际调用的是janus的<code>sendMessage</code>方法。我们来看一下它的大体实现吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function sendMessage(handleId, callbacks) &#123;</span><br><span class="line">    ...</span><br><span class="line">    var pluginHandle &#x3D; pluginHandles[handleId];</span><br><span class="line">    ...</span><br><span class="line">    var message &#x3D; callbacks.message;</span><br><span class="line">    ...</span><br><span class="line">    if(pluginHandle.token)</span><br><span class="line">        request[&quot;token&quot;] &#x3D; pluginHandle.token;</span><br><span class="line">    ...</span><br><span class="line">    var request &#x3D; &#123; &quot;janus&quot;: &quot;message&quot;, &quot;body&quot;: message, &quot;transaction&quot;: transaction &#125;;</span><br><span class="line">    ...</span><br><span class="line">    if(websockets)&#123;</span><br><span class="line">        ws.send(JSON.stringify(request));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码我们可以发现，在<code>sendMessage</code>中主要是构造<code>request</code>对象，然后将构造好的<code>request</code>消息通过<code>websocket</code>发送出去。</p><p>消息发送给janus服务器，服务器处理好后又会给客户端返回消息。消息返回到客户端后，后会触发websocket的<code>message</code>事件，这样就又回到了我们上面介绍的<code>handleEvent</code>处理函数。</p><h2 id="Plugin相关"><a href="#Plugin相关" class="headerlink" title="Plugin相关"></a>Plugin相关</h2><p>在<code>janus.js</code>中，<code>Plugin</code>相关函数的主要作用是，在客户端创建一个<code>pluginHandle</code>对象，并让该对象与janus服务端的某个插件关联。</p><p>所谓的关联就是在<code>pluginHandle</code>对象中保存着可以访问janus服务端插件的信息。该对象中存放着很多的信息，如session、plugin、webrtc等信息。下面我抽取了一些比较关键的信息，我们来详细分析一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">session : that,</span><br><span class="line">plugin : plugin,</span><br><span class="line">...</span><br><span class="line">token : handleToken,</span><br><span class="line">detached : false,</span><br><span class="line">webrtcStuff : &#123;</span><br><span class="line">    ...</span><br><span class="line">    mySdp : null,</span><br><span class="line">    mediaConstraints : null,</span><br><span class="line">    pc : null,</span><br><span class="line">    trickle : true,</span><br><span class="line">    iceDone : false,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面的字段就是<code>pluginHandle</code>对象的一些重要信息，在这些信息中包括了两在部分，基础信息部分和WebRTC信息部分。</p><p>首先我们看一下基础信息。session中保存的是<code>janus</code>核心类对象；plugin指明我们要与服务端那个个插件建立联接，例如<code>vidoeroom</code>插件；token用于安全访问；detached表明是否已经与服务端对应的<code>plugin</code>建立了联系。</p><p>接下来<code>webrtcStuff</code>域是与webrtc相关的参数。mySdp中保存的是本地SDP信息；mediaConstrains存放用于采集音视频数据的限制参数；pc表示PeerConnection；trickle指明在使用WebRTC时是否使用<code>trickle</code>机制；iceDone表明是否ICE建立成功了。</p><p>该对象中的内容是由<code>createHandle</code>函数创建和填充的，下面我们就来看一下<code>createHandle</code>函数做了哪些事儿？</p><p>在该函数中，它首先构造<code>request</code>对象，该对象包括以下几个信息：</p><ul><li>janus，表示信令类型， 在<code>createHandle</code>函数中，该域填的内容为<code>attach</code>，表示与某个<code>plugin</code> 进行绑定。</li><li>plugin，指明要绑定的具体<code>plugin</code>。<code>janus.plugin.videoroom</code></li><li>opaque_id，一个唯一的ID。</li><li>transaction，表示一个事务ID。</li><li>token，用于与服务器连接的合法标识</li><li>apisecret，API密码。</li><li>sessionID，session的唯一标识。</li></ul><p><code>request</code>对象创建好后，通过websocket发送给服务端，这样就在客户端与服务端的plugin插件建立了联接。</p><p>除了创建<code>request</code>对象外，该函数还创建了一个transaction对象，并将它存放在 <code>transactions</code> 数组中(<code>transactions[transaction]</code>)。</p><p>实际上 <code>transaction</code> 是一个函数，该函数中会创建一个<code>pluginHandle</code>对象，<code>pluginHandle</code>创建好后，也会被保存起来放到<code>pluginHandles</code>里以备后面使用。</p><p>除了<code>createHandle</code>函数之外，在janus.js中还有<code>destoryHandle</code>函数，它是<code>createHandle</code>的反函数，用于做释放操作。</p><p>以上就是janus.js中处理Plugin相关的函数。</p><h2 id="Webrtc相关"><a href="#Webrtc相关" class="headerlink" title="Webrtc相关"></a>Webrtc相关</h2><p>在<code>janus.js</code>中WebRTC相关的方法是最多的，也是最为重要的。其中尤以<code>prepareWebRTC</code>最为重要。下面我们就来详细介绍一下这个函数。</p><p>这个函数的作用是什么呢？说来起它还是蛮复杂的，我们来一项一项来介绍。一、它要过浏览器采集音视频数据，以便可以将数据上传给远端；二要与按照WebRTC的规规范进行媒体协商；三协商成功后要与远端建立连接；最后把采集的数据压缩编码后传到远端；</p><p>这个函数代码量非常大，我抽取了函数中重要的逻辑，这样更有利于我们撑握整个函数的流程脉络。代码整理如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">if(isAudioSendEnabled(media) || isVideoSendEnabled(media)) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;media为空，或者media.video不为屏幕，说明现在想采集视频数据</span><br><span class="line">    if(!media || media.video !&#x3D;&#x3D; &#39;screen&#39;) &#123;</span><br><span class="line">        &#x2F;&#x2F;遍历每个设备</span><br><span class="line">        navigator.mediaDevices.enumerateDevices().then( function(devices) &#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;如果是音频输入设备</span><br><span class="line">            var audioExist &#x3D; devices.some(function(device) &#123;</span><br><span class="line">                                return device.kind &#x3D;&#x3D;&#x3D; &#39;audioinput&#39;;</span><br><span class="line">                            &#125;),</span><br><span class="line">            &#x2F;&#x2F;如果是视频输入设置</span><br><span class="line">            videoExist &#x3D; isScreenSendEnabled(media) || devices.some(function(device) &#123;</span><br><span class="line">                                return device.kind &#x3D;&#x3D;&#x3D; &#39;videoinput&#39;;</span><br><span class="line">                            &#125;);</span><br><span class="line">           ...</span><br><span class="line">           &#x2F;&#x2F;设置采集数据的限制条件</span><br><span class="line">           var gumConstraints &#x3D; &#123;</span><br><span class="line">              audio: (audioExist &amp;&amp; !media.keepAudio) ? audioSupport : false,</span><br><span class="line">              video: (videoExist &amp;&amp; !media.keepVideo) ? videoSupport : false</span><br><span class="line">           &#125;;</span><br><span class="line"></span><br><span class="line">           ...</span><br><span class="line">           &#x2F;&#x2F;采集数据</span><br><span class="line">           navigator.mediaDevices.getUserMedia(gumConstraints)</span><br><span class="line">             .then(function(stream) &#123;</span><br><span class="line">               ...</span><br><span class="line">               &#x2F;&#x2F;</span><br><span class="line">               streamsDone(handleId, jsep, media, callbacks, stream);</span><br><span class="line">             &#125;).catch(function(error) &#123;...&#125;);</span><br><span class="line"></span><br><span class="line">        &#125;).catch(...);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过代码的梳理我们可以看到<code>prepareWebrtc</code>函数首先遍历所有设备，找出可用的设备，之外调用`getUserMedia函数去采集音视频数据。之后像媒体协商、Candidate的收集都在 streamDone 函数中完成。</p><p>接下来我们继续分析<code>streamsDone</code> 函数。下面是<code>streamsDone</code>函数的主要脉络代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function streamsDone(handleId, jsep, media, callbacks, stream) &#123;</span><br><span class="line">    ...</span><br><span class="line">    var config &#x3D; pluginHandle.webrtcStuff;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;创建PeerConnection</span><br><span class="line">    f(!config.pc) &#123;</span><br><span class="line">        var pc_config &#x3D; &#123;&quot;iceServers&quot;: iceServers, &quot;iceTransportPolicy&quot;: iceTransportPolicy, &quot;bundlePolicy&quot;: bundlePolicy&#125;;</span><br><span class="line">        ...</span><br><span class="line">        var pc_constraints &#x3D; &#123;</span><br><span class="line">            &quot;optional&quot;: [&#123;&quot;DtlsSrtpKeyAgreement&quot;: true&#125;]</span><br><span class="line">        &#125;;</span><br><span class="line">        ...</span><br><span class="line">        config.pc &#x3D; new RTCPeerConnection(pc_config, pc_constraints);</span><br><span class="line">        config.pc.oniceconnectionstatechange &#x3D; ...;</span><br><span class="line">        config.pc.onicecandidate &#x3D; ...;</span><br><span class="line">        config.pc.ontrack &#x3D; ...;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将本地track添加到流中</span><br><span class="line">    if(addTracks &amp;&amp; stream) &#123;</span><br><span class="line">        ...</span><br><span class="line">        config.pc.addTrack(track, stream);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建offer进行媒体协商</span><br><span class="line">    if(!jsep) &#123;</span><br><span class="line">        createOffer(handleId, media, callbacks);</span><br><span class="line">    &#125;else&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该函数中首先会根据限制条件创建一个<code>PeerConnection</code>。PeerConnection简称PC，它是浏览器下使用WebRTC的核心，想了解这块知识的同学可以看一下我的课程<a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门与实战》</a>，这里我就不过多讲解这部分内容了。</p><p>PC创建好后，需要将之前从<code>prepareWebrtc</code>中获取的本地音视频轨添加到PC中，为媒体协商做好准备。最后调用createOffer函数生成媒体协商中的<code>Offer</code>SDP与远端交换从成完成媒体协商。</p><p>现在你应该了解<code>streamsDone</code>函数的作用了吧？同时也应该清楚<code>prepareWebrtc</code>函数是干什么的了。</p><p>当我们将<code>prepareWebrtc</code>函数的功能搞清楚之后，对于其它的WebRTC相关API就比较容易理解了，由于篇幅的原因我就不在这里一一做介绍了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>上面我对janus.js文件做了全面的剖析，通过本文你应该知道<code>janus.js</code>的API可以分成四大类，分别是Session相关，信令相关，Plugin相关以及WebRTC相关的API。同时你也应该清楚，janus中的Session表示的是客户端与服务端之间的网络连接；客户端与服务器之间的信令是如何交互的，以及包括了哪些信令；<code>pluginHandle</code>的作用是用来保存访问远端插件的信息用的，同时它也保存了操作WebRTC相关的信息；而WebRTC相关的API是janus.js中最关键，最为复杂的。尤其是<code>prepareWebrtc</code>函数是最核心的API。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://avdancedu.com/18fc7df1/" target="_blank" rel="noopener">《js类的探究》</a>文中介绍了ES5与ES6之间的区别</li><li><a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门与实战课程》</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/janus_js/janus_logo.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Hello,大家好！今天我们继续来分析janus。相信现在大家应该对&lt;a href=&quot;https://janus.conf.meetecho.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;janus&lt;/a&gt; 都比较熟悉了，它是一套完整的音视频会议系统，包括了WebRTC流媒体服务器和客户端API两大部分。&lt;/p&gt;
&lt;p&gt;其中，客户端又包括Android、iOS以及浏览器端。今天我们要分析的内容就是浏览器端中的&lt;code&gt;janus.js&lt;/code&gt;文件。之所以要分析它，是因为它是浏览器端最关键的一个文件，了解了它我们基本上就将浏览器端的逻辑全部撑握了。&lt;/p&gt;
&lt;p&gt;从大的方面说，&lt;code&gt;janus.js&lt;/code&gt;主要完成两方面的事儿。一是封装了浏览器与janus流媒体服务器之间的业务接口，使得在浏览器端开发音视频会议系统变得特别简单；二是对WebRTC的API做了封装，这样用户不用再理会WebRTC底层API该何使用了。&lt;/p&gt;
&lt;p&gt;总之一句话，就是大大的减了少JS用户使用janus的难度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/categories/WebRTC/"/>
    
    
      <category term="janus" scheme="https://blog.avdancedu.com/tags/janus/"/>
    
  </entry>
  
  <entry>
    <title>音视频已强势崛起，我们该如何快速入门音视频技术？</title>
    <link href="https://blog.avdancedu.com/811929dc/"/>
    <id>https://blog.avdancedu.com/811929dc/</id>
    <published>2020-06-14T16:51:59.000Z</published>
    <updated>2020-06-29T05:28:25.028Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者： 李超 音视频直播技术专家<br>曾在 跟谁学 负责直播平台技术团队的管理工作；在 新东方集团 任职音视频技术专家；<br>在音视频会议行业工作6年，在线教育行业工作4年，一直聚焦在多人音视频实时互动领域。</p></blockquote><p>最近经常遇到一些同学问我如何学习音视频，怎样才能快速上手？还有一些对音视频不了解的同学问我该不该学习音视频？作为一名音视频行业的10年老兵，我有一些思考分享给大家，希望能对你有所帮助。</p><a id="more"></a><h2 id="大背景"><a href="#大背景" class="headerlink" title="大背景"></a>大背景</h2><p><img data-src="https://img1.sycdn.imooc.com/5e84c07f0001c21806890390.jpg" alt=""></p><p>2020年真的是一个多灾、多难的年份，冠状病毒的爆发使得本该举国欢庆的春节变得尤为沉闷。不能走亲，不能访友，除了呆在家里，那儿也不能去。正如张文宏大夫向我们劝解的，我们要将病毒给<code>闷死</code>。</p><p>大家都盼着疫情可以赶紧过去，早点恢复正常的生活。但从目前的情况看，短时间内这个疫情是很难结束的。这不刚从中国消停了一阵，又跑到海外大爆发了，谁知道它会不会又转回来呢？</p><p>可我们还得生活！还得工作！还要学习！</p><h2 id="好时代"><a href="#好时代" class="headerlink" title="好时代"></a>好时代</h2><p><img data-src="https://img1.sycdn.imooc.com/5e84c080000173fe12000437.jpg" alt=""></p><p>幸运的是我们生活在一个好时代，科技在这几十年得到了迅猛的发展。在疫情肆虐的当下，我们可以通过音视频会议进行远程办公；我们还有在线教育系统，对于大多数学生来说，完全可以在家进行在线学习。</p><p>从某个角度看，这次疫情虽然导致很多行业处于崩溃边缘，但也催生了新的行业发展，其中音视频会议和在线教育就是因<code>疫</code>而起的行业。在疫情短时间内难以结束的情况下，音视频会议和在线教育的重要性马上体现了出来，新的沟通方式和教育方式被越来越多的人所认知，所接纳。</p><p>甚至我们可以判定，在线教育行业和音视频会议行业会在今年崛起，并在未来十年得到迅猛发展。</p><p>目前，各大巨头公司（如阿里、腾讯、今日头条，新东方等），纷纷在这两个方向上谋篇布局，进行了大量的投资，笼络技术人才，也可以间接佐证这个判断了。</p><h2 id="大趋势"><a href="#大趋势" class="headerlink" title="大趋势"></a>大趋势</h2><p><img data-src="https://img1.sycdn.imooc.com/5e84c0820001ade512400564.jpg" alt=""></p><p>从未来的大趋势来看，随着5G时代的到来，音视频慢慢变成人们日常生活中的必须品。除了在线教育、音视频会议、即时通讯这些必须使用音视频技术的产品外，其它的产品也需要加入音频、视频元素。比如说将现在的网站注册与登陆的图文方式全部改为语音方式是否更加安全？相信随着音视频技术的普及，更加有创意的产品会如雨后春笋般孕育而生。</p><p>目前，音视频技术从之前的<strong>象牙塔</strong>逐渐走向<strong>百姓家</strong>已是不争的事实。正是因为这样一个大的趋势，现在除了各大厂之外，其它一些小厂也开始寻找音视频人才。一名稍好点的音视频人才现在可能会有3-4家公司抢着要、挣着要。</p><p>对音视频人才的需求从小众变成了大众，这更多的是大家对未来市场预期的结果。做个不恰当的比喻，3G/4G的出现，促成了移动互联网10年繁荣。而5G的出现，也会促成至少10年音视频行业的繁荣。</p><p><strong>除了5G的到来可以让音视频得到更广范的应用外，音视频技术在未来还有更重要的作用</strong>。事实上，在人类可以识别人信息中，音视频包含的信息是最丰富的，但人类并没有很好的将它们利用起来。</p><p>究其原因，是因为这些信息都是非结构化的数据，而人类善长的是处理结构化数据（比如数据库）。而对于这些非结构化的数据却无从下手的，所以这些音视频数据都被白白浪费掉了。</p><p>但随着计算机视觉、人工智能的发展，人们开始撑握了如何将音视频这类非结构化数据转化为结构化数据的方法。一旦我们将音视频数据转为结构化数据后，我们就可以利用现有的技术（如搜索引擎、大数据，数据挖掘等）对这些数据进行各种分析了，这个价值是不是更加惊人呢？而这一切的基础都是音视频技术。</p><p>所以，音视频研发的未来是极为广阔的。目前可以说是学习音视频的最佳时机，<strong>及早的加入音视频研发的队伍，才能使自己在未来的职场上更有作为</strong>。</p><h2 id="有钱景"><a href="#有钱景" class="headerlink" title="有钱景"></a>有钱景</h2><p><img data-src="https://img2.sycdn.imooc.com/5e84c0830001d45512000437.jpg" alt=""></p><p>正如我上面所说的，各大厂为了争夺未来，抢占先机，不惜重金笼络人才。通过招聘市场我们可以了解到，一名合格的音视频开发人员，少则年薪 30 万起，多则可以达 100万以上。</p><p>出现这种情况的原因主要有两个，一是音视频方面的人才不好培养，二是现有的优秀人才太少了。</p><p>从技术上来说，音视频从业者分成两个方向，一是搞算法的，另一个是搞工程的。搞音视频算法的这类人非常少，需要有深的数学能力和算法背景。相对来说，学习成本高，一般企业不需要，也养不起。这类人一般都会选择去大公司，薪水百万都是Low的。这些人一般只专注在一个领域上，因此就业面也窄。</p><p>搞工程的人相对多一些，他们有扎实的理论基础，很强的技术功底，对音频/视频都非常熟悉。这类人才工资要比同级别的其它开发人员薪资高20%以上。</p><p>因此，搞音视频技术的开发人员钱景还是非常乐观的。而且随着时间的推移，在未来几年音视频人才会更加炙手可热。</p><h2 id="音视频好学吗？"><a href="#音视频好学吗？" class="headerlink" title="音视频好学吗？"></a>音视频好学吗？</h2><p><img data-src="https://img1.sycdn.imooc.com/5e84c0850001c42712400565.jpg" alt=""></p><p>说句实话，音视频自学起来困难重重，学习成本非常高，且效率低。主要有两方面的原因，一是音视频知识庞杂，通俗易懂的资料非常少；另一方面，网上充斥着大量的错误信息，使得很多初学者掉到坑里就爬不出来了。</p><p>我来举个例子，按照传统的音视频学习方法，学习音视频你首先要阅读大量的音视频规范/协议文档（如H264、MP4/FLV、RTP/RTCP等）。这些文档中的内容基本都以<strong>位</strong>为单位的，即每个二进制位的变化都代表不同的含义，这种文档极其枯燥，很难阅读。</p><p>在对文档熟悉的前提下，再进行代码的开发难度就“更上一层楼”了。这时你会发现，如果你对 C/C++ 使用不熟练，没有专门进行过训练的话，你就进入了炼狱般的状况，那是一种折磨。</p><p>好在现在有FFMPG、WebRTC 等开源库，大大降低了研发成本。但即使这样，对于小白同学来说学习音视频依然是十分困难的。</p><h2 id="小白如何学习音视频？"><a href="#小白如何学习音视频？" class="headerlink" title="小白如何学习音视频？"></a>小白如何学习音视频？</h2><p><img data-src="https://img1.sycdn.imooc.com/5e84c0850001599610240576.jpg" alt=""></p><p>如上面所讲，音视频的入门难度还是蛮大的，我们该如何更快的入门呢？</p><p>我觉得最好的方式有非常好的课程，可以循序渐近，有条理、系统的学习。当然能有老师指导，遇到问题时老师能及时给予解答就更加锦上添花了。这样既可以快速入门，又可以系统的学习音视频知识，可以说这是最佳途径了。</p><p>对于能力强的同学也可以自学，但相对来说，这个时间成本就太高了。遇到一个坑卡几天是很正常的。网上音视频资料那么多坑，你想想要经历多长时间你才能真正学会它呢？即使你历尽千辛入门之后，你会发现离用人单位的要求还差着十万八千里呢。</p><p>对于各大厂来说，他们要招聘的人才既要有非常扎实的基础知识，又需要有一定的工程经验；如果你在学习的过程中没有实际做一些项目就很难达到它们的要求。</p><p>正是基于这样的考虑，我推出了一系列音视频的课程。这些课程中既有适合小白同学入门的课程（如<a href="https://coding.imooc.com/class/415.html?mc_marking=458ad0334bdc050a302667f903757fa0&mc_channel=shouji" target="_blank" rel="noopener">音视频小白系统入门</a>）, 又有进阶的课程（如<a href="https://coding.imooc.com/class/279.html?mc_marking=59c321c0417e144904c49c366f94dd57&mc_channel=shouji" target="_blank" rel="noopener">FFmpeg音视频核心技术精讲与实战</a>）。</p><p>其中与ffmpeg相关的课程是<a href="https://coding.imooc.com/class/415.html?mc_marking=458ad0334bdc050a302667f903757fa0&mc_channel=shouji" target="_blank" rel="noopener">音视频小白系统入门</a>和<a href="https://coding.imooc.com/class/279.html?mc_marking=59c321c0417e144904c49c366f94dd57&mc_channel=shouji" target="_blank" rel="noopener">FFmpeg音视频核心技术精讲与实战</a>。与 WebRTC 相关的课程是<a href="https://coding.imooc.com/class/329.html?mc_marking=59909dfb407cd07d4f3998dbc2d45c49&mc_channel=shouji" target="_blank" rel="noopener">WebRTC实时互动直播技术入门与实战</a>和 <a href="https://coding.imooc.com/class/387.html?mc_marking=6ebf81516468954587f53973c3c1789a&mc_channel=shouji" target="_blank" rel="noopener">WebRTC流媒体服务器设计与开发</a>。</p><p>如果你想学习音视频基础知识，音视频处理、编辑、特效相关的内容就学习ffmpeg的系列课程。如果你想学习音视频实时通讯（如音视频会议、在线教育）就学习WebRTC相关的课程。</p><h2 id="入门音视频要学习哪些内容呢？"><a href="#入门音视频要学习哪些内容呢？" class="headerlink" title="入门音视频要学习哪些内容呢？"></a><a href="https://coding.imooc.com/class/415.html?mc_marking=458ad0334bdc050a302667f903757fa0&mc_channel=shouji" target="_blank" rel="noopener">入门音视频要学习哪些内容呢？</a></h2><p><img data-src="https://img1.sycdn.imooc.com/5e84c086000163a706360300.jpg" alt=""></p><p>这里我简单列举一下入门音视频都要学哪些知识。对于已经学习了一些音视频知识而不知道自己目前水平的同学也可以作为一个参考，看看自己是否达到了入门水平。</p><ul><li>ffmpeg在不同系统中的安装与简单裁剪</li><li>音频基础知识，如频率、采样大小和通道数等</li><li>音频的压缩原理</li><li>如何从不同的设备上采集音频数据</li><li>如何对音频进行不同的编解码</li><li>视频的基础知识</li><li>H264编码原理</li><li>如何从不同设备上采集视频数据</li><li>熟悉YUV的一些常见格式（YUV420、NV21，YV12的不同）</li><li>如何将YUV数据编码为H264/H265、VP8/VP9等</li><li>FLV/RTMP/HLS/MP4协议要十分清楚<br>……</li></ul><p>从上面的列表中你可能看到，要入门音视频要学的知识还是不少的。尤其是音视频的基础原理是最为重要的，否则你去面试人家问你为什么会产生花屏，为什么会产生卡顿，如何才能秒开这些简单的问题你都无法回答上来。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总之，音视频已经强势崛起，相信未来的十年一定是音视频的十年。并且将音视频技术与计算机视觉和人工智能结合将引领未来二十年。</p><p>现在正是学习音视技术的最佳时机，大家一定要把握住机会，跟上时代的步伐，让自己可以在未来大有作为。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://coding.imooc.com/class/415.html?mc_marking=458ad0334bdc050a302667f903757fa0&mc_channel=shouji" target="_blank" rel="noopener">音视频小白系统入门</a></li><li><a href="https://coding.imooc.com/class/279.html?mc_marking=59c321c0417e144904c49c366f94dd57&mc_channel=shouji" target="_blank" rel="noopener">FFmpeg音视频核心技术精讲与实战</a></li><li><a href="https://coding.imooc.com/class/329.html?mc_marking=59909dfb407cd07d4f3998dbc2d45c49&mc_channel=shouji" target="_blank" rel="noopener">WebRTC实时互动直播技术入门与实战</a></li><li><a href="https://coding.imooc.com/class/387.html?mc_marking=6ebf81516468954587f53973c3c1789a&mc_channel=shouji" target="_blank" rel="noopener">WebRTC流媒体服务器设计与开发</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者： 李超 音视频直播技术专家&lt;br&gt;曾在 跟谁学 负责直播平台技术团队的管理工作；在 新东方集团 任职音视频技术专家；&lt;br&gt;在音视频会议行业工作6年，在线教育行业工作4年，一直聚焦在多人音视频实时互动领域。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近经常遇到一些同学问我如何学习音视频，怎样才能快速上手？还有一些对音视频不了解的同学问我该不该学习音视频？作为一名音视频行业的10年老兵，我有一些思考分享给大家，希望能对你有所帮助。&lt;/p&gt;
    
    </summary>
    
    
      <category term="音视频" scheme="https://blog.avdancedu.com/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="https://blog.avdancedu.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript入门</title>
    <link href="https://blog.avdancedu.com/48922786/"/>
    <id>https://blog.avdancedu.com/48922786/</id>
    <published>2020-06-12T16:12:07.000Z</published>
    <updated>2020-06-28T16:47:53.092Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/typescript/typescript.jpg" alt="TypeScript"><br>我们要学习一门新知识，首先要了解一些新知识的历史。<code>TypeScript</code> 是微软开发的，它的出现是为了解决 <code>JavaScript</code> 没有类型检查的弊端。因此，<code>TypeScript</code>并不是一门新语言，它的作用就是帮<code>JavaScript</code>检查数据类型是否正确，所以称它为<code>JavaScript</code>的一个<code>超集</code>是更贴切的。</p><p>有很多同学对 <code>TypeScript</code> 产生疑惑，他们会问 <code>TypeScript</code> 可以在浏览器上运行吗？</p><a id="more"></a><p>虽然<code>TypeScript</code>是<code>JavaScript</code>的一个<code>超集</code>，但由于它要进行类型检查，所以就与 JavaScript 的语法有一些不同了，因此 TypeScript 编写的程序是无法直接运行在浏览器上的。</p><h2 id="TypeScript-工作原理"><a href="#TypeScript-工作原理" class="headerlink" title="TypeScript 工作原理"></a>TypeScript 工作原理</h2><p>在讲解 <code>TypeScript</code> 工作原理之前，有一句话是你必须清楚且要印在脑子里的: <strong>在浏览器上，只能运行 JavaScript 脚本</strong>。</p><p>既然浏览器里只能运行<code>JavaScript</code>，那<code>TypeScript</code>具体又做了什么事儿呢？下面我就向你解释一下<code>TypeScript</code>都做了哪些事儿。</p><p>学习过编译原理的同学都清楚，<strong>类型检查</strong>就是<strong>语法分析</strong>，它属于编译器的范筹。TypeScript官网说: <strong>“TypeScrpt是JavaScript的超集，可以进行JavaScript类型检查。”</strong> 表明<code>TypeScript</code>为<code>JavaScript</code>增加了<strong>类型语法</strong>，并且它还有一个<strong>编译器</strong>，可以将用<code>TypeScript</code>语法编写的程序（.ts文件)，<strong>翻译成</strong> <code>JavaScript</code> 脚本语言。</p><p>因此，<code>TypeScript</code>的使用步骤一定是这样的: 首先用 <code>TypeScript</code> 语法编写程序；然后<strong>编译</strong>，输出<code>JavaScript</code>脚本；最终在浏览器中引用生成的 JavaScript 脚本这样一个过程。</p><p>实际情况也确实如此，在TypeScript的官网上你可以找到，TypeScript 有一个编译工具称为 <code>tsc</code>，即 <code>t</code>(ype) <code>s</code>(cript) <code>c</code>(ompiler)的缩写 。</p><h2 id="JavaScript的最大问题"><a href="#JavaScript的最大问题" class="headerlink" title="JavaScript的最大问题"></a>JavaScript的最大问题</h2><p>使用过其它面向对象语言的同学们再使用JavaScript开发时，都会觉得特别<code>难受</code>，因为JavaScript无法进行类型检查。对于Javascript语法来说，你传给它什么类型的数据都可以，这样虽然看似很<code>很好</code>，但一旦你将数据传错了，你得到的结果就是错误的。当错误出现时，没有任何的提示，光凭我们肉眼去查找错误实在是太费力了，这就是JavaScript的最大问题。</p><p>我们来看一个最简单的JavaScript例子你应该就清楚了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function func(msg)&#123;</span><br><span class="line">    console.log(&quot;the message is :&quot; + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码是一段最简单的JS代码，它需要一个字符串参数。但由于JavaScript并没有对参数的类型做限制，所以你在调用这个函数时，可以给他传任意的值。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func(123);</span><br><span class="line">func(&#39;this is my book!&#39;);</span><br><span class="line">func(func);</span><br></pre></td></tr></table></figure><p>我的本意是只有第二种调用<code>func</code>的方式才是正确的，但在JavaScript中上面这几种调用<code>func</code>函数的方法都是正确的。在我们实际工作中，我们写了很长的代码后，传入了一个错误的值时JavaScript就无法为我们检测出那里出错了，这是最可怕的。</p><p>这也是为什么<code>TypeScript</code>逐渐受到大家喜欢的原因。</p><h2 id="一个最简单的-TypeScript-程序"><a href="#一个最简单的-TypeScript-程序" class="headerlink" title="一个最简单的 TypeScript 程序"></a>一个最简单的 TypeScript 程序</h2><p>下面我们就来写一个最简单的 TypeScript程序，了解一下整个使用过程。咱们还是以 Helloworld 为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function hello(person: string) &#123;</span><br><span class="line">  return &#39;Hello , &#39; + person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let user&#x3D;&#39;xxx&#39;</span><br><span class="line">console.log(hello(user));</span><br></pre></td></tr></table></figure><p>上面就是一个简单的 TypeScript脚本，有了这个脚本后我们需要先对其进行编译，编译执行下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc hello.ts</span><br></pre></td></tr></table></figure><p>编译出 JavaScript 脚本后，通过 HTML5 引用一下就好了，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;user typescript&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;.&#x2F;hellots.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br></pre></td></tr></table></figure><p>至此，一个 TypeScript的简单使用过程就完成了，还是蛮简单的对吧！</p><h2 id="TS-调用JS"><a href="#TS-调用JS" class="headerlink" title="TS 调用JS"></a>TS 调用JS</h2><p>我们在使用TS开发时最常见的一个问题是如何通过 TS 调用 JS。产生该问题的根本原因是一些著名的 JS 库(如VUE）的TS版本还没有开发出来，但我们的项目中又必须使用他们，因此就产生了我前面所说的TS 库要调用 JS 库的情况。</p><p>我们前面也讲了 TS 本来就是 JS 的一个<code>超集</code>，因此它是有办法调用JS库的。从原理上我们可以证明这一点，因为TS程序最终要经过编译生成JS脚本程序后才能被浏览器执行，因此只要在浏览器上引入它需要的 JS 库，经编译后的 TS 程序就可以与其它的JS库相互调用。</p><p>按照上面的描述好像TS 调JS是很简单的事儿，那问题在哪儿呢？其实问题在于如果我们自己写的 TS 程序调用了其它第三方 JS 库，那么正常情况下 <code>tsc</code> 编译我们的 <code>ts</code> 程序时就会报错。所以实际的问题应该是，我们编写的TS程序在调用第三方JS库时，如何可以顺利编译通过呢？</p><p>我们在网上可以找到以下几种方案，第一种是将引用到的 JS 库直接翻译成 TS 库。很多同学看到这句话会<code>嗤之以鼻</code>，这明显就是行不通的方案。不过这种方案虽然难度很大，但总归还是一种方案不是；第二种是让<code>tsc</code>编译器不进行类型检查，那也就失去了 <code>TS</code> 的意义，所以这种方法也不是好办法；第三种是为 JS 库增加声名函数，这种方式既可以让<code>tsc</code>在编译时顺利通过，又同时可以检查我们写的代码是否有问题。</p><p>所以综上所述，第三种方案是最优的方案。</p><p>接下来我就来重点讲解一下如何通过第三种方案实现<code>TS</code>调用第三方<code>JS库</code>。首先我们先来创建一个JS库<code>test.js</code>，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function showmsg(msg)&#123;</span><br><span class="line">    console.log(&quot;the msg is :&quot; + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码非常简单，只实现了一个函数。该函数有一个参数<code>msg</code>，当该函数被调用时，输出传入的参数值。</p><p>接下来我们来看一下在<code>TS</code>中如何调用JS中的方法。为了使 TS 可以调用JS的方法，我们需要写一个与<code>JS</code>文件名对应的<code>.d.ts</code>文件。对于我们上面的<code>test.js</code>则需要有一个<code>test.d.ts</code>与之对应。</p><p>编写<code>.d.ts</code>文件也很简单，对于test.js来说，它的<code>.d.ts</code>文件内容如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare function showmsg( msg: string) : void;</span><br></pre></td></tr></table></figure><p>只需要这样一句就可以了。实际上，它就是为test.js文件中的showmsg函数定个声名。然后我们在使用它的TS文件中引用这个<code>.d.ts</code>文件就好了。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;reference path &#x3D; &quot;.&#x2F;test.d.ts&quot; &#x2F;&gt;</span><br><span class="line">function doSomeThing()&#123;</span><br><span class="line">    showmsg(&#39;ts&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doSomeThing();</span><br></pre></td></tr></table></figure><p>在TS文件中引用<code>.d.ts</code>文件的方法是，在文件的开头写上 <code>/// &lt;reference path=&quot;./test.d.ts&quot; /&gt;</code> 即可。这样当我们使用<code>tsc</code>去编译<code>.ts</code>文件时就不会报错了。</p><p>当<code>tsc</code>编译好TS文件后，我们可以在HTML中引入生成的JS文件以及它所使用的JS库了。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt; test ts call js&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;script src&#x3D;&quot;.&#x2F;test.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">        &lt;script src&#x3D;&quot;.&#x2F;my.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>此时，在浏览器的<code>debugger</code>里就可以看到<code>the msg is :ts</code>这句话了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我向你介绍了<code>TypeScript</code>的基本工作原理，从中我们可能知道TypeScript解决了JavaScript最大的问题，即类型检测。但TypeScript并不是一门新语言，它也不会代替JavaScript，它只是JavaScript的一个超集而以。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/typescript/typescript.jpg&quot; alt=&quot;TypeScript&quot;&gt;&lt;br&gt;我们要学习一门新知识，首先要了解一些新知识的历史。&lt;code&gt;TypeScript&lt;/code&gt; 是微软开发的，它的出现是为了解决 &lt;code&gt;JavaScript&lt;/code&gt; 没有类型检查的弊端。因此，&lt;code&gt;TypeScript&lt;/code&gt;并不是一门新语言，它的作用就是帮&lt;code&gt;JavaScript&lt;/code&gt;检查数据类型是否正确，所以称它为&lt;code&gt;JavaScript&lt;/code&gt;的一个&lt;code&gt;超集&lt;/code&gt;是更贴切的。&lt;/p&gt;
&lt;p&gt;有很多同学对 &lt;code&gt;TypeScript&lt;/code&gt; 产生疑惑，他们会问 &lt;code&gt;TypeScript&lt;/code&gt; 可以在浏览器上运行吗？&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://blog.avdancedu.com/categories/JavaScript/"/>
    
    
      <category term="js" scheme="https://blog.avdancedu.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>多人实时互动之各WebRTC流媒体服务器比较</title>
    <link href="https://blog.avdancedu.com/947c722a/"/>
    <id>https://blog.avdancedu.com/947c722a/</id>
    <published>2020-06-12T08:02:41.000Z</published>
    <updated>2020-06-28T16:45:20.478Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/sfu/conference.jpg" alt="SUF"><br>随着网络基础设施的提高，音视频实时通信越来越成为人们日常生活和工作中必不可少的需求。2011年 WebRTC的出现，则更加速了这种需求变为现实的可能性。</p><p>熟悉 WebRTC 的同学应该都知道，WebRTC规范只定义了实时通信中客户端的行为，而没有规范服务端（包括哪些信令、数据如何流转）的行为。所以，你可以使用WebRTC库方便的实现 1:1 实时通信，但对于多人实时互动，光依靠 WebRTC库显然就无法完成要求了。</p><p>那我们该如何实现多人实时互动通信呢？</p><a id="more"></a><h2 id="WebRTC-流媒体服务器"><a href="#WebRTC-流媒体服务器" class="headerlink" title="WebRTC 流媒体服务器"></a>WebRTC 流媒体服务器</h2><p>要想实现多人的实时互动，如音视频会议、在线教育这类产品，我们必须使用 WebRTC + WebRTC流媒体服务器这种方案。</p><p>目前有很多比较有名的开源流媒体服务器，如 Janus、Medooze、Mediasoup、Licode(OWT)、Jitsi等等。这些流媒体服务器各有优缺点，下面我就对这几种流媒体服务器作下简要的介绍与比较。</p><p>通过本文，你将知道各 WebRTC 流媒体服务器的优缺点，并依俱它们的优缺点选择出更适合你的那款WebRTC流媒体服务器。</p><h3 id="Mediasoup"><a href="#Mediasoup" class="headerlink" title="Mediasoup"></a>Mediasoup</h3><p><img data-src="https://cdn.avdancedu.com/image/article/sfu/mediasoup.jpg" alt="mediasoup 整体结构"></p><p>上图是Mediasoup整体架构图，通过该图我们可以知道 Mediasoup 流媒体服务器是由 Nodejs 和 Mediasoup(C++) 两部分组成。</p><ul><li>Nodejs，负责 Mediasoup 的信令接收与业务管理。如创建/消毁房间，创建/关闭生产者，创建/关闭消费者等。</li><li>Mediasoup(C++)，这是一个单独的程序，但该程序无法直接启动。因为它在内部会判断是否是 Nodejs 将它启动起来了。只有在Nodejs 的 Mediasoup 管理模块加载之后，再将 Mediasoup(C++)启动起来，这样它才能正常工作。</li></ul><p>在众多的 WebRTC 流媒体服务器中，Mediasoup 可以说是性能最优秀的WebRTC流媒体服务器。它使用 C++ 作为开发语言，底层使用 libuv 处理 I/O 事件。</p><p>有很多人对 Nodejs 比较诟病，认为 Nodejs 提拱不了高性能的流媒体服务器。实际上，如果按照传输的 Nodejs 应用开发出的流媒体服务器肯定是不能胜任这项工作的。但对于 Mediasoup 来讲，它只不过使用 Nodejs 做 信令处理 及 业务的管理 工作，所以它的负担并不重。对性能要求高的是媒体数据流的转发工作，而这部分工作是由 Mediasoup(C++)部分实现的。Nodejs 与 Mediasoup之间通过管道进行通信。</p><p>严格意义上来说，Mediasoup是单进程的。但你不要以为这就影响了它的性能。实际上，它是使用单进程的方式将服务器上CPU某个 <code>核</code> 充分利用好，然后在业务层控制进程的个数。比如说你的服务器是个 8 核的CPU，那么在业务层你就该启动 8 个Mediasoup进程。通过这种方式来达到对 CPU 的充分利用。</p><p><img data-src="https://cdn.avdancedu.com/image/article/sfu/mediasoup_arch.jpg" alt="mediasoup结构图"></p><p>Mediasoup中的每个进程称为一个 Worker, 你也可以把它理解为一个<code>节点</code>，在每个 Worker 中可以有多个 Router。对于 Router，你站在不同的解度可以有不同的理解。如果你占在应用层的角度，你可以把它理解为一个房间；如果你站在数据流转的角度，可以把它理解为一个路由器，数据通过 <code>路由器</code> 转发给目标用户。</p><p>想了解更多Mediasoup的细节，可以观看我的视频课 <a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">《百万级高并发WebRTC流媒体服务器设计与开发》</a>，在这个视频中我对 Mediasoup 源码做了深入剖析。</p><h3 id="Janus"><a href="#Janus" class="headerlink" title="Janus"></a>Janus</h3><p><img data-src="https://cdn.avdancedu.com/image/article/sfu/janus_arch.jpg" alt="Janus架构"></p><p>上面这张图是 Janus 的整体架构图。在这张图中我们可以看到， 从大的方面说 Janus 由 Janus CORE、Janus Plugin 以及信令接口三部分组成。</p><ul><li>信令接口，Janus 支持的信令协议比较多，如 HTTP、WebSocket、RabbitMQ 等。这些信令协议使得 Janus 具有非常好的接入性。因为很多公司喜欢各种不同的协议，如有的喜欢 websocket，有的喜欢http，proto等。因此 Janus 在信令接入方面具有很大的优势。</li><li>Janus Plugin，Janus 的业务管理是按照 Plugin 的方式管理的，因此你可以在Janus中根据自己的需要实现自己的业务插件。实际上，对于一般性的需求 Janus 已经相关的插件。如：<ul><li>VideoRoom，用于多人音视频互动，像音视频会议，在线教育都可以通过该插件来实现。</li><li>VideoCall，用于 1:1 的音视频通信。</li><li>SIP，用于与传统电话设备对接。</li><li>Streaming，用于广播，也就是我们通常所说的一人共享，多人观看的直播模式。</li><li>TextRoom，它是一个聊天室，通过它可以进行文本聊天。</li><li>RecordPlay，用于录制和回放。</li></ul></li><li>Janus Core 是Janus的核心，其作用是处理流的转发，各种协议的接入。以浏览器为例，要想让浏览器接入到 WebRTC 流媒体服务器上，那流媒体服务器必须要支持 STUN、DTLS、SRTP、ICE 等协议。而 Janus Core 就是专门做这事儿的。</li></ul><p>Janus 是由 C语言开发的，因此它的性能非常优秀。要说不足的话，janus 底层没有使用 epoll 这类异步I/O事件处理机制，这应该说是它的一大缺陷；另外，Janus还使用 glib 库，由于 glib 库对于国内的很多开发同学来说用的比较少，所以会有一定的学习成本。</p><p>整体上看，Janus采用了插件的架构设计方案。这种方案非常适合于有多种业务模型或业务经常发生变化的公司或项目。另外 Janus 支持多种消息传输协议，这对于开发人员来说具有极大的吸引力。</p><h2 id="Medooze"><a href="#Medooze" class="headerlink" title="Medooze"></a>Medooze</h2><p><img data-src="https://cdn.avdancedu.com/image/article/sfu/medooze_arch.jpg" alt="Medooze 架构.png"></p><p>Medooze 的整体架构与 Mediasoup 类似，不过它的信令处理、业务管理以及媒体数据的转发功能都是放在 Nodejs下进行统一管理的。实际上，这样的管理方式也不会对性能造成什么影响，因为重的媒体流的转发工作仍然是使用的 C++ 在 Nodejs 底层实现的。</p><p>Medooze 的业务功能要比 Mediasoup 强大，像服务端录制、推流这些 Mediasoup 没有的功能它都支持。但它性能没有 Mediasoup 做的极致，在Medooze的底层使用的poll来处理I/O事件，poll与epoll性能相差距大。除此之外，Medooze的业务逻辑也没有Mediasoup简洁；另外与 Janus 相比，它的业务管理不如 Janus 灵活，Janus 的插件管理方式显然要优于 Medooze 和 mediasoup。</p><p>但总的来说，Medooze还是一款非常不错的 WebRTC 流媒体服务器。虽然有一些小的暇疵，但还是非常不错的一款流媒体服务器。</p><p>想了解更多 Medooze 细节的同学可以看我的专栏 <a href="https://time.geekbang.org/column/article/136000" target="_blank" rel="noopener">《从0打造音视频直播系统》</a>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过上面的描述，我想你应该对目前主流的 WebRTC 流媒体服务器有了一个大体的了解。所以在选型上你可以按照自己团队的能力进行评估到底该用那个流媒体服务器。</p><p>如果你团队能力比较强，可以做底层开发，那么建议你使用 Mediasoup。因为 Mediasoup 不关心应用层，它关注的是底层数据如何高效的流转，代码简洁、高效，性能极佳。</p><p>如果你们要做的业务种类比较多，变化比较快，那建议你选择使用 Janus 作为流媒体服务器。将你的业务做成一个插件放到 Janus上很快就能实现你们的业务需求。</p><p>如果你们的业务变化不大，除了追求性能外，还需要录制、推流之类的功能，那么你可以选择使用Medooze，它可以很好的满足你们的需求。</p><p>当然，除了上面我介绍到的几款比较流行的 WebRTC 流媒体服务器外，还有一些其它的流媒体服务器，如 Licode、OWT、Jitsi等也可以选择。</p><p>Licode 之所以名气比较大，是因为它推出的时间比较早。而 OWT 是 Licode 的一个变种，它在 Licode上实现了 SFU 功能。看一下 Licode 代码你就会发现，Licode 实现了一套完整的音视频会议系统，对于这样一套系统它的实现非常复杂。如果你的团队没有音视频方面的开发人才的话，可以考虑Licode，将它搭建出来之后就可以直接使用了。但如果你有业务变化想修改它就太麻烦了。</p><p>Jitsi 上层是使用 Java 语言开发的，但底层也是使用的 C/C++ 语言。它通过 JNI 来实现Java与 C/C++之间的通信。在 2018 年有机构做过一次性能评测，当时 Jitsi 表现比较差强人意，不知现在是否已经有了改进。</p><p>以上就是对几款 WebRTC流媒体服务器的比较，希望本文可以帮助你解决WebRTC流媒体服务器的选择问题。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">《百万级高并发WebRTC流媒体服务器设计与开发》</a></li><li><a href="https://time.geekbang.org/column/article/136000" target="_blank" rel="noopener">《从0打造音视频直播系统》</a></li><li><a href="https://www.jianshu.com/p/159ab573c38d" target="_blank" rel="noopener">音视频会议系统 Janus 的布署与安装</a></li><li><a href="https://www.jianshu.com/p/98674c32aef8" target="_blank" rel="noopener">Janus的线程模型</a></li><li><a href="https://www.jianshu.com/p/7867916c52e3" target="_blank" rel="noopener">理解Janus中的Plugin</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/sfu/conference.jpg&quot; alt=&quot;SUF&quot;&gt;&lt;br&gt;随着网络基础设施的提高，音视频实时通信越来越成为人们日常生活和工作中必不可少的需求。2011年 WebRTC的出现，则更加速了这种需求变为现实的可能性。&lt;/p&gt;
&lt;p&gt;熟悉 WebRTC 的同学应该都知道，WebRTC规范只定义了实时通信中客户端的行为，而没有规范服务端（包括哪些信令、数据如何流转）的行为。所以，你可以使用WebRTC库方便的实现 1:1 实时通信，但对于多人实时互动，光依靠 WebRTC库显然就无法完成要求了。&lt;/p&gt;
&lt;p&gt;那我们该如何实现多人实时互动通信呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/categories/WebRTC/"/>
    
    
      <category term="mediasoup" scheme="https://blog.avdancedu.com/tags/mediasoup/"/>
    
  </entry>
  
  <entry>
    <title>mediasoup 课程常见问题</title>
    <link href="https://blog.avdancedu.com/5a9f427c/"/>
    <id>https://blog.avdancedu.com/5a9f427c/</id>
    <published>2020-06-12T07:00:00.000Z</published>
    <updated>2020-06-28T16:46:20.857Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/mediasoup_ask/mediasoup_banner.jpg" alt="mediasoup"><br>《WebRTC流媒体服器》课程推出已经有一段时间了，受到很多同学们的好评，是慕课网为数不多的10分好课。这门课是专门讲解与WebRTC互通的流媒体服务器的高端课，课程从如何开发服务器程序讲起，逐步向你介绍如何构建出一个可商用的、高并发的、性能优越的流媒体服务器。</p><p>该服务器可以与Chrome等浏览器对接，实现多人音视频会议系统或实时互动在线教育系统。毫不夸张的说，只要你能撑握课程中的 85% 的内容，去应聘流媒体服务器的研发岗时，你就不用再担心技术问题了。</p><a id="more"></a><p>在课程的评论区有很多评论，有兴趣的同学也可以参考一下</p><p><img data-src="https://cdn.avdancedu.com/image/article/mediasoup_ask/ping.jpg" alt="课程评论"></p><p>同学们在学习课程内容的时候也经常问一些问题，这里我总结了一些大家常见的问题以及问题答案希望对你能有所帮助。</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="Q-有mediasoup、janus、licode等流媒体服务器的比较吗？"><a href="#Q-有mediasoup、janus、licode等流媒体服务器的比较吗？" class="headerlink" title="Q: 有mediasoup、janus、licode等流媒体服务器的比较吗？"></a>Q: 有mediasoup、janus、licode等流媒体服务器的比较吗？</h3><p>A: <a href="https://www.avdancedu.com/947c722a/" target="_blank" rel="noopener">可以看我这篇文章</a></p><h3 id="Q-有各流媒体服务器之间的性能比较吗？"><a href="#Q-有各流媒体服务器之间的性能比较吗？" class="headerlink" title="Q: 有各流媒体服务器之间的性能比较吗？"></a>Q: 有各流媒体服务器之间的性能比较吗？</h3><p>A: <a href="https://webrtchacks.com/sfu-load-testing/" target="_blank" rel="noopener">可以看这篇文章</a></p><h3 id="Q-单台mediasoup流媒体服务器能承载多少路流？"><a href="#Q-单台mediasoup流媒体服务器能承载多少路流？" class="headerlink" title="Q: 单台mediasoup流媒体服务器能承载多少路流？"></a>Q: 单台mediasoup流媒体服务器能承载多少路流？</h3><p>A: 官方答案为 500 路流。</p><h3 id="Q-布署流媒体服务器是需要怎样的配置"><a href="#Q-布署流媒体服务器是需要怎样的配置" class="headerlink" title="Q: 布署流媒体服务器是需要怎样的配置?"></a>Q: 布署流媒体服务器是需要怎样的配置?</h3><p>A: <a href="https://github.com/havfo/multiparty-meeting/wiki/Scaling-and-recommended-Hardware" target="_blank" rel="noopener">这里有一份说明</a></p><h3 id="Q-mediasoup安装时报错是什么原因？"><a href="#Q-mediasoup安装时报错是什么原因？" class="headerlink" title="Q: mediasoup安装时报错是什么原因？"></a>Q: mediasoup安装时报错是什么原因？</h3><p>A: 建议使用Ubuntu18.04 安装mediasoup。</p><h3 id="Q-在Ubuntu18-04上安装也报错"><a href="#Q-在Ubuntu18-04上安装也报错" class="headerlink" title="Q: 在Ubuntu18.04上安装也报错"></a>Q: 在Ubuntu18.04上安装也报错</h3><p>A: node 版本在 10 以上，npm 版本在 6.4 版本以上。</p><h3 id="Q-mediasoup安装好后看不对远端视频"><a href="#Q-mediasoup安装好后看不对远端视频" class="headerlink" title="Q: mediasoup安装好后看不对远端视频"></a>Q: mediasoup安装好后看不对远端视频</h3><p>A: 配置文件是否配置对了？检查一下IP地址不要写成127.0.0.1</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">WebRTC高并发流媒体服务器mediasoup</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/mediasoup_ask/mediasoup_banner.jpg&quot; alt=&quot;mediasoup&quot;&gt;&lt;br&gt;《WebRTC流媒体服器》课程推出已经有一段时间了，受到很多同学们的好评，是慕课网为数不多的10分好课。这门课是专门讲解与WebRTC互通的流媒体服务器的高端课，课程从如何开发服务器程序讲起，逐步向你介绍如何构建出一个可商用的、高并发的、性能优越的流媒体服务器。&lt;/p&gt;
&lt;p&gt;该服务器可以与Chrome等浏览器对接，实现多人音视频会议系统或实时互动在线教育系统。毫不夸张的说，只要你能撑握课程中的 85% 的内容，去应聘流媒体服务器的研发岗时，你就不用再担心技术问题了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/categories/WebRTC/"/>
    
    
      <category term="mediasoup" scheme="https://blog.avdancedu.com/tags/mediasoup/"/>
    
  </entry>
  
  <entry>
    <title>js类的探究</title>
    <link href="https://blog.avdancedu.com/18fc7df1/"/>
    <id>https://blog.avdancedu.com/18fc7df1/</id>
    <published>2020-06-10T07:38:47.000Z</published>
    <updated>2020-06-28T16:49:16.690Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/js/javascript.png" alt="javascript"></p><p>随着浏览器的发展，JS（JavaScript) 越来越受到人们的欢迎。它不再像以前只能做单一的渲染页面这样的事情了，在Chrome等现代浏览器上，你甚至可以用JS来做音视频的处理，是不是觉得很神奇？</p><p>不过今天我要讨论的并不是如何使用JS来做一些<strong>神奇</strong>的事儿，而是来重新认识一下JS中<strong>类</strong>的使用。对于这部分知识的理解，将为我们后面阅读Janus(一款WebRTC流媒体服务器)代码有着至关重要的作用。</p><a id="more"></a><h2 id="JS中的function"><a href="#JS中的function" class="headerlink" title="JS中的function"></a>JS中的function</h2><p>在ES5以前，JS中并没有<strong>class</strong>关键字，那时候JS是如何表示一个类的呢？说来也奇怪，它使用<strong>function</strong>来表示。</p><p>我在了解这部分知识的时候也是觉得不可思意！实际上我早在2003年的时候就学习并使用JS了，那时候JS还很简单。虽然后来很久没有再碰过它，但印象中<strong>function</strong>一直是用来定义一个函数的，现在怎么又用来定义<strong>类</strong>了呢？</p><p>后来看了一些资料才逐渐理清，原来现在的JS中<code>function</code>既可以用来定义函数，也可以用来定义类。有点类似于语文中的<strong>一语双关</strong>。</p><p>之所以<code>function</code>有双层含义，是因为JS最开始并不支持面向对象开发模式。但随着技术的发展，面向对象的开发模式越来越受到人们的欢迎，JS为了能跟上时代，所以也必须支持面向对象开发。</p><p>不过JS在转向面向对象语言时面临一种选择，即从原生语言上支持<code>class</code>，那JS解析器就要做大的调整，这可不是一时半会儿可以完成的。而如果在原有的基础上修改则要容易得多。</p><p>权衡利弊之后，JS<code>大神</code>们还是决定在现有的基础上修改是最省时少力的。于是就借用了<code>function</code>函数，把它看作是一个<strong>构造函数</strong>，这样就可以快速的将JS改造成面向对象的开发语言了。</p><p>以上就是JS中使用<code>function</code>定义类的大致由头！下面我们就来看看在ES5上该如何定义一个<strong>类</strong>。</p><h2 id="类及成员"><a href="#类及成员" class="headerlink" title="类及成员"></a>类及成员</h2><p>在JS中如何定义一个类呢？实际上它与其它面向对象语言(如Java)是很类似的，只不过在Java中定义类用的是<code>class</code>关键字，而在JS中用<code>function</code>代替而以。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function classname() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 中，类的成员按安全性可以分为<strong>公有</strong>和<strong>私有</strong>，JS中是否也有类似的概念呢？答案是肯定的，接下来我们就来看一下在JS类中如何定义公有成员和私有成员吧。</p><p>JS中公有成员和私有成员的定义都是隐式的，不像Java有明确的<code>public</code>和<code>private</code>关键字来指明它们的权限。在JS类中直接定义的函数或变量都是私有成员，在类成员或函数前面加<code>this</code>关键字的，则表式是公有成员。</p><p>我们来看个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function myclass ()&#123;</span><br><span class="line"></span><br><span class="line">    function test()&#123;</span><br><span class="line">        console.log(&quot;testA function&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; new myclass();</span><br><span class="line">obj.test();</span><br></pre></td></tr></table></figure><p>如果我们在浏览器执行上面的代码，在浏览器的<code>debugger</code>中你一定可以看到这样一条错误信息<code>“Uncaught TypeError: obj.testfunc is not a function”</code>，这说明通过<code>obj</code>对像是无法访问到<code>test()</code>函数的。</p><p>我们稍微调整一下这段代码，修改如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function myclass ()&#123;</span><br><span class="line"></span><br><span class="line">    this.test &#x3D; test() &#123; &#x2F;&#x2F;这里加了this 关键字</span><br><span class="line">        console.log(&quot;testA function&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; new myclass();</span><br><span class="line">obj.test();</span><br></pre></td></tr></table></figure><p>我们在<code>test</code>函数前加上<code>this.</code>，只做这一点点修改，这段代码就可以在浏览器上成功运行了。</p><p>由此我们可以知道，如果你想让外面访问对象中的成员（成员变量或成员方法），你就应该在这些成员前面加上<code>this</code>关键字。反过来讲，如果你不想让外面访问到对象中的成员，则不要在这些成员前面加<code>this</code>。</p><h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><p>在Java中除了有对象成员外，还可以有类成员，比如在使用单例模式时，我们都会定义一个静态的成员。在JS中如何做到这点呢？我们来看个具体例子吧。还是刚才那个代码，我们在其基础上稍做修改即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;定义类方法</span><br><span class="line">myclass.init &#x3D; function()&#123; </span><br><span class="line">    console.log(&quot;class method!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function myclass ()&#123;</span><br><span class="line"></span><br><span class="line">    this.test &#x3D; test() &#123; &#x2F;&#x2F;这里加了this 关键字</span><br><span class="line">        console.log(&quot;testA function&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调用类方法</span><br><span class="line">myclass.init();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建对象</span><br><span class="line">var obj &#x3D; new myclass();</span><br><span class="line">obj.test();</span><br></pre></td></tr></table></figure><p>在这段代码中，加入了类方法的定义及调用类方法的代码。从上述代码中我们可以知道，在JS中类方法是在类之外定义的，而不像Java在是类内加<code>static</code>关键字。</p><h2 id="类的原型prototype"><a href="#类的原型prototype" class="headerlink" title="类的原型prototype"></a>类的原型prototype</h2><p>在JS中，每个类都有一个类属性<code>prototype</code>，用来指向类原型。或者你可以把它理解为指向<strong>类原型的地址</strong>。当我们想为这个类添加方法或成员变量的时候，就可以通过prototype来实现，只需修改prototype指向的内存地址的内容就可以达到添加成员的目的。</p><p>举个例子，假设我们定义了一个类如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function myjs()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前在这个类中没有写任何方法或成员变量，只是定义了一个空类。下面我想修改这个类，给这个类增加一些内容，该怎么做呢？实现的方法很简单，修改prototype即可，看下面的例子你就明白了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function myjs()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myjs.prototype.a  &#x3D; 5;</span><br><span class="line">myjs.prototype.test &#x3D; function() &#123;</span><br><span class="line">    console.log(&quot;this is a function of myjs object!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; new myjs();</span><br><span class="line">console.log(&quot;myjs.a &#x3D;&#x3D; &quot; + obj.a );</span><br><span class="line">obj.test();</span><br></pre></td></tr></table></figure><p>通过上面的代码，我们就给<code>myjs</code>类增加了两个成员，即一个变量<code>a</code>和一个方法<code>test</code>。当我们生成myjs对象时，生成的对象中就有我们之前添加的成员变量和成员方法了。</p><h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>JS中没有专门用于类继承的语法，不过你可以通过上一节介绍的prototype来实现<code>类继承</code>。在我们正式讲解继承之前，我们先了解一下prototype在内存中是如何表示的。如下图所示：<br><img data-src="https://cdn.avdancedu.com/image/article/js/prototype.jpg" alt="prototype"></p><p>通过上图我们可以看到，使用<code>function</code>定义的类并非真实的<code>类</code>，更准确的说它应该是一个<code>构造函数</code>。而类属性<code>prototype</code>指向的才是类的真正地址。</p><p>可能很多同学会问JS是如何通过构造函数找到它所在的类的呢？其实这是C语言的一个小巧，其过程是JS调用浏览器，通过浏览器使用C语言中的<code>技巧</code>获取构造函数所在类的地址，这对于浏览器来当然是小菜一碟。</p><p>了解了<code>prototype</code>的物理意义后，接下来我们看看类生成的对象在内存中的情况，它与prototype之间的关系又是怎样的？如下图所示。<br><img data-src="https://cdn.avdancedu.com/image/article/js/js_obj.jpg" alt="对象在内存中"></p><p>通过上图我们可以看到，JS在创建对象时会为每个对象分配内存空间。更为重要的一点是，多个相同类型的<code>对象</code>会指向同一个prototype。</p><p>了解了上面的特性后，我们就可以利用<code>prototype</code>来实现类的继承了。如何来做呢？我们再来举个例子。</p><p>首先，我们定义一个基类，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function parent() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;给基类添加一个新的属性 a</span><br><span class="line">parent.prototype.a &#x3D; 1;</span><br></pre></td></tr></table></figure><p>然后，我们创建一个子类，并让子类的prototype指向父类，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function child() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">child.prototype &#x3D; new parent();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;再给子类添加一个属性 b</span><br><span class="line">child.prototype.b &#x3D; 2;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建子类</span><br><span class="line">var obj_child &#x3D; new child();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;访问子类的属性</span><br><span class="line">console.log(&quot;a &#x3D; &quot; + obj_child.a);</span><br><span class="line">console.log(&quot;b &#x3D; &quot; + obj_child.b);</span><br></pre></td></tr></table></figure><p>执行上面的例子，我们通过浏览器的<code>debugger</code>就可以看到如下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; 1</span><br><span class="line">b &#x3D; 2</span><br></pre></td></tr></table></figure><p>说明child子类确实是继承了parent类。我们再深扒一下，对于上面这段代码表示的继承关系在内存中的物理意义是什么呢？如下图所示：</p><p><img data-src="https://cdn.avdancedu.com/image/article/js/js_extend.jpg" alt="js继承"></p><p>在JS中，正常情况下每生成一个对象，该对象的 <code>__proto__</code> 都指向该对象的<strong>原始类的地址</strong>。如上图所示parent对象的<code>__proto__</code>指向parent.prototype，child对象的<code>__proto__</code>指向child.prototype。</p><p>为什么会这样呢？要理解其中的奥秘，我们必须要知道JS中 <code>new xxx</code> 做了哪些事儿。实际上，<code>new xxx</code> 做了四件事儿，我们以上图中的<code>new parent()</code>为例，它做的四件事儿如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;&#125;;</span><br><span class="line">obj.__proto__ &#x3D; parent.prototype; &#x2F;&#x2F;即parent</span><br><span class="line">parent.call(obj);                 &#x2F;&#x2F;调用parent的构造函数</span><br><span class="line">return obj;</span><br></pre></td></tr></table></figure><p>在这步中，第二步是最关键的，它表明了新对象的<code>__proto__</code>指向了哪里。这样我们就可以理解 <strong>“对象的 <code>__proto__</code> 都指向该对象的原始类的地址”</strong> 这句话了。</p><p>当我们理解了 <code>new xxx</code> 的真实含义之后，<code>child.prototype = new parent()</code> 这句代码的含义立马就清楚了，它的含义是改变 <code>child.prototype</code> 的指向， 让他重新指向<code>parent</code>对象。</p><p>由于生成parent对象时，它的<code>__proto__</code>指向了parent的<strong>原始类</strong>，因此child.prototype就与parent的prototype建立了连接。</p><p>在接下来创建<code>obj_child</code>对象时，由于child.prototype已经指向了parent对象，因此<code>obj_child.__proto__</code>也就指向了parent对象。此时通过 old_child 就可以访问到parent对象的内容了，从而也就达到了继承的目的。</p><h2 id="ES6-中的类"><a href="#ES6-中的类" class="headerlink" title="ES6 中的类"></a>ES6 中的类</h2><p>大家对于在JS中使用<code>function</code>方式定义类实在感到很厌烦，就不能与其它语言一样可以使用<code>class</code>来定义类吗？在ES6时代，JS终于可以做到这一点了。</p><p>现在我们来看看在JS中该如何定义类吧，例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class cls &#123;</span><br><span class="line">    constructor(arg)&#123;</span><br><span class="line">        this.a &#x3D; arg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    do()&#123;</span><br><span class="line">        console.log(&quot;a value &#x3D;&#x3D;&quot; + this.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var t &#x3D; new cls(&#39;hello&#39;);</span><br><span class="line">t.do();</span><br></pre></td></tr></table></figure><p>上面的代码是不是看着就舒服多了？但实际上，ES6中的<code>class</code>只是一个<code>语法糖</code>。啥意思呢？也就是说虽然语法上JS改成了与其它面向对象语言一致的用法，但在JS内部还是使用的<code>function</code>的机制来实现的。</p><h3 id="公有成员与私有成员"><a href="#公有成员与私有成员" class="headerlink" title="公有成员与私有成员"></a>公有成员与私有成员</h3><p>使用 ES6 中的 <code>class</code> 定义类时，类中的成员默认都是公有成员，外面都可以直接访问到。当然在class中也可以使用<code>#</code>来定义私有成员变量，但一般情况下我们很少用到。我们来看一下例子吧，在上面的代码中做一点修改即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class cls &#123;</span><br><span class="line">    #a;</span><br><span class="line">    constructor(arg)&#123;</span><br><span class="line">        this.#a &#x3D; arg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    do()&#123;</span><br><span class="line">        console.log(&quot;a value &#x3D;&#x3D;&quot; + this.#a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var t &#x3D; new cls(&#39;hello&#39;);</span><br><span class="line">console.log(&quot;#a&#x3D; &quot; + t.#a);</span><br><span class="line">t.do();</span><br></pre></td></tr></table></figure><p>我们在上面代码中增加了 <code>#a</code> 变量，因<code>#</code>表示的是私有成员，所以当我们创建对象 <code>t</code> 后，通过 <code>t.a</code> 是无法访问它的，此时只能通过cls类的成员方法<code>do()</code>才能访问 <code>#a</code>变量。</p><h3 id="类的继承-1"><a href="#类的继承-1" class="headerlink" title="类的继承"></a>类的继承</h3><p>接下来我们再来看看在 ES6 中如何实现<code>类的继承</code>。在ES5中要实现类继承必须使用<code>prototype</code>，如果你不从内存存储的角度去思考的话，就很难理解它是如何实现<code>类继承</code>的。而在 ES6 中，类的继承就就像我们使用其它语言中的类继承一样，让我们一目了然。</p><p>我们来举个例子，你一看就明白了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class parent &#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.a &#x3D; &#39;hello&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class child extends parent &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.b &#x3D; &#39;world&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var c &#x3D; new child();</span><br><span class="line"></span><br><span class="line">console.log(c.a + &quot; &quot; + c.b);</span><br></pre></td></tr></table></figure><p>上面的代码定义了两个类，一个父类<code>parent</code>;一个子类<code>child</code>。当我们创建 <code>child</code> 对象 <code>c</code>时，首先会触发 child的构造函数。在child构造函数中，它首先调用 <code>super()</code>方法，而该方法会调用<code>parent</code> 类的构造函数，从而将parent类中的<code>a</code>属性进行初始化。之后又回到child构造函数中对<code>b</code>属性进行初始化，至此所有的初始化工作完成，最终<code>c</code>对象被创建出来。</p><p>当c对象创建好后，我们就可以直接访问它里边的 <code>a</code> 和 <code>b</code> 属性了，以上就是ES6中类继承的过程。其过程与其它面向对象语言完成一致，所以大家在使用它时会觉得非常自然。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上我对JS中 ES5 和 ES6 标准中的<code>类</code>做的一些浅显的探究，在ES5 中类是通过<code>function</code>创建了，由于JS最开始并不支持面向对象开发，所以在ES5中使用JS实现面向对象开发的方式让人觉得很<code>诡异</code>。我在理解这部分知识时，也颇费了一翻周折。不过如果你对内存管理比较熟悉的话，从内存管理的角度去理解 ES5 中的类与继承就比较容易了。</p><p>对于 ES6 来说，类的定义与类的继承几乎完全照搬了 Java 的语法，所以我们在学习和使用它时就非常方便了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="noopener">阮一峰</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/js/javascript.png&quot; alt=&quot;javascript&quot;&gt;&lt;/p&gt;
&lt;p&gt;随着浏览器的发展，JS（JavaScript) 越来越受到人们的欢迎。它不再像以前只能做单一的渲染页面这样的事情了，在Chrome等现代浏览器上，你甚至可以用JS来做音视频的处理，是不是觉得很神奇？&lt;/p&gt;
&lt;p&gt;不过今天我要讨论的并不是如何使用JS来做一些&lt;strong&gt;神奇&lt;/strong&gt;的事儿，而是来重新认识一下JS中&lt;strong&gt;类&lt;/strong&gt;的使用。对于这部分知识的理解，将为我们后面阅读Janus(一款WebRTC流媒体服务器)代码有着至关重要的作用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://blog.avdancedu.com/categories/JavaScript/"/>
    
    
      <category term="js" scheme="https://blog.avdancedu.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>hexo中如何画图</title>
    <link href="https://blog.avdancedu.com/f3ccc53/"/>
    <id>https://blog.avdancedu.com/f3ccc53/</id>
    <published>2020-06-09T14:44:43.000Z</published>
    <updated>2020-06-29T05:29:43.932Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/markdown_flow/markdown.jpg" alt="Markdown时序图"></p><p>有很多同学觉得用Markdown画图是一个很鸡肋的事儿，一是Markdown画不了太复杂的图，如果图太复杂了估计能把自己绕晕；二是Markdown画不了特别漂亮的图，比如你想通过颜色来区分一些元素的作用Markdown就无能为力了。</p><p>我以前也是持有这种态度，所以一直很反对使用Markdown画图。但最近我的思想有所改变，我认为Markdown画图还是有它的优势的。</p><a id="more"></a><p>Markdown绘图有两方面优势，一是通过Markdown画的图不占带宽，这个优势对我来说特别有吸引力。因为我的主机本来带宽就不足，要是在一篇文章中图片太多的话页面加载的速度就太慢了。</p><p>二是Markdown的绘图功能还在不断发展中，没准那天就可以做到手工在页面里直接编辑的程度了，我相信这一天不会太迟到来。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>下面这两幅图就是用Markdown语法绘制的，第一个是流程图，第二个是时序图。看着是不是觉得也还蛮不错的呢？</p><ul><li><p>流程图</p><center><div id="flowchart-0" class="flow-chart"></div></center></li><li><p>时序图</p></li></ul><center><div id="sequence-0"></div></center><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>当然，目前要想实现Markdown绘图还需要安装插件，对于每种不同类型图要安装不同的插件。绘制流程图要安装<code>hexo-filter-flowchart</code>; 绘制时序图要安装<code>hexo-filter-sequence</code>。</p><p>安装的方法以及Markdown的语法我以后再来补充</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在Markdown上绘制图型还是有它的优势的，尤其对于自建博客的同学会更愿意偿试这种方式绘制图型。</p><script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.27/webfontloader.js"></script><script src="https://cdn.bootcss.com/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">Alice->Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob-->Alice: I am good thanks!</textarea><textarea id="sequence-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12,"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script><script src="https://cdn.bootcss.com/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: Start|past:>https://www.google.com[blank]e=>end: End:>https://www.google.comop1=>operation: My Operation|pastop2=>operation: Stuff|currentsub1=>subroutine: My Subroutine|invalidcond=>condition: Yesor No?|approved:>https://www.google.comc2=>condition: Good idea|rejectedio=>inputoutput: catch something...|requestst->op1(right)->condcond(yes, right)->c2cond(no)->sub1(left)->op1c2(yes)->io->ec2(no)->op2->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12,"theme":"simple"}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/markdown_flow/markdown.jpg&quot; alt=&quot;Markdown时序图&quot;&gt;&lt;/p&gt;
&lt;p&gt;有很多同学觉得用Markdown画图是一个很鸡肋的事儿，一是Markdown画不了太复杂的图，如果图太复杂了估计能把自己绕晕；二是Markdown画不了特别漂亮的图，比如你想通过颜色来区分一些元素的作用Markdown就无能为力了。&lt;/p&gt;
&lt;p&gt;我以前也是持有这种态度，所以一直很反对使用Markdown画图。但最近我的思想有所改变，我认为Markdown画图还是有它的优势的。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="时序图" scheme="https://blog.avdancedu.com/tags/%E6%97%B6%E5%BA%8F%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>git常用命令及一些特殊用法</title>
    <link href="https://blog.avdancedu.com/423abe9e/"/>
    <id>https://blog.avdancedu.com/423abe9e/</id>
    <published>2020-06-05T05:44:03.000Z</published>
    <updated>2020-06-09T00:28:13.400Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/git/git-banner.jpg" alt=""><br>本文主要记录一些工作中常用的 git 命令，以及一些比较特殊的git用法，希望这些命令对您也能有所帮助。</p><a id="more"></a><h2 id="git-的基本工作原理"><a href="#git-的基本工作原理" class="headerlink" title="git 的基本工作原理"></a>git 的基本工作原理</h2><p>其实要想使用好git，你必须要知道一点git的工作原理，否则你在使用git时就只能死记硬背一些命令。如果你还处理死记硬背一些git命令的阶段，那么一旦你遇到一个非常复杂的或非手棘手的git case时，可以100%肯定你是无法解决的。</p><p>因此，了解一点git的基本工作原理是我们每个开发人员都必须的基础知识，下面我就对git的的基本工作原理做一下简要介绍。</p><h3 id="git的结构"><a href="#git的结构" class="headerlink" title="git的结构"></a>git的结构</h3><p>首先我们必须要清楚是，git是由三大部分组成的，即本地工作区，本地仓库以及远程仓库。</p><ul><li>本地工作区，就是你平常写代码或修改代码的地方。</li><li>本地仓库，就是我们工作区中.git目录。它里边有一堆子目录，这些子目录都有各自的用途，我们暂且不管。</li><li>远程仓库，这个比较好理解了，就是远端的git仓库，比如我们在github上创建的仓库。</li></ul><p>通过下面这张图我们可以更直观的了解这三大部分：<br><img data-src="https://cdn.avdancedu.com/image/article/git/git_base.jpg" alt="git结构图"></p><p>从图中我们可以清楚的知道，平时我们使用git的三个主要命令(git add、git commit、git push)具体都做了些什么:</p><ul><li>git add: 将本地工作区中代码的修改保存到本地仓库的staged区，即暂存区。</li><li>git commit: 将staged区中的内容保存到本地仓库。</li><li>git push: 将本地仓库中的内容推送给远程仓库保存。</li></ul><p>通过上面这张图我们可以得出以下几点重要结论。</p><p>第一，git在处理我们的提交时是按顺序、分阶段的。比如我们的一个提交，必须先到 staged 后才能进入本地仓库，这个处理顺序是不能乱的。</p><p>第二，git管理中有一个 HEAD 指针，它始终指向正在处理的git commit。而它的前一次git commit 可以用<code>HEAD^</code>表式，它的上上次commit可以用<code>HEAD ^^</code>表式。</p><p>第三，当我们想用地本仓库的内容更新本地工作区的内容时，如果 staged 中没有内容，则可以直接用本地仓库的内容更新本地工作区内容。但如果 staged 中有内容，则需要先更新staged ，然后再更新本地工作区。</p><p>第四，git的核心是本地仓库，所有的操作都是围绕着它来的。它既是用户<code>commit</code>的终点，又是远程仓库的接收<code>commit</code>起点。我们在使用git时，可以向本地仓库提交多次修改，而只向远程仓库推送一次，git推送时会将之前的多个<code>commit</code>合并到一起。</p><h3 id="git的分支管理"><a href="#git的分支管理" class="headerlink" title="git的分支管理"></a>git的分支管理</h3><p>在git中还有一个特别重要的概念就是branch，即分支。它是我们多人合作开发的基础。如下图所示：<br><img data-src="https://cdn.avdancedu.com/image/article/git/git_branch.jpg" alt="git 分支"></p><p>通过上图我们可以清楚的知道，git是以<strong>指针</strong>的方式对分支进行管理的。下面我们来详述一下git是如何管理分支的。</p><p>当我们执行<code>git init</code>时，git默认为我们创建一个分支，即<code>Master</code>分支。而HEAD指针也被初始化指向Master分支，因此每当你提交新的修改时，这些修改都会被压入到Master分支<strong>栈</strong>上。</p><p>当然一般情况下我们都不会轻易对Master分支做操作，而是创建一个<code>Dev</code>分支作为我们的开发分支。在git中你可以执行<code>git branch branchname</code>命令来创建一个新分支，比如将branchname设置为<code>Dev</code>，这样我们就创建出了<code>Dev</code>分支。</p><p>然后你可以执行<code>git checkout Dev</code> 命令，它的作用是让<code>HEAD</code>指向Dev分支。后面你所有的commit就都被<strong>push</strong>到Dev分支上了。</p><p>如果你觉得执行两条命令比较麻烦，你也可以将上面的两步合并为一步，执行<code>git checkout -b branchname</code>这一条命令就可以了，这也是我们平常真正使用的命令。</p><p>通过上面的描述，我想你应该对git的工作原理有了最基本的了解了，下面我们再来看这些命令时就很容易理解它们的作用以及为什么要这么做了。</p><h2 id="已有代码该如何提效到仓库中"><a href="#已有代码该如何提效到仓库中" class="headerlink" title="已有代码该如何提效到仓库中"></a>已有代码该如何提效到仓库中</h2><p>第一步，在github 上创建一个仓库。<br>第二步，执行下面的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:avdance&#x2F;test.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h2 id="本地与远程有突冲，想放弃本地修改"><a href="#本地与远程有突冲，想放弃本地修改" class="headerlink" title="本地与远程有突冲，想放弃本地修改"></a>本地与远程有突冲，想放弃本地修改</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard FETCH_HEAD</span><br></pre></td></tr></table></figure><h2 id="重新从远端拉取某个文件"><a href="#重新从远端拉取某个文件" class="headerlink" title="重新从远端拉取某个文件"></a>重新从远端拉取某个文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- a.c</span><br></pre></td></tr></table></figure><h2 id="撤消某次-add"><a href="#撤消某次-add" class="headerlink" title="撤消某次 add"></a>撤消某次 add</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached &lt;added_file_to_undo&gt;</span><br></pre></td></tr></table></figure><h2 id="撤消某次-commit"><a href="#撤消某次-commit" class="headerlink" title="撤消某次 commit"></a>撤消某次 commit</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft commitID  只是删除了commitId之后的commit记录,但是代码改动仍然存在</span><br><span class="line">git reset --hard commitID  彻底的回到CommitID时候的版本,之后的改动不存在了</span><br></pre></td></tr></table></figure><h2 id="将本地修改先暂存起来"><a href="#将本地修改先暂存起来" class="headerlink" title="将本地修改先暂存起来"></a>将本地修改先暂存起来</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git stash 将本地修改暂存起来</span><br><span class="line">git stash pop 弹出暂存的修改</span><br></pre></td></tr></table></figure><h2 id="查看有冲突的文件"><a href="#查看有冲突的文件" class="headerlink" title="查看有冲突的文件"></a>查看有冲突的文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status -uno</span><br></pre></td></tr></table></figure><h2 id="不显示临时文件"><a href="#不显示临时文件" class="headerlink" title="不显示临时文件"></a>不显示临时文件</h2><p>在 .gitignore 中添加不想被 git staus 看到的文件或目录</p><h2 id="暂时回滚到某版本"><a href="#暂时回滚到某版本" class="headerlink" title="暂时回滚到某版本"></a>暂时回滚到某版本</h2><p>首先通过 git log查看你之前的提交码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log | more</span><br></pre></td></tr></table></figure><blockquote><p>commit 4adb3f0ecd9dbc79bd09666d88f8c2520305c001<br>Author: xxxxxx<br>Date:   Thu Jan 25 11:51:45 2018 +0800</p></blockquote><p>摘取 commit 码的前 7位，执行下面的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout 4adb3f0</span><br><span class="line">git reset --hard 4adb3f0</span><br></pre></td></tr></table></figure><h2 id="切换-回滚到主分支"><a href="#切换-回滚到主分支" class="headerlink" title="切换/回滚到主分支"></a>切换/回滚到主分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><h2 id="服务端有更新，但你却-commit了你的代码"><a href="#服务端有更新，但你却-commit了你的代码" class="headerlink" title="服务端有更新，但你却 commit了你的代码"></a>服务端有更新，但你却 commit了你的代码</h2><ul><li><p>先拉取服务端代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure></li><li><p>提交代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure></li><li><p>如果你在 dev分支，此时还要拉取master的代码<br><strong>1. 先 切换到 master 分支</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p><strong>2. 拉取代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p><strong>3. 重新切换到 dev 分支</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev</span><br></pre></td></tr></table></figure></li></ul><h2 id="查看每次提交的文件列表"><a href="#查看每次提交的文件列表" class="headerlink" title="查看每次提交的文件列表"></a>查看每次提交的文件列表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --stat | more</span><br></pre></td></tr></table></figure><h2 id="查看某些提交代码的变化"><a href="#查看某些提交代码的变化" class="headerlink" title="查看某些提交代码的变化"></a>查看某些提交代码的变化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show &lt;commit id&gt; [&lt;filename&gt;]</span><br></pre></td></tr></table></figure><h2 id="显示所有本地与远端分支"><a href="#显示所有本地与远端分支" class="headerlink" title="显示所有本地与远端分支"></a>显示所有本地与远端分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><h2 id="显示所有远程分支"><a href="#显示所有远程分支" class="headerlink" title="显示所有远程分支"></a>显示所有远程分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure><h2 id="显示远端地址"><a href="#显示远端地址" class="headerlink" title="显示远端地址"></a>显示远端地址</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><h2 id="创建一个新分支"><a href="#创建一个新分支" class="headerlink" title="创建一个新分支"></a>创建一个新分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b new_branch</span><br><span class="line">git --set-upstream origin new_branch</span><br><span class="line">git push origin new_branch</span><br></pre></td></tr></table></figure><h2 id="远程仓库已经删除，而本地仓库还在，如果清除？"><a href="#远程仓库已经删除，而本地仓库还在，如果清除？" class="headerlink" title="远程仓库已经删除，而本地仓库还在，如果清除？"></a>远程仓库已经删除，而本地仓库还在，如果清除？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull -p</span><br></pre></td></tr></table></figure><h2 id="git-diff-不显示修改的内容"><a href="#git-diff-不显示修改的内容" class="headerlink" title="git diff 不显示修改的内容"></a>git diff 不显示修改的内容</h2><p>有些情况下，通过 <code>git status</code> 能查到某些文件有变化，但使用 <code>git diff</code> 却看不到修改的内容。可以使用下面的面试查看变化。</p><ul><li>第一种方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached 文件名</span><br></pre></td></tr></table></figure></li><li>或者<br>先将修改的文件重命名，然后执行下面的语句<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD</span><br></pre></td></tr></table></figure></li></ul><h2 id="配置更好的-git-diff-工具"><a href="#配置更好的-git-diff-工具" class="headerlink" title="配置更好的 git diff 工具"></a>配置更好的 git diff 工具</h2><p>在使用 git diff 时，常常发现有很多不方便的地方。因为git diff 默认使用 patch 方式展示代码的不同。如果想看修改后代码的上下文就比较麻烦了（比如代码 review）。</p><p>其实 git 已经提供了扩展功能。可经将它的默认 diff 工具修改为vimdiff。配置如下：</p><ul><li>首先打开 git config 文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~&#x2F;.gitconfig</span><br></pre></td></tr></table></figure></li><li>增加配置项<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[difftool]</span><br><span class="line">    prompt &#x3D; false</span><br><span class="line">[diff]</span><br><span class="line">    vimdiff</span><br><span class="line">    tool &#x3D; vimdiff</span><br><span class="line">[difftool &quot;vimdiff&quot;]</span><br><span class="line">    path &#x3D; &#x2F;usr&#x2F;bin&#x2F;vimdiff</span><br></pre></td></tr></table></figure></li></ul><h2 id="打tag"><a href="#打tag" class="headerlink" title="打tag"></a>打tag</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;为git打tag, 第一次需要在前面加一个v</span><br><span class="line">git tag &quot;v1.0.0&quot;</span><br><span class="line">&#x2F;&#x2F;将tag推送到远程仓库</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure><h2 id="git-merge-每次都生成一次commit"><a href="#git-merge-每次都生成一次commit" class="headerlink" title="git merge 每次都生成一次commit"></a>git merge 每次都生成一次commit</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff</span><br></pre></td></tr></table></figure><blockquote><p>注：ff表示 fast forward</p></blockquote><h2 id="切到某个tag"><a href="#切到某个tag" class="headerlink" title="切到某个tag"></a>切到某个tag</h2><p>与切到某个分支是类似的，只不过将branch 名换为 tag 名而以。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout tag_name</span><br></pre></td></tr></table></figure><h2 id="查看某个人的所有提交"><a href="#查看某个人的所有提交" class="headerlink" title="查看某个人的所有提交"></a>查看某个人的所有提交</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --author&#x3D;“author”</span><br></pre></td></tr></table></figure><h2 id="为git设置默认用户名和密码"><a href="#为git设置默认用户名和密码" class="headerlink" title="为git设置默认用户名和密码"></a>为git设置默认用户名和密码</h2><p>在使用Git 的时候，经常会遇到需要频繁输入密码的情况，每次git push 和 git pull 都要求输入用户名和密码，如果提交频繁的话就十分不方便。</p><p>可以使用下面的方法，只需要第一次输入用户名和密码，以后都不用再输入了。</p><h3 id="进入Git-配置文件"><a href="#进入Git-配置文件" class="headerlink" title="进入Git 配置文件"></a>进入Git 配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~&#x2F;.gitconfig</span><br></pre></td></tr></table></figure><h3 id="修改配置文件，添加下面这一行。"><a href="#修改配置文件，添加下面这一行。" class="headerlink" title="修改配置文件，添加下面这一行。"></a>修改配置文件，添加下面这一行。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[credential]  </span><br><span class="line">    helper &#x3D; store</span><br></pre></td></tr></table></figure><p>##修改已提交的commit的用户名邮箱</p><ol><li><p>第一步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;newName&quot;</span><br><span class="line">git config --global user.email &quot;newEmail&quot;</span><br></pre></td></tr></table></figure></li><li><p>修改已提交commit的用户名邮箱</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend --author&#x3D;&quot;userName &lt;userEmail&gt;&quot;</span><br></pre></td></tr></table></figure></li></ol><p><strong>注意不能缺少<code>&lt; &gt;</code></strong><br><strong>此指令仅能更新最近的一次commit的用户名邮箱</strong></p><h2 id="git-应用-patch"><a href="#git-应用-patch" class="headerlink" title="git 应用 patch"></a>git 应用 patch</h2><ol><li>预览patch的结是</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git apply --stat file.patch</span><br></pre></td></tr></table></figure><ol start="2"><li>检测patch后是否有错误</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git apply --check file.patch</span><br></pre></td></tr></table></figure><ol start="3"><li>打patch</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git am --signoff &lt; a_file.patch</span><br></pre></td></tr></table></figure><ol start="4"><li>执行commit</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  commit -m &quot;&quot;</span><br></pre></td></tr></table></figure><ol start="5"><li>提交代码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><h2 id="循环克隆"><a href="#循环克隆" class="headerlink" title="循环克隆"></a>循环克隆</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --recursive https:&#x2F;&#x2F;xxx.git</span><br></pre></td></tr></table></figure><h2 id="给代码设置两个不同的源"><a href="#给代码设置两个不同的源" class="headerlink" title="给代码设置两个不同的源"></a>给代码设置两个不同的源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin https:&#x2F;&#x2F;xxx.git</span><br></pre></td></tr></table></figure><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>命令在不断更新中…</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">廖雪峰git教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/git/git-banner.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;本文主要记录一些工作中常用的 git 命令，以及一些比较特殊的git用法，希望这些命令对您也能有所帮助。&lt;/p&gt;
    
    </summary>
    
    
      <category term="git" scheme="https://blog.avdancedu.com/categories/git/"/>
    
    
      <category term="git" scheme="https://blog.avdancedu.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>ffmpeg精讲常见问题</title>
    <link href="https://blog.avdancedu.com/f3f66133/"/>
    <id>https://blog.avdancedu.com/f3f66133/</id>
    <published>2020-05-30T16:27:10.000Z</published>
    <updated>2020-06-04T12:23:37.890Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问：编译-ffmpeg-方法"><a href="#问：编译-ffmpeg-方法" class="headerlink" title="问：编译 ffmpeg 方法"></a>问：编译 ffmpeg 方法</h2><p>答：在各个平台编译方法基本都是一样的。</p><ul><li>首先下载 ffmpeg 源码，地址为: <a href="https://www.ffmpeg.org/download.html" target="_blank" rel="noopener">https://www.ffmpeg.org/download.html</a></li><li>进入到下载后的<a href="https://coding.imooc.com/class/279.html?mc_marking=59c321c0417e144904c49c366f94dd57&mc_channel=shouji" target="_blank" rel="noopener">ffmpeg目</a>录下，执行下面的指令：<a id="more"></a><ul><li>Mac 平台：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;ffmpeg</span><br><span class="line">                  --enable-gpl</span><br><span class="line">                  --enable-nonfree</span><br><span class="line">                  --enable-libfdk-aac</span><br><span class="line">                  --enable-libx264</span><br><span class="line">                  --enable-libx265</span><br><span class="line">                  --enable-filter&#x3D;delogo</span><br><span class="line">                  --enable-debug</span><br><span class="line">                  --disable-optimizations</span><br><span class="line">                  --enable-libspeex</span><br><span class="line">                  --enable-videotoolbox</span><br><span class="line">                  --enable-shared</span><br><span class="line">                  --enable-pthreads</span><br><span class="line">                  --enable-version3</span><br><span class="line">                  --enable-hardcoded-tables</span><br><span class="line">                  --cc&#x3D;clang</span><br><span class="line">                  --host-cflags&#x3D;</span><br><span class="line">                  --host-ldflags&#x3D;</span><br></pre></td></tr></table></figure></li><li>Linux平台<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;ffmpeg</span><br><span class="line">                  --enable-gpl</span><br><span class="line">                  --enable-nonfree</span><br><span class="line">                  --enable-libfdk-aac</span><br><span class="line">                  --enable-libx264</span><br><span class="line">                  --enable-libx265</span><br><span class="line">                  --enable-filter&#x3D;delogo</span><br><span class="line">                  --enable-debug</span><br><span class="line">                  --disable-optimizations</span><br><span class="line">                  --enable-libspeex</span><br><span class="line">                  --enable-shared</span><br><span class="line">                  --enable-pthreads</span><br></pre></td></tr></table></figure></li><li>Windows平台<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;ffmpeg</span><br><span class="line">                  --enable-gpl</span><br><span class="line">                  --enable-nonfree</span><br><span class="line">                  --enable-libfdk-aac</span><br><span class="line">                  --enable-libx264</span><br><span class="line">                  --enable-libx265</span><br><span class="line">                  --enable-filter&#x3D;delogo</span><br><span class="line">                  --enable-debug</span><br><span class="line">                  --disable-optimizations</span><br><span class="line">                  --enable-libspeex</span><br><span class="line">                  --enable-static</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="问：make-amp-amp-make-install失败"><a href="#问：make-amp-amp-make-install失败" class="headerlink" title="问：make &amp;&amp; make install失败"></a>问：make &amp;&amp; make install失败</h2><p>答：make &amp;&amp; make install 之所以会失败，则由于该用户没有操作目录的权限引起的。所以只需要在make install 之前加 sudo即可。</p><p>另一种方法是将用户切换成 root用户，因 root用户的权力最大，所以这样做也是没问题的。但建议还是用 非 root用户操作，这样更安全。</p><h2 id="问：库已经安装好了，但仍报找不到它的错误？"><a href="#问：库已经安装好了，但仍报找不到它的错误？" class="headerlink" title="问：库已经安装好了，但仍报找不到它的错误？"></a>问：库已经安装好了，但仍报找不到它的错误？</h2><p>答：首先确认是否已经将 <code>pkg-config</code>工具安装好了。可以执行下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config</span><br></pre></td></tr></table></figure><p>如果提示没有安装，则先将该工具安装好，安装命令如下：</p><ul><li>ubuntu  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt intall pkg-config</span><br></pre></td></tr></table></figure></li><li>mac  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install pkg-config</span><br></pre></td></tr></table></figure></li><li>cygwin  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cyg install pkg-config</span><br></pre></td></tr></table></figure></li><li>centos  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install pkg-config</span><br></pre></td></tr></table></figure>安装完该工具后仍然报错？那再按照具体的错误看下面的解决方案吧。</li></ul><h2 id="问：libx264库找不到（-ERROR-libx264-not-found-）"><a href="#问：libx264库找不到（-ERROR-libx264-not-found-）" class="headerlink" title="问：libx264库找不到（[ERROR: libx264 not found]）"></a>问：libx264库找不到（[ERROR: libx264 not found]）</h2><p>该问题可能由下面三个方面的问题引起。</p><ul><li>libx264库没有安装。对于这种情况有两种解决办法:<ul><li>其一，是通过平台的安装工作进行安装，如 apt/brew/yum install x264。（注：在Linux下应该安装 libx264-dev）。</li><li>其二，是通过源码安装，步骤如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. wget https:&#x2F;&#x2F;code.videolan.org&#x2F;videolan&#x2F;x264&#x2F;-&#x2F;archive&#x2F;master&#x2F;x264-master.tar.bz2</span><br><span class="line">2. bunzip2 x264-master.tar.bz2</span><br><span class="line">3. tar -vxf x264-master.tar.tar</span><br><span class="line">4. .&#x2F;configure --enable-static --enable-shared --disable-asm --disable-avs</span><br><span class="line">5. make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure></li></ul></li><li>通过 pkg-config 命令无法找到。对于这类问题，我们可以使用下面的命 <code>pkg-config --cflags --lib libx264</code>看是否可以找到 libx264，如果找不到，就说明确实是这个问题。解决的办法是设置环境变量。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PKG_CONFIG_PATH&#x3D;$PKG_CONFIG_PATH:&#x2F;xxx&#x2F;xxx&#x2F;lib&#x2F;pkgconfig</span><br></pre></td></tr></table></figure>其中 <code>xxx</code> 由你的实际路径代替。</li></ul><blockquote><p>注，有可能你的系统中并没有装 pkg-config工具，可以使用 brew/apt/yum install pkg-config进行安装。</p></blockquote><ul><li>无法链接上libx264, 这是由于通过环境变量 LD_LIBRARY_PATH 无法定位到 libx264库。解决的办法也很简单，与上面类似，可以通过设置环境变量来解决该问题。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH&#x3D;$LIB_LIBRARY_PATH:&#x2F;xxx&#x2F;xxx&#x2F;lib</span><br></pre></td></tr></table></figure>其中，<code>xxx</code>由你的实际路径代替。</li></ul><p>当然，你也可以将环境变量设置在脚本里，这样就不用每次都写export命令了。只需要将上面的两条语句加入到 <del>/.bashrc / 或</del>/.bash_profil 文件里，然后在控制台执行 <code>source ~/.bashrc</code> 或 <code>source ~/.bash_profile</code>即可。</p><h2 id="问：fdk-aac库找不到（-ERROR-libfdk-aac-not-found-）"><a href="#问：fdk-aac库找不到（-ERROR-libfdk-aac-not-found-）" class="headerlink" title="问：fdk-aac库找不到（[ERROR: libfdk_aac not found]）"></a>问：fdk-aac库找不到（[ERROR: libfdk_aac not found]）</h2><p>答：该问题与上面的 libx264 问题类似，所以只需要将上面的 libx264替换为libfdk-aac即可。这里不在赘述。</p><h2 id="问：speex库找不到（-ERROR-speex-not-found-）"><a href="#问：speex库找不到（-ERROR-speex-not-found-）" class="headerlink" title="问：speex库找不到（[ERROR: speex not found]）"></a>问：speex库找不到（[ERROR: speex not found]）</h2><p>答：该问题与上面的 libx264 问题类似，所以只需要将上面的 libx264替换为speex即可。这里不在赘述。</p><h2 id="问：编译不出ffplay"><a href="#问：编译不出ffplay" class="headerlink" title="问：编译不出ffplay"></a>问：编译不出ffplay</h2><p>答：引起该问题有以下几方面的原因：</p><ul><li>所使用的操作系统没有安装图形库。如有的同学在阿里的云服务器上想安装ffplay是肯定不行的。</li><li>没有安装 SDL2 库。解决办法是通过 brew/apt/yum install sdl2 即可 或 通过 SDL2 源码安装。<strong>安装完成后，要重新进行到 ffmpeg目录下，执行 ./configure…这指命令。</strong></li><li>有的同学编译ffmpeg时，在ffmpeg目录执行./configure … 之后，没有修改config.h文件，这样也编译不出ffplay来。解决办法是进入到 ffmpeg 目录下，打开 config.h文件找 FFPLAY 关键字，将其后面的 0 修改为 1，保存并退出该文件。在当前目录下执行 make &amp;&amp; sudo  make install。<strong>注意，修改 config.h文件后，不要再执行./configure …了，否则config.h中的值又都恢复为原来的值了。</strong></li><li>SDL2与最新的Mac系统 mojave不兼容。解决办法：<ul><li>方法一<ul><li>从 <a href="https://www.libsdl.org/tmp/release/SDL2-2.0.9.tar.gz" target="_blank" rel="noopener">SDL</a>下载 2.0.9版本或以后的SDL2代码。</li><li>执行 ./configure</li><li>执行 make &amp;&amp; sudo make install</li><li>执行 export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig</li><li>[重新]编译ffmpeg</li></ul></li><li>方法二<ul><li>从<a href="https://www.libsdl.org/tmp/release/SDL2-2.0.9.dmg" target="_blank" rel="noopener">SDL</a>下载dmg包。</li><li>执行 open SDL2-2.0.9.dmg</li><li>[重新]编译ffmpeg</li></ul></li></ul></li></ul><h2 id="SDL在windows的-cygwin下无法打印日志"><a href="#SDL在windows的-cygwin下无法打印日志" class="headerlink" title="SDL在windows的 cygwin下无法打印日志"></a>SDL在windows的 cygwin下无法打印日志</h2><p>在编译 SDL 时，将configure 中的 <code>-mwindows</code> 参数去掉。</p><h2 id="问：如何在Windows下编译ffmpeg问题"><a href="#问：如何在Windows下编译ffmpeg问题" class="headerlink" title="问：如何在Windows下编译ffmpeg问题"></a>问：如何在Windows下编译ffmpeg问题</h2><p>答：参见 <a href="https://www.imooc.com/article/247113" target="_blank" rel="noopener">Windows下编译ffmpeg问题</a></p><h2 id="问：在Windows下编译安装ffmpeg是不是特别麻烦？"><a href="#问：在Windows下编译安装ffmpeg是不是特别麻烦？" class="headerlink" title="问：在Windows下编译安装ffmpeg是不是特别麻烦？"></a>问：在Windows下编译安装ffmpeg是不是特别麻烦？</h2><p>答：确实是这样。所以建议在Window开发者最好装一个 Ubuntu的虚拟机，这样就方便很多了。如果条件允许的话，最好能用Mac开发。可以说Mac Pro是关专为开发者制造的，一旦你用上它会让你爱不释手。</p><h2 id="问：编译时，各种库找不到问题"><a href="#问：编译时，各种库找不到问题" class="headerlink" title="问：编译时，各种库找不到问题"></a>问：编译时，各种库找不到问题</h2><p>答：该问题与上面的 libx264类似，我们可以通过 <code>brew/apt/yum install xxx</code> 命令进行安装，一般情况下这种方式都可以满足我们的需求。如果始终不行的话，就需要源码安装了。源码安装的方法可以参见 <a href="https://www.imooc.com/article/247113" target="_blank" rel="noopener">Windows下编译ffmpeg问题</a> 里的说明。</p><h2 id="问：ffmpeg如何使用-libx265"><a href="#问：ffmpeg如何使用-libx265" class="headerlink" title="问：ffmpeg如何使用 libx265"></a>问：ffmpeg如何使用 libx265</h2><p>答：准确的讲ffmpeg应该是一个音视频框架，所有的音视频编解码器都是以插件的方式与ffmpeg联系起来的。换句话说，ffmpeg在上层提供了统一的 API，无法你使用的编解决是 x264, open264, x265, vp8/vp9/av1 上层用户都不管心，它仍然使用同样的 API， 只是在find_decoder 或 find_encoder时，指定具体的编解码器就可以了。也就是说在find_xxx时，你要设置了 x264 它最终就会调用 x264进行编解码，设置了 x265它就使用 x265进行编解码。如些而已。</p><h2 id="问：这门课有群吗？"><a href="#问：这门课有群吗？" class="headerlink" title="问：这门课有群吗？"></a>问：这门课有群吗？</h2><p>答：有的，群号：883069602，不过<a href="https://coding.imooc.com/class/279.html?mc_marking=59c321c0417e144904c49c366f94dd57&mc_channel=shouji" target="_blank" rel="noopener">需要购买课程</a>后输入验证码才可以进群。大家可以在群里讨论问题，也可以在课程的评论区里搜索答案。目前评论区里已经积累了大量问题的解决方案。</p><h2 id="问：为什么我使用课程中的程序无法成功抽取AAC音频？"><a href="#问：为什么我使用课程中的程序无法成功抽取AAC音频？" class="headerlink" title="问：为什么我使用课程中的程序无法成功抽取AAC音频？"></a>问：为什么我使用课程中的程序无法成功抽取AAC音频？</h2><p>答：<a href="https://www.imooc.com/article/254733" target="_blank" rel="noopener">详细回答在这里</a></p><h2 id="问：Android播放器例子为什么调API失败"><a href="#问：Android播放器例子为什么调API失败" class="headerlink" title="问：Android播放器例子为什么调API失败"></a>问：Android播放器例子为什么调API失败</h2><p>答：你目前使用的 NDK 版本与我编译时使用的 NDK 版本不一致造成的，换成 NDK10e试试。</p><h2 id="问：NDK10e-从哪里下载"><a href="#问：NDK10e-从哪里下载" class="headerlink" title="问：NDK10e 从哪里下载"></a>问：NDK10e 从哪里下载</h2><p>答：可以到<a href="https://developer.android.com/ndk/downloads/older_releases" target="_blank" rel="noopener">这里</a>下载。</p><ul><li><a href="https://dl.google.com/android/repository/android-ndk-r10e-darwin-x86_64.zip" target="_blank" rel="noopener">mac NDK10e</a></li><li><a href="https://dl.google.com/android/repository/android-ndk-r10e-windows-x86.zip" target="_blank" rel="noopener">windows 32 位 NDK10e</a></li><li><a href="https://dl.google.com/android/repository/android-ndk-r10e-windows-x86_64.zip" target="_blank" rel="noopener">windows 64位 NDK10e</a></li><li><a href="https://dl.google.com/android/repository/android-ndk-r10e-linux-x86_64.zip" target="_blank" rel="noopener">linux NDK10e</a></li></ul><h2 id="问：NDKr21-从哪里下载"><a href="#问：NDKr21-从哪里下载" class="headerlink" title="问：NDKr21 从哪里下载"></a>问：NDKr21 从哪里下载</h2><p>答：可以到这里下载。</p><ul><li><a href="https://dl.google.com/android/repository/android-ndk-r21-darwin-x86_64.zip" target="_blank" rel="noopener">mac NDKr21</a></li><li><a href="https://dl.google.com/android/repository/android-ndk-r21-windows-x86_64.zip" target="_blank" rel="noopener">windows NDKr21</a></li><li><a href="https://dl.google.com/android/repository/android-ndk-r21-linux-x86_64.zip" target="_blank" rel="noopener">linux NDKr21</a></li></ul><h2 id="问：ffmpeg安装好后，编译视频中的ffmpeg-log不成功"><a href="#问：ffmpeg安装好后，编译视频中的ffmpeg-log不成功" class="headerlink" title="问：ffmpeg安装好后，编译视频中的ffmpeg_log不成功"></a>问：ffmpeg安装好后，编译视频中的ffmpeg_log不成功</h2><p>答：执行下面的命令进行编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g -o ffmpeg_log ffmpeg_log.c &#96;pkg-config --libs --cflags libavutil&#96;</span><br></pre></td></tr></table></figure><p><strong>注意：pkg-confg 前面的符号不是<code>&#39;</code>哟！它是键盘左上角 ESC键下面的键。</strong></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>该文章会不定期更新，我们将一些大家使用<a href="https://coding.imooc.com/class/279.html?mc_marking=59c321c0417e144904c49c366f94dd57&mc_channel=shouji" target="_blank" rel="noopener">ffmpeg</a>常见的问题更新到这里来。</p><h2 id="视频课地址"><a href="#视频课地址" class="headerlink" title="视频课地址"></a>视频课地址</h2><p><a href="https://www.imooc.com/u/4873493/courses?sort=publish" target="_blank" rel="noopener">课程主页地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问：编译-ffmpeg-方法&quot;&gt;&lt;a href=&quot;#问：编译-ffmpeg-方法&quot; class=&quot;headerlink&quot; title=&quot;问：编译 ffmpeg 方法&quot;&gt;&lt;/a&gt;问：编译 ffmpeg 方法&lt;/h2&gt;&lt;p&gt;答：在各个平台编译方法基本都是一样的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先下载 ffmpeg 源码，地址为: &lt;a href=&quot;https://www.ffmpeg.org/download.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.ffmpeg.org/download.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;进入到下载后的&lt;a href=&quot;https://coding.imooc.com/class/279.html?mc_marking=59c321c0417e144904c49c366f94dd57&amp;mc_channel=shouji&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ffmpeg目&lt;/a&gt;录下，执行下面的指令：
    
    </summary>
    
    
      <category term="音视频" scheme="https://blog.avdancedu.com/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="ffmpeg" scheme="https://blog.avdancedu.com/tags/ffmpeg/"/>
    
      <category term="音视频" scheme="https://blog.avdancedu.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="直播" scheme="https://blog.avdancedu.com/tags/%E7%9B%B4%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>音视频系统入门常见问题</title>
    <link href="https://blog.avdancedu.com/631d466a/"/>
    <id>https://blog.avdancedu.com/631d466a/</id>
    <published>2020-05-30T16:19:12.000Z</published>
    <updated>2020-06-08T04:47:36.006Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/av_base/question.jpg" alt=""></p><p>同学们在学习《音视频课小白系统入门》这门课的过程中，经常遇到一些问题，如Mac系统下为什么无法编译ffmpeg? Xcode编译课程中的程序为什么不成功? 为什么我从设备中读的数据很小?等等不足而一。</p><p>实际上，大部分同学提出的问题都是重复的。因此，我将一些最常见的问题整理出了答案放在这里，同学们可以根据自己的情况去查找相应的解决办法，以免我个人原因不能及时回答问题时，给大家的学习造成麻烦和不便。</p><a id="more"></a><h2 id="Q-在-Mac-10-15-3-系统下编译-ffmpeg-成功后，在运行-ffmpeg-命令时出现crash"><a href="#Q-在-Mac-10-15-3-系统下编译-ffmpeg-成功后，在运行-ffmpeg-命令时出现crash" class="headerlink" title="Q: 在 Mac 10.15.3 系统下编译 ffmpeg 成功后，在运行 ffmpeg 命令时出现crash."></a>Q: 在 Mac 10.15.3 系统下编译 ffmpeg 成功后，在运行 ffmpeg 命令时出现crash.</h2><p>A: 重新编译ffmpeg，在执行 ./configure 时增加 –extra-cflags=”fno-static-check” 选项，注意该选项一定要放在前面，否则编译有问题。</p><h2 id="Q-在Mac下添加-–extra-cflags-”fno-static-check”-选项仍然-crash"><a href="#Q-在Mac下添加-–extra-cflags-”fno-static-check”-选项仍然-crash" class="headerlink" title="Q: 在Mac下添加 –extra-cflags=”fno-static-check” 选项仍然 crash"></a>Q: 在Mac下添加 –extra-cflags=”fno-static-check” 选项仍然 crash</h2><p>A: 编译时保持尽量少的参数，应该是与其它一些参数有突冲。</p><h2 id="Q-无论通过何种方式编译出的ffmpeg都会引发crash，如何解决？"><a href="#Q-无论通过何种方式编译出的ffmpeg都会引发crash，如何解决？" class="headerlink" title="Q: 无论通过何种方式编译出的ffmpeg都会引发crash，如何解决？"></a>Q: 无论通过何种方式编译出的ffmpeg都会引发crash，如何解决？</h2><p>A: 那就只能用命令的方式安装ffmpeg了，执行 <code>brew install ffmpeg</code>即可。</p><h2 id="Q-在Mac下，通过命令方式安装的ffmpeg没有带fdk-aac库怎么办"><a href="#Q-在Mac下，通过命令方式安装的ffmpeg没有带fdk-aac库怎么办" class="headerlink" title="Q: 在Mac下，通过命令方式安装的ffmpeg没有带fdk-aac库怎么办?"></a>Q: 在Mac下，通过命令方式安装的ffmpeg没有带fdk-aac库怎么办?</h2><p>A: 以命令方式安装带 fdk-aac 的ffmpeg需要按下面的步骤执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0. brew unstall ffmpeg</span><br><span class="line">1. brew tap homebrew-ffmpeg&#x2F;ffmpeg</span><br><span class="line">2. brew install homebrew-ffmpeg&#x2F;ffmpeg&#x2F;ffmpeg --with-fdk-aac</span><br></pre></td></tr></table></figure><p>注意，安装时如果报<code>ERROR: libsnappy not found</code> 错误，则你需要到<code>https://github.com/google/snappy</code>下载源码，并按照项目的说明编译并安装snappy库。</p><p>安装好snappy库后，重新执行<code>brew install homebrew-ffmpeg/ffmpeg/ffmpeg --with-fdk-aac</code>命令。</p><h2 id="Q-在Mac下通过命令方式安装ffmpeg库时，如何能带上其它第三方库呢？如x264"><a href="#Q-在Mac下通过命令方式安装ffmpeg库时，如何能带上其它第三方库呢？如x264" class="headerlink" title="Q: 在Mac下通过命令方式安装ffmpeg库时，如何能带上其它第三方库呢？如x264"></a>Q: 在Mac下通过命令方式安装ffmpeg库时，如何能带上其它第三方库呢？如x264</h2><p>A: 与上面安装ffmpeg带fdk-aac库的命令是类似的，命令格式为: <code>brew install ffmpeg --with-xxxx</code>，添加某个库的具体参数可以通过<code>homebrew-ffmpeg/ffmpeg/ffmpeg</code> 来查找。</p><h2 id="Q-Xcode-编译课程中的程序成功，但执行失败，报的错误是没有权限该如何解决？"><a href="#Q-Xcode-编译课程中的程序成功，但执行失败，报的错误是没有权限该如何解决？" class="headerlink" title="Q: Xcode 编译课程中的程序成功，但执行失败，报的错误是没有权限该如何解决？"></a>Q: Xcode 编译课程中的程序成功，但执行失败，报的错误是没有权限该如何解决？</h2><p>A:<br><img data-src="https://cdn.avdancedu.com/image/article/av_base/nopriv.jpg" alt=""></p><p>如果是上面这种错误信息，解决办法是: 在编译课程中的例子时，先将将沙盒关闭掉，在info.list中增加访问mic phone 访问权限。具体操作如下图所示:</p><p><img data-src="https://cdn.avdancedu.com/image/article/av_base/info.jpg" alt=""></p><h2 id="Q-info-plist加了权限仍然报没有权限怎么解决？"><a href="#Q-info-plist加了权限仍然报没有权限怎么解决？" class="headerlink" title="Q: info.plist加了权限仍然报没有权限怎么解决？"></a>Q: info.plist加了权限仍然报没有权限怎么解决？</h2><p>A: 按下图操作试试<br><img data-src="https://cdn.avdancedu.com/image/article/av_base/priv2.jpg" alt=""></p><h2 id="Q-引入ffmpeg库后，报libavformat-xxx-dylib-未签名，错误信息类似”code-signature…not-valid”"><a href="#Q-引入ffmpeg库后，报libavformat-xxx-dylib-未签名，错误信息类似”code-signature…not-valid”" class="headerlink" title="Q: 引入ffmpeg库后，报libavformat.xxx.dylib 未签名，错误信息类似”code signature…not valid”"></a>Q: 引入ffmpeg库后，报libavformat.xxx.dylib 未签名，错误信息类似”code signature…not valid”</h2><p>A:<br><img data-src="https://cdn.avdancedu.com/image/article/av_base/unsigned.jpg" alt=""><br>如果像上图所展示的一样，则按下面步骤操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 打开 Mac 中的 keychain Access.app, 选择“我的证书”</span><br><span class="line">2. 执行 codesign -f -s &quot;证书名&quot; xxx.dylib</span><br><span class="line">3. 为了避免逐个签名，可以进行批量操作 codesign -f -s &quot;证书名&quot; &#x2F;usr&#x2F;local&#x2F;ffmpeg&#x2F;lib&#x2F;*.dylib</span><br></pre></td></tr></table></figure><h2 id="Q-ffmpeg-执行时提示没有权限执行ffmpeg"><a href="#Q-ffmpeg-执行时提示没有权限执行ffmpeg" class="headerlink" title="Q: ffmpeg 执行时提示没有权限执行ffmpeg"></a>Q: ffmpeg 执行时提示没有权限执行ffmpeg</h2><p>A: 将目录切换到你自己的用户目录下再执行ffmpeg试试。</p><h2 id="Q-在Linux虚似机中每次获取的音频数据很小，只有64个字节，如果进行重采样？"><a href="#Q-在Linux虚似机中每次获取的音频数据很小，只有64个字节，如果进行重采样？" class="headerlink" title="Q: 在Linux虚似机中每次获取的音频数据很小，只有64个字节，如果进行重采样？"></a>Q: 在Linux虚似机中每次获取的音频数据很小，只有64个字节，如果进行重采样？</h2><p>A: ffmpeg中最低采样个数为32个，所以只有 64 字节数据时，是无进行重采样的。解决办法是将数据放到一个缓冲区中，积攒到一定大小后，再进行重采样。</p><h2 id="Q-在从设备采体音频数据时，返回错误-35"><a href="#Q-在从设备采体音频数据时，返回错误-35" class="headerlink" title="Q: 在从设备采体音频数据时，返回错误 -35"></a>Q: 在从设备采体音频数据时，返回错误 -35</h2><p>A: 说明你的设备现在暂时还没准备好，此时你应该等待它几秒，之后就可以正常读数据了。例如：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while(re&#x3D;av_read_frame(...))&#123;</span><br><span class="line">   if(ret&#x3D;&#x3D;-35) &#123;</span><br><span class="line">       sleep(1);</span><br><span class="line">       continue;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Q-在编码时，编码器返回-35-错误"><a href="#Q-在编码时，编码器返回-35-错误" class="headerlink" title="Q: 在编码时，编码器返回 -35 错误"></a>Q: 在编码时，编码器返回 -35 错误</h2><p>A: 此时说明编码器没有准备好，像上面的一样需要等待一会儿。</p><h2 id="Q-采集到的音频数据编码-AAC-时，报无法找到libfdk-aac库"><a href="#Q-采集到的音频数据编码-AAC-时，报无法找到libfdk-aac库" class="headerlink" title="Q: 采集到的音频数据编码 AAC 时，报无法找到libfdk-aac库"></a>Q: 采集到的音频数据编码 AAC 时，报无法找到libfdk-aac库</h2><p>A: 如果是通过命令安装的ffmepg，则上面已经给了答案。下面的方案是通过源码编译出带fdk-aac的ffmeg。具体步骤如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 安装好 fdk-aac库</span><br><span class="line">2. 重新在ffmpeg源码目录下执行.&#x2F;configure 并增加--enable-libfdk-aac 参数</span><br><span class="line">3. make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h2 id="Q-在Linux中何采集音频数据"><a href="#Q-在Linux中何采集音频数据" class="headerlink" title="Q: 在Linux中何采集音频数据"></a>Q: 在Linux中何采集音频数据</h2><p>A: ffmpeg -f alsa -i hw:0,0 xxx.wav</p><h2 id="Q-在-Linux-中找不到-alsa-设备"><a href="#Q-在-Linux-中找不到-alsa-设备" class="headerlink" title="Q: 在 Linux 中找不到 alsa 设备"></a>Q: 在 Linux 中找不到 alsa 设备</h2><p>A：可以通过 arecord -l 查看你linux系统下有哪些音频设备。如果没有alsa, 可以使用  oss.</p><h2 id="Q-编译ffmpeg-时-filter-编译不过"><a href="#Q-编译ffmpeg-时-filter-编译不过" class="headerlink" title="Q: 编译ffmpeg 时 filter 编译不过"></a>Q: 编译ffmpeg 时 filter 编译不过</h2><p>A：选择使用 libstdc++ 库试试</p><h2 id="Q-Windows下编译ffmpeg"><a href="#Q-Windows下编译ffmpeg" class="headerlink" title="Q: Windows下编译ffmpeg"></a>Q: Windows下编译ffmpeg</h2><p>A:  <a href="https://trac.ffmpeg.org/wiki/CompilationGuide/MinGW" target="_blank" rel="noopener">https://trac.ffmpeg.org/wiki/CompilationGuide/MinGW</a></p><h2 id="Q-AAC-编码为-AAC-HE-V2-时，声音与原始声音不一样"><a href="#Q-AAC-编码为-AAC-HE-V2-时，声音与原始声音不一样" class="headerlink" title="Q: AAC 编码为 AAC_HE_V2 时，声音与原始声音不一样"></a>Q: AAC 编码为 AAC_HE_V2 时，声音与原始声音不一样</h2><p>A：这是因为老师用的 AAC 版本比较老，老版本的 AAC 与新版本的 AAC 可能有一些差异，这个我会后面查找一下原因。大家测试时可以将profile修改为 AAC HE 或 AAC LC，这样就可以正常编码出 AAC 数据了。</p><h2 id="Q-库已经安装好了，但仍报找不到它的错误？"><a href="#Q-库已经安装好了，但仍报找不到它的错误？" class="headerlink" title="Q: 库已经安装好了，但仍报找不到它的错误？"></a>Q: 库已经安装好了，但仍报找不到它的错误？</h2><p>A：首先确认是否已经将 <code>pkg-config</code>工具安装好了。可以执行下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config</span><br></pre></td></tr></table></figure><p>如果提示没有安装，则先将该工具安装好，安装命令如下：</p><ul><li>ubuntu  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt intall pkg-config</span><br></pre></td></tr></table></figure></li><li>mac  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install pkg-config</span><br></pre></td></tr></table></figure></li><li>cygwin  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cyg install pkg-config</span><br></pre></td></tr></table></figure></li><li>centos  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install pkg-config</span><br></pre></td></tr></table></figure>安装完该工具后仍然报错？那再按照具体的错误看下面的解决方案吧。</li></ul><h2 id="Q-libx264库找不到（-ERROR-libx264-not-found-）"><a href="#Q-libx264库找不到（-ERROR-libx264-not-found-）" class="headerlink" title="Q: libx264库找不到（[ERROR: libx264 not found]）"></a>Q: libx264库找不到（[ERROR: libx264 not found]）</h2><p>A:<br>该问题可能由下面三个方面的问题引起。</p><ul><li>libx264库没有安装。对于这种情况有两种解决办法:<ul><li>其一，是通过平台的安装工作进行安装，如 apt/brew/yum install x264。（注：在Linux下应该安装 libx264-dev）。</li><li>其二，是通过源码安装，步骤如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. wget https:&#x2F;&#x2F;code.videolan.org&#x2F;videolan&#x2F;x264&#x2F;-&#x2F;archive&#x2F;master&#x2F;x264-master.tar.bz2</span><br><span class="line">2. bunzip2 last_x264.tar.bz2</span><br><span class="line">3. tar -vxf last_x264.tar</span><br><span class="line">4. .&#x2F;configure --enable-static --enable-shared --disable-asm --disable-avs</span><br><span class="line">5. make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure></li></ul></li><li>通过 pkg-config 命令无法找到。对于这类问题，我们可以使用下面的命 <code>pkg-config --cflags --lib libx264</code>看是否可以找到 libx264，如果找不到，就说明确实是这个问题。解决的办法是设置环境变量。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PKG_CONFIG_PATH&#x3D;$PKG_CONFIG_PATH:&#x2F;xxx&#x2F;xxx&#x2F;lib&#x2F;pkgconfig</span><br></pre></td></tr></table></figure>其中 <code>xxx</code> 由你的实际路径代替。</li></ul><blockquote><p>注，有可能你的系统中并没有装 pkg-config工具，可以使用 brew/apt/yum install pkg-config进行安装。</p></blockquote><ul><li>无法链接上libx264, 这是由于通过环境变量 LD_LIBRARY_PATH 无法定位到 libx264库。解决的办法也很简单，与上面类似，可以通过设置环境变量来解决该问题。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH&#x3D;$LIB_LIBRARY_PATH:&#x2F;xxx&#x2F;xxx&#x2F;lib</span><br></pre></td></tr></table></figure>其中，<code>xxx</code>由你的实际路径代替。</li></ul><p>当然，你也可以将环境变量设置在脚本里，这样就不用每次都写export命令了。只需要将上面的两条语句加入到 ~/.bashrc / 或~/.bash_profile 文件里，然后在控制台执行 <code>source ~/.bashrc</code> 或 <code>source ~/.bash_profile</code>即可。</p><h2 id="Q-通过-avcodec-find-encoder-by-name-无法找到编码器"><a href="#Q-通过-avcodec-find-encoder-by-name-无法找到编码器" class="headerlink" title="Q: 通过 avcodec_find_encoder_by_name() 无法找到编码器"></a>Q: 通过 avcodec_find_encoder_by_name() 无法找到编码器</h2><p>A：通过以下步骤进行解决</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0. 你使用的ffmpeg必须是经过源码编译的</span><br><span class="line">1. 你在编译 ffmpeg 时，执行.&#x2F;configure时是否将此编码器模块添加到 ffmpeg中了？以 fdk_aac 为例，在执行 .&#x2F;configure …时你应该加上 --enable-libfdk-aac 选项。</span><br><span class="line">2. 如果通过源码编译ffmpeg时有报错，请根据错误信息查看本文档的相应处理方法</span><br><span class="line">3. 确保 pkg-config 命令查询到的是你通过源码编译的ffmpeg库</span><br></pre></td></tr></table></figure><h2 id="Q-编译不出ffplay"><a href="#Q-编译不出ffplay" class="headerlink" title="Q: 编译不出ffplay"></a>Q: 编译不出ffplay</h2><p>A：引起该问题有以下几方面的原因：</p><ul><li>所使用的操作系统没有安装图形库。如有的同学在阿里的云服务器上想安装ffplay是肯定不行的。</li><li>没有安装 SDL2 库。解决办法是通过 brew/apt/yum install sdl2 即可 或 通过 SDL2 源码安装。<strong>安装完成后，要重新进行到 ffmpeg目录下，执行 ./configure…这指命令。</strong></li><li>有的同学编译ffmpeg时，在ffmpeg目录执行./configure …时没有添加 –enable-sdl2 选项也会导致无法编译出 ffplay</li><li>SDL2与最新的Mac系统 mojave不兼容。解决办法：<ul><li>方法一<ul><li>从 <a href="https://www.libsdl.org/tmp/release/SDL2-2.0.9.tar.gz" target="_blank" rel="noopener">SDL</a>下载 2.0.9版本或以后的SDL2代码。</li><li>执行 ./configure</li><li>执行 make &amp;&amp; sudo make install</li><li>执行 export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig</li><li>[重新]编译ffmpeg</li></ul></li><li>方法二<ul><li>从<a href="https://www.libsdl.org/tmp/release/SDL2-2.0.9.dmg" target="_blank" rel="noopener">SDL</a>下载dmg包。</li><li>执行 open SDL2-2.0.9.dmg</li><li>[重新]编译ffmpeg</li></ul></li></ul></li></ul><h2 id="Q-非Mac同学如何学习本课程"><a href="#Q-非Mac同学如何学习本课程" class="headerlink" title="Q: 非Mac同学如何学习本课程"></a>Q: 非Mac同学如何学习本课程</h2><p>A：本课程中的例子的界面是由 Swift 编写的，如果你没有 Mac 系统的话，你可以用 Qt 甚至不用界面开发，代码中与ffmpeg相着的代码都是跨平台的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://coding.imooc.com/class/415.html?mc_marking=b587280c0c1c0e76c1092aa21406565a&mc_channel=syb6" target="_blank" rel="noopener">音视频小白系统入门课</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/av_base/question.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;同学们在学习《音视频课小白系统入门》这门课的过程中，经常遇到一些问题，如Mac系统下为什么无法编译ffmpeg? Xcode编译课程中的程序为什么不成功? 为什么我从设备中读的数据很小?等等不足而一。&lt;/p&gt;
&lt;p&gt;实际上，大部分同学提出的问题都是重复的。因此，我将一些最常见的问题整理出了答案放在这里，同学们可以根据自己的情况去查找相应的解决办法，以免我个人原因不能及时回答问题时，给大家的学习造成麻烦和不便。&lt;/p&gt;
    
    </summary>
    
    
      <category term="音视频" scheme="https://blog.avdancedu.com/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="ffmpeg" scheme="https://blog.avdancedu.com/tags/ffmpeg/"/>
    
      <category term="音视频" scheme="https://blog.avdancedu.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="直播" scheme="https://blog.avdancedu.com/tags/%E7%9B%B4%E6%92%AD/"/>
    
  </entry>
  
</feed>
