<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>音视跳动科技</title>
  
  <subtitle>传播最前沿的科技知识！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.avdancedu.com/"/>
  <updated>2020-07-08T08:42:03.422Z</updated>
  <id>https://blog.avdancedu.com/</id>
  
  <author>
    <name>音视跳动</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ffmpeg命令详解</title>
    <link href="https://blog.avdancedu.com/92d94a35/"/>
    <id>https://blog.avdancedu.com/92d94a35/</id>
    <published>2020-07-08T08:29:15.000Z</published>
    <updated>2020-07-08T08:42:03.422Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="http://upload-images.jianshu.io/upload_images/5956443-29b1eff4f8ce0e61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1600" alt="ffmpegX.png"></p><p>FFMPEG是特别强大的专门用于处理音视频的开源库。你既可以使用它的API对音视频进行处理，也可以使用它提供的工具，如 ffmpeg, ffplay, ffprobe，来编辑你的音视频文件。</p><p>本文将简要介绍一下 FFMPEG 库的基本目录结构及其功能，然后详细介绍一下我们在日常工作中，如何使用 ffmpeg 提供的工具来处理音视频文件。</p><a id="more"></a><h1 id="FFMPEG-目录及作用"><a href="#FFMPEG-目录及作用" class="headerlink" title="FFMPEG 目录及作用"></a>FFMPEG 目录及作用</h1><ul><li>libavcodec： 提供了一系列编码器的实现。</li><li>libavformat： 实现在流协议，容器格式及其本IO访问。</li><li>libavutil： 包括了hash器，解码器和各利工具函数。</li><li>libavfilter： 提供了各种音视频过滤器。</li><li>libavdevice： 提供了访问捕获设备和回放设备的接口。</li><li>libswresample： 实现了混音和重采样。</li><li>libswscale： 实现了色彩转换和缩放工能。</li></ul><h1 id="FFMPEG基本概念"><a href="#FFMPEG基本概念" class="headerlink" title="FFMPEG基本概念"></a>FFMPEG基本概念</h1><p>在讲解 FFMPEG 命令之前，我们先要介绍一些音视频格式的基要概念。</p><ul><li>音／视频流</li></ul><blockquote><p>在音视频领域，我们把一路音／视频称为一路<strong>流</strong>。如我们小时候经常使用VCD看港片，在里边可以选择粤语或国语声音，其实就是CD视频文件中存放了两路音频流，用户可以选择其中一路进行播放。</p></blockquote><ul><li>容器</li></ul><blockquote><p>我们一般把 MP4､ FLV、MOV等文件格式称之为<strong>容器</strong>。也就是在这些常用格式文件中，可以存放多路音视频文件。以 MP4 为例，就可以存放一路视频流，多路音频流，多路字幕流。</p></blockquote><ul><li>channel</li></ul><blockquote><p>channel是音频中的概念，称之为声道。在一路音频流中，可以有单声道，双声道或立体声。</p></blockquote><h1 id="FFMPEG-命令"><a href="#FFMPEG-命令" class="headerlink" title="FFMPEG 命令"></a>FFMPEG 命令</h1><p>我们按使用目的可以将 FFMPEG 命令分成以下几类：</p><ul><li>基本信息查询命令</li><li>录制</li><li>分解/复用</li><li>处理原始数据</li><li>滤镜</li><li>切割与合并</li><li>图／视互转</li><li>直播相关</li></ul><p>除了 FFMPEG 的基本信息查询命令外，其它命令都按下图所示的流程处理音视频。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> _______              ______________</span><br><span class="line">|       |            |              |</span><br><span class="line">| input |  demuxer   | encoded data |   decoder</span><br><span class="line">| file  | ---------&gt; | packets      | -----+</span><br><span class="line">|_______|            |______________|      |</span><br><span class="line">                                           v</span><br><span class="line">                                       _________</span><br><span class="line">                                      |         |</span><br><span class="line">                                      | decoded |</span><br><span class="line">                                      | frames  |</span><br><span class="line">                                      |_________|</span><br><span class="line"> ________             ______________       |</span><br><span class="line">|        |           |              |      |</span><br><span class="line">| output | &lt;-------- | encoded data | &lt;----+</span><br><span class="line">| file   |   muxer   | packets      |   encoder</span><br><span class="line">|________|           |______________|</span><br></pre></td></tr></table></figure><p>ffmpeg调用libavformat库（包含demuxers）来读取输入文件并获取包含编码数据的数据包。 当有多个输入文件时，ffmpeg会尝试通过跟踪任何活动输入流上的最低时间戳来使其保持同步。</p><p>然后将编码的数据包传送给解码器（除非为数据流选择了流拷贝，请参阅进一步描述）。 解码器产生未压缩的帧（原始视频/ PCM音频/ …），可以通过滤波进一步处理（见下一节）。 在过滤之后，帧被传递到编码器，编码器并输出编码的数据包。 最后，这些传递给复用器，将编码的数据包写入输出文件。</p><p>默认情况下，ffmpeg只包含输入文件中每种类型（视频，音频，字幕）的一个流，并将其添加到每个输出文件中。 它根据以下标准挑选每一个的“最佳”：对于视频，它是具有最高分辨率的流，对于音频，它是具有最多channel的流，对于字幕，是第一个字幕流。 在相同类型的几个流相等的情况下，选择具有最低索引的流。</p><p>您可以通过使用-vn / -an / -sn / -dn选项来禁用某些默认设置。 要进行全面的手动控制，请使用-map选项，该选项禁用刚描述的默认设置。</p><p>下面我们就来详细介绍一下这些命令。</p><h2 id="基本信息查询命令"><a href="#基本信息查询命令" class="headerlink" title="基本信息查询命令"></a>基本信息查询命令</h2><p>FFMPEG 可以使用下面的参数进行基本信息查询。例如，想查询一下现在使用的 FFMPEG 都支持哪些 filter，就可以用 <code>ffmpeg -filters</code> 来查询。详细参数说明如下：</p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-version</td><td align="left">显示版本。</td></tr><tr><td align="left">-formats</td><td align="left">显示可用的格式（包括设备）。</td></tr><tr><td align="left">-demuxers</td><td align="left">显示可用的demuxers。</td></tr><tr><td align="left">-muxers</td><td align="left">显示可用的muxers。</td></tr><tr><td align="left">-devices</td><td align="left">显示可用的设备。</td></tr><tr><td align="left">-codecs</td><td align="left">显示libavcodec已知的所有编解码器。</td></tr><tr><td align="left">-decoders</td><td align="left">显示可用的解码器。</td></tr><tr><td align="left">-encoders</td><td align="left">显示所有可用的编码器。</td></tr><tr><td align="left">-bsfs</td><td align="left">显示可用的比特流filter。</td></tr><tr><td align="left">-protocols</td><td align="left">显示可用的协议。</td></tr><tr><td align="left">-filters</td><td align="left">显示可用的libavfilter过滤器。</td></tr><tr><td align="left">-pix_fmts</td><td align="left">显示可用的像素格式。</td></tr><tr><td align="left">-sample_fmts</td><td align="left">显示可用的采样格式。</td></tr><tr><td align="left">-layouts</td><td align="left">显示channel名称和标准channel布局。</td></tr><tr><td align="left">-colors</td><td align="left">显示识别的颜色名称。</td></tr></tbody></table><p>接下来介绍的是 FFMPEG 处理音视频时使用的命令格式与参数。</p><h2 id="命令基本格式及参数"><a href="#命令基本格式及参数" class="headerlink" title="命令基本格式及参数"></a>命令基本格式及参数</h2><p>下面是 FFMPEG 的基本命令格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg [global_options] &#123;[input_file_options] -i input_url&#125; ...</span><br><span class="line"> &#123;[output_file_options] output_url&#125; ...</span><br></pre></td></tr></table></figure><p>ffmpeg 通过 -i 选项读取输任意数量的输入“文件”（可以是常规文件，管道，网络流，抓取设备等，并写入任意数量的输出“文件”。</p><p>原则上，每个输入/输出“文件”都可以包含任意数量的不同类型的视频流（视频/音频/字幕/附件/数据）。 流的数量和/或类型是由容器格式来限制。 选择从哪个输入进入到哪个输出将自动完成或使用 -map 选项。</p><p>要引用选项中的输入文件，您必须使用它们的索引（从0开始）。 例如。 第一个输入文件是0，第二个输入文件是1，等等。类似地，文件内的流被它们的索引引用。 例如。 2：3是指第三个输入文件中的第四个流。</p><p>上面就是 FFMPEG 处理音视频的常用命令，下面是一些常用参数：</p><h3 id="主要参数"><a href="#主要参数" class="headerlink" title="主要参数"></a>主要参数</h3><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-f fmt（输入/输出）</td><td align="left">强制输入或输出文件格式。 格式通常是自动检测输入文件，并从输出文件的文件扩展名中猜测出来，所以在大多数情况下这个选项是不需要的。</td></tr><tr><td align="left">-i url（输入）</td><td align="left">输入文件的网址</td></tr><tr><td align="left">-y（全局参数）</td><td align="left">覆盖输出文件而不询问。</td></tr><tr><td align="left">-n（全局参数）</td><td align="left">不要覆盖输出文件，如果指定的输出文件已经存在，请立即退出。</td></tr><tr><td align="left">-c [：stream_specifier] codec（输入/输出，每个流）</td><td align="left">选择一个编码器（当在输出文件之前使用）或解码器（当在输入文件之前使用时）用于一个或多个流。codec 是解码器/编码器的名称或 copy（仅输出）以指示该流不被重新编码。如：ffmpeg -i INPUT -map 0 -c:v libx264 -c:a copy OUTPUT</td></tr><tr><td align="left">-codec [：stream_specifier]编解码器（输入/输出，每个流）</td><td align="left">同 -c</td></tr><tr><td align="left">-t duration（输入/输出）</td><td align="left">当用作输入选项（在-i之前）时，限制从输入文件读取的数据的持续时间。当用作输出选项时（在输出url之前），在持续时间到达持续时间之后停止输出。</td></tr><tr><td align="left">-ss位置（输入/输出）</td><td align="left">当用作输入选项时（在-i之前），在这个输入文件中寻找位置。 请注意，在大多数格式中，不可能精确搜索，因此ffmpeg将在位置之前寻找最近的搜索点。 当转码和-accurate_seek被启用时（默认），搜索点和位置之间的这个额外的分段将被解码和丢弃。 当进行流式复制或使用-noaccurate_seek时，它将被保留。当用作输出选项（在输出url之前）时，解码但丢弃输入，直到时间戳到达位置。</td></tr><tr><td align="left">-frames [：stream_specifier] framecount（output，per-stream）</td><td align="left">停止在帧计数帧之后写入流。</td></tr><tr><td align="left">-filter [：stream_specifier] filtergraph（output，per-stream）</td><td align="left">创建由filtergraph指定的过滤器图，并使用它来过滤流。filtergraph是应用于流的filtergraph的描述，并且必须具有相同类型的流的单个输入和单个输出。在过滤器图形中，输入与标签中的标签相关联，标签中的输出与标签相关联。有关filtergraph语法的更多信息，请参阅ffmpeg-filters手册。</td></tr></tbody></table><h3 id="视频参数"><a href="#视频参数" class="headerlink" title="视频参数"></a>视频参数</h3><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-vframes num（输出）</td><td align="left">设置要输出的视频帧的数量。对于-frames：v，这是一个过时的别名，您应该使用它。</td></tr><tr><td align="left">-r [：stream_specifier] fps（输入/输出，每个流）</td><td align="left">设置帧率（Hz值，分数或缩写）。作为输入选项，忽略存储在文件中的任何时间戳，根据速率生成新的时间戳。这与用于-framerate选项不同（它在FFmpeg的旧版本中使用的是相同的）。如果有疑问，请使用-framerate而不是输入选项-r。作为输出选项，复制或丢弃输入帧以实现恒定输出帧频fps。</td></tr><tr><td align="left">-s [：stream_specifier]大小（输入/输出，每个流）</td><td align="left">设置窗口大小。作为输入选项，这是video_size专用选项的快捷方式，由某些分帧器识别，其帧尺寸未被存储在文件中。作为输出选项，这会将缩放视频过滤器插入到相应过滤器图形的末尾。请直接使用比例过滤器将其插入到开头或其他地方。格式是’wxh’（默认 - 与源相同）。</td></tr><tr><td align="left">-aspect [：stream_specifier] 宽高比（输出，每个流）</td><td align="left">设置方面指定的视频显示宽高比。aspect可以是浮点数字符串，也可以是num：den形式的字符串，其中num和den是宽高比的分子和分母。例如“4：3”，“16：9”，“1.3333”和“1.7777”是有效的参数值。如果与-vcodec副本一起使用，则会影响存储在容器级别的宽高比，但不会影响存储在编码帧中的宽高比（如果存在）。</td></tr><tr><td align="left">-vn（输出）</td><td align="left">禁用视频录制。</td></tr><tr><td align="left">-vcodec编解码器（输出）</td><td align="left">设置视频编解码器。这是-codec：v的别名。</td></tr><tr><td align="left">-vf filtergraph（输出）</td><td align="left">创建由filtergraph指定的过滤器图，并使用它来过滤流。</td></tr></tbody></table><h3 id="音频参数"><a href="#音频参数" class="headerlink" title="音频参数"></a>音频参数</h3><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-aframes（输出）</td><td align="left">设置要输出的音频帧的数量。这是-frames：a的一个过时的别名。</td></tr><tr><td align="left">-ar [：stream_specifier] freq（输入/输出，每个流）</td><td align="left">设置音频采样频率。对于输出流，它默认设置为相应输入流的频率。对于输入流，此选项仅适用于音频捕获设备和原始分路器，并映射到相应的分路器选件。</td></tr><tr><td align="left">-ac [：stream_specifier]通道（输入/输出，每个流）</td><td align="left">设置音频通道的数量。对于输出流，它默认设置为输入音频通道的数量。对于输入流，此选项仅适用于音频捕获设备和原始分路器，并映射到相应的分路器选件。</td></tr><tr><td align="left">-an（输出）</td><td align="left">禁用录音。</td></tr><tr><td align="left">-acodec编解码器（输入/输出）</td><td align="left">设置音频编解码器。这是-codec的别名：a。</td></tr><tr><td align="left">-sample_fmt [：stream_specifier] sample_fmt（输出，每个流）</td><td align="left">设置音频采样格式。使用-sample_fmts获取支持的样本格式列表。</td></tr><tr><td align="left">-af filtergraph（输出）</td><td align="left">创建由filtergraph指定的过滤器图，并使用它来过滤流。</td></tr></tbody></table><p>了解了这些基本信息后，接下来我们看看 FFMPEG 具体都能干些什么吧。</p><h2 id="录制"><a href="#录制" class="headerlink" title="录制"></a>录制</h2><p>首先通过下面的命令查看一下 mac 上都有哪些设备。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f avfoundation -list_devices true -i &quot;&quot;</span><br></pre></td></tr></table></figure><p><strong>录屏</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f avfoundation -i 1 -r 30 out.yuv</span><br></pre></td></tr></table></figure><ul><li>-f 指定使用 avfoundation 采集数据。</li><li>-i 指定从哪儿采集数据，它是一个文件索引号。在我的MAC上，1代表桌面（可以通过上面的命令查询设备索引号）。</li><li>-r 指定帧率。按ffmpeg官方文档说-r与-framerate作用相同，但实际测试时发现不同。-framerate 用于限制输入，而-r用于限制输出。</li></ul><blockquote><p>注意，桌面的输入对帧率没有要求，所以不用限制桌面的帧率。其实限制了也没用。</p></blockquote><p><strong>录屏+声音</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg  -f avfoundation -i 1:0  -r 29.97 -c:v libx264 -crf 0 -c:a libfdk_aac -profile:a aac_he_v2 -b:a 32k  out.flv</span><br></pre></td></tr></table></figure><ul><li>-i 1:0 冒号前面的 “1” 代表的屏幕索引号。冒号后面的”0”代表的声音索相号。</li><li>-c:v 与参数 -vcodec 一样，表示视频编码器。c 是 codec 的缩写，v 是video的缩写。</li><li>-crf 是 x264 的参数。 0 表式无损压缩。</li><li>-c:a 与参数 -acodec 一样，表示音频编码器。</li><li>-profile 是 fdk_aac 的参数。 aac_he_v2 表式使用 AAC_HE v2 压缩数据。</li><li>-b:a 指定音频码率。 b 是 bitrate的缩写, a是 audio的缩与。</li></ul><p><strong>Linux下录屏</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f x11grab -s 640*480 -r 20 -i :0.0 test.mp4</span><br></pre></td></tr></table></figure><p><strong>录视频</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -framerate 30 -f avfoundation -i 0 out.mp4</span><br></pre></td></tr></table></figure><ul><li>-framerate 限制视频的采集帧率。这个必须要根据提示要求进行设置，如果不设置就会报错。</li><li>-f 指定使用 avfoundation 采集数据。</li><li>-i 指定视频设备的索引号。</li></ul><p><strong>视频+音频</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -framerate 30 -f avfoundation -i 0:0 out.mp4</span><br></pre></td></tr></table></figure><p><strong>录音</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f avfoundation -i :0 out.wav</span><br></pre></td></tr></table></figure><p><strong>录制音频裸数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg  -f avfoundation -i :0 -ar 44100 -f s16le out.pcm</span><br></pre></td></tr></table></figure><p><strong>在Windows下录制播放的声音</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg  -f dshow -i audio&#x3D;&quot;立体声混音 (Realtek High Definition Audio)&quot; -ar 48000  -acodec aac -bsf:a aac_adtstoasc -f flv temp.flv</span><br></pre></td></tr></table></figure><h2 id="分解与复用"><a href="#分解与复用" class="headerlink" title="分解与复用"></a>分解与复用</h2><p>流拷贝是通过将 copy 参数提供给-codec选项来选择流的模式。它使得ffmpeg省略了指定流的解码和编码步骤，所以它只能进行多路分解和多路复用。 这对于更改容器格式或修改容器级元数据很有用。 在这种情况下，上图将简化为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> _______              ______________            ________</span><br><span class="line">|       |            |              |          |        |</span><br><span class="line">| input |  demuxer   | encoded data |  muxer   | output |</span><br><span class="line">| file  | ---------&gt; | packets      | -------&gt; | file   |</span><br><span class="line">|_______|            |______________|          |________|</span><br></pre></td></tr></table></figure><p>由于没有解码或编码，速度非常快，没有质量损失。 但是，由于许多因素，在某些情况下可能无法正常工作。 应用过滤器显然也是不可能的，因为过滤器处理未压缩的数据。</p><p><strong>抽取音频流</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -acodec copy -vn out.aac</span><br></pre></td></tr></table></figure><ul><li>acodec: 指定音频编码器，copy 指明只拷贝，不做编解码。</li><li>vn: v 代表视频，n 代表 no 也就是无视频的意思。</li></ul><p><strong>抽取视频流</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -vcodec copy -an out.h264</span><br></pre></td></tr></table></figure><ul><li>vcodec: 指定视频编码器，copy 指明只拷贝，不做编解码。</li><li>an: a 代表视频，n 代表 no 也就是无音频的意思。</li></ul><p><strong>转格式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -vcodec copy -acodec copy out.flv</span><br></pre></td></tr></table></figure><p>上面的命令表式的是音频、视频都直接 copy，只是将 mp4 的封装格式转成了flv。</p><p><strong>音视频合并</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.h264 -i out.aac -vcodec copy -acodec copy out.mp4</span><br></pre></td></tr></table></figure><h2 id="处理原始数据"><a href="#处理原始数据" class="headerlink" title="处理原始数据"></a>处理原始数据</h2><p><strong>提取YUV数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -an -c:v rawvideo -pix_fmt yuv420p out.yuv</span><br><span class="line">ffplay -s wxh out.yuv</span><br></pre></td></tr></table></figure><ul><li>-c:v rawvideo 指定将视频转成原始数据</li><li>-pix_fmt yuv420p 指定转换格式为yuv420p</li></ul><p><strong>YUV转H264</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f rawvideo -pix_fmt yuv420p -s 320x240 -r 30 -i out.yuv -c:v libx264 -f rawvideo out.h264</span><br></pre></td></tr></table></figure><p><strong>提取PCM数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -vn -ar 44100 -ac 2 -f s16le out.pcm</span><br><span class="line">ffplay -ar 44100 -ac 2 -f s16le -i out.pcm</span><br></pre></td></tr></table></figure><p><strong>PCM转WAV</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f s16be -ar 8000 -ac 2 -acodec pcm_s16be -i input.raw output.wav</span><br></pre></td></tr></table></figure><h2 id="滤镜"><a href="#滤镜" class="headerlink" title="滤镜"></a>滤镜</h2><p>在编码之前，ffmpeg可以使用libavfilter库中的过滤器处理原始音频和视频帧。 几个链式过滤器形成一个过滤器图形。 ffmpeg区分两种类型的过滤器图形：简单和复杂。</p><h3 id="简单滤镜"><a href="#简单滤镜" class="headerlink" title="简单滤镜"></a>简单滤镜</h3><p>简单的过滤器图是那些只有一个输入和输出，都是相同的类型。 在上面的图中，它们可以通过在解码和编码之间插入一个额外的步骤来表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> _________                        ______________</span><br><span class="line">|         |                      |              |</span><br><span class="line">| decoded |                      | encoded data |</span><br><span class="line">| frames  |\                   _ | packets      |</span><br><span class="line">|_________| \                  &#x2F;||______________|</span><br><span class="line">             \   __________   &#x2F;</span><br><span class="line">  simple     _\||          | &#x2F;  encoder</span><br><span class="line">  filtergraph   | filtered |&#x2F;</span><br><span class="line">                | frames   |</span><br><span class="line">                |__________|</span><br></pre></td></tr></table></figure><p>简单的filtergraphs配置了per-stream-filter选项（分别为视频和音频使用-vf和-af别名）。 一个简单的视频filtergraph可以看起来像这样的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> _______        _____________        _______        ________</span><br><span class="line">|       |      |             |      |       |      |        |</span><br><span class="line">| input | ---&gt; | deinterlace | ---&gt; | scale | ---&gt; | output |</span><br><span class="line">|_______|      |_____________|      |_______|      |________|</span><br></pre></td></tr></table></figure><p>请注意，某些滤镜会更改帧属性，但不会改变帧内容。 例如。 上例中的fps过滤器会改变帧数，但不会触及帧内容。 另一个例子是setpts过滤器，它只设置时间戳，否则不改变帧。</p><h3 id="复杂滤镜"><a href="#复杂滤镜" class="headerlink" title="复杂滤镜"></a>复杂滤镜</h3><p>复杂的过滤器图是那些不能简单描述为应用于一个流的线性处理链的过滤器图。 例如，当图形有多个输入和/或输出，或者当输出流类型与输入不同时，就是这种情况。 他们可以用下图来表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> _________</span><br><span class="line">|         |</span><br><span class="line">| input 0 |\                    __________</span><br><span class="line">|_________| \                  |          |</span><br><span class="line">             \   _________    &#x2F;| output 0 |</span><br><span class="line">              \ |         |  &#x2F; |__________|</span><br><span class="line"> _________     \| complex | &#x2F;</span><br><span class="line">|         |     |         |&#x2F;</span><br><span class="line">| input 1 |----&gt;| filter  |\</span><br><span class="line">|_________|     |         | \   __________</span><br><span class="line">               &#x2F;| graph   |  \ |          |</span><br><span class="line">              &#x2F; |         |   \| output 1 |</span><br><span class="line"> _________   &#x2F;  |_________|    |__________|</span><br><span class="line">|         | &#x2F;</span><br><span class="line">| input 2 |&#x2F;</span><br><span class="line">|_________|</span><br></pre></td></tr></table></figure><p>复杂的过滤器图使用-filter_complex选项进行配置。 请注意，此选项是全局性的，因为复杂的过滤器图形本质上不能与单个流或文件明确关联。</p><p>-lavfi选项等同于-filter_complex。</p><p>一个复杂的过滤器图的一个简单的例子是覆盖过滤器，它有两个视频输入和一个视频输出，包含一个视频叠加在另一个上面。 它的音频对应是amix滤波器。</p><p><strong>添加水印</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4  -vf &quot;movie&#x3D;logo.png,scale&#x3D;64:48[watermask];[in][watermask] overlay&#x3D;30:10 [out]&quot; water.mp4</span><br></pre></td></tr></table></figure><ul><li>-vf中的 movie 指定logo位置。scale 指定 logo 大小。overlay 指定 logo 摆放的位置。</li></ul><p><strong>删除水印</strong><br>先通过 ffplay 找到要删除 LOGO 的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffplay -i test.flv -vf delogo&#x3D;x&#x3D;806:y&#x3D;20:w&#x3D;70:h&#x3D;80:show&#x3D;1</span><br></pre></td></tr></table></figure><p>使用 delogo 滤镜删除 LOGO</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.flv -vf delogo&#x3D;x&#x3D;806:y&#x3D;20:w&#x3D;70:h&#x3D;80 output.flv</span><br></pre></td></tr></table></figure><p><strong>视频缩小一倍</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -vf scale&#x3D;iw&#x2F;2:-1 scale.mp4</span><br></pre></td></tr></table></figure><ul><li>-vf scale 指定使用简单过滤器 scale，iw/2:-1 中的 iw 指定按整型取视频的宽度。 -1 表示高度随宽度一起变化。</li></ul><p><strong>视频裁剪</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i VR.mov  -vf crop&#x3D;in_w-200:in_h-200 -c:v libx264 -c:a copy -video_size 1280x720 vr_new.mp4</span><br></pre></td></tr></table></figure><p>crop 格式：crop=out_w:out_h:x:y</p><ul><li>out_w: 输出的宽度。可以使用 in_w 表式输入视频的宽度。</li><li>out_h: 输出的高度。可以使用 in_h 表式输入视频的高度。</li><li>x : X坐标</li><li>y : Y坐标</li></ul><blockquote><p>如果 x和y 设置为 0,说明从左上角开始裁剪。如果不写是从中心点裁剪。</p></blockquote><p><strong>倍速播放</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -filter_complex &quot;[0:v]setpts&#x3D;0.5*PTS[v];[0:a]atempo&#x3D;2.0[a]&quot; -map &quot;[v]&quot; -map &quot;[a]&quot; speed2.0.mp4</span><br></pre></td></tr></table></figure><ul><li>-filter_complex 复杂滤镜，[0:v]表示第一个（文件索引号是0）文件的视频作为输入。setpts=0.5*PTS表示每帧视频的pts时间戳都乘0.5 ，也就是差少一半。[v]表示输出的别名。音频同理就不详述了。</li><li>map 可用于处理复杂输出，如可以将指定的多路流输出到一个输出文件，也可以指定输出到多个文件。”[v]” 复杂滤镜输出的别名作为输出文件的一路流。上面 map的用法是将复杂滤镜输出的视频和音频输出到指定文件中。</li></ul><p><strong>对称视频</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg  -i out.mp4 -filter_complex &quot;[0:v]pad&#x3D;w&#x3D;2*iw[a];[0:v]hflip[b];[a][b]overlay&#x3D;x&#x3D;w&quot; duicheng.mp4</span><br></pre></td></tr></table></figure><ul><li>hflip 水平翻转</li></ul><p>如果要修改为垂直翻转可以用vflip。</p><p><strong>画中画</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -i out1.mp4 -filter_complex &quot;[1:v]scale&#x3D;w&#x3D;176:h&#x3D;144:force_original_aspect_ratio&#x3D;decrease[ckout];[0:v][ckout]overlay&#x3D;x&#x3D;W-w-10:y&#x3D;0[out]&quot; -map &quot;[out]&quot; -movflags faststart new.mp4</span><br></pre></td></tr></table></figure><p><strong>录制画中画</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg  -f avfoundation -i &quot;1&quot; -framerate 30 -f avfoundation -i &quot;0:0&quot;</span><br><span class="line">-r 30 -c:v libx264 -preset ultrafast</span><br><span class="line">-c:a libfdk_aac -profile:a aac_he_v2 -ar 44100 -ac 2</span><br><span class="line">-filter_complex &quot;[1:v]scale&#x3D;w&#x3D;176:h&#x3D;144:force_original_aspect_ratio&#x3D;decrease[a];[0:v][a]overlay&#x3D;x&#x3D;W-w-10:y&#x3D;0[out]&quot;</span><br><span class="line">-map &quot;[out]&quot; -movflags faststart -map 1:a b.mp4</span><br></pre></td></tr></table></figure><p><strong>多路视频拼接</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg  -f avfoundation -i &quot;1&quot; -framerate 30 -f avfoundation   -i &quot;0:0&quot; -r 30 -c:v libx264 -preset ultrafast -c:a libfdk_aac -profile:a aac_he_v2 -ar 44100 -ac 2 -filter_complex &quot;[0:v]scale&#x3D;320:240[a];[a]pad&#x3D;640:240[b];[b][1:v]overlay&#x3D;320:0[out]&quot; -map &quot;[out]&quot; -movflags faststart  -map 1:a  c.mp4</span><br></pre></td></tr></table></figure><p><strong>滤镜加水印</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i killer.mp4 -filter_complex &quot;movie&#x3D;.&#x2F;logo&#x2F;daka.png,scale&#x3D;64:48[w];[0:v]curves&#x3D;vintage[o];[o][w]overlay&#x3D;30:10[out]&quot; -map &quot;[out]&quot; -map 0:a test1.mp4</span><br></pre></td></tr></table></figure><p><strong>多张图片合成一张</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i killer.mp4 -vf &quot;select&#x3D;not(mod(n\,250)),scale&#x3D;320:240,tile&#x3D;2x3&quot; -an  out%3d.png</span><br></pre></td></tr></table></figure><h2 id="一些比较有意思的滤镜"><a href="#一些比较有意思的滤镜" class="headerlink" title="一些比较有意思的滤镜"></a>一些比较有意思的滤镜</h2><ul><li>镜像<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crop&#x3D;iw&#x2F;2:ih:0:0,split[left][tmp];[tmp]hflip[right];</span><br></pre></td></tr></table></figure></li><li>复古<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curves&#x3D;vintage;</span><br></pre></td></tr></table></figure></li><li>光晕<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vignette&#x3D;PI&#x2F;4</span><br></pre></td></tr></table></figure></li><li>变暗<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colorlevels&#x3D;rimin&#x3D;0.058:gimin&#x3D;0.058:bimin&#x3D;0.058</span><br></pre></td></tr></table></figure></li><li>增加对比度<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fftfilt&#x3D;dc_Y&#x3D;0:weight_Y&#x3D;&#39;exp(-4 * ((Y+X)&#x2F;(W+H)))</span><br></pre></td></tr></table></figure></li><li>降噪<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hqdn3d&#x3D;luma_spatial&#x3D;15.0</span><br></pre></td></tr></table></figure></li><li>强对比度<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curves&#x3D;strong_contrast</span><br></pre></td></tr></table></figure></li><li>变亮<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curves&#x3D;lighter</span><br></pre></td></tr></table></figure></li><li>锐化<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fftfilt&#x3D;dc_Y&#x3D;0:weight_Y&#x3D;&#39;1+squish(1-(Y+X)&#x2F;100)&#39;</span><br></pre></td></tr></table></figure></li><li>低通滤波<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fftfilt&#x3D;dc_Y&#x3D;0:weight_Y&#x3D;&#39;squish((Y+X)&#x2F;100-1)&#39;</span><br></pre></td></tr></table></figure></li><li>高通滤波<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fftfilt&#x3D;dc_Y&#x3D;128:weight_Y&#x3D;&#39;squish(1-(Y+X)&#x2F;100)&#39;</span><br></pre></td></tr></table></figure></li><li>复古<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curves&#x3D;vintage</span><br></pre></td></tr></table></figure></li><li>边缘检测<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edgedetect</span><br></pre></td></tr></table></figure></li><li>底片<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">negate</span><br></pre></td></tr></table></figure></li><li>彩色底片<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curves &#x3D; ‘none’‘color_negative’</span><br></pre></td></tr></table></figure></li></ul><h2 id="音视频的拼接与裁剪"><a href="#音视频的拼接与裁剪" class="headerlink" title="音视频的拼接与裁剪"></a>音视频的拼接与裁剪</h2><p><strong>裁剪</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -ss 00:00:00 -t 10 out1.mp4</span><br></pre></td></tr></table></figure><ul><li>-ss 指定裁剪的开始时间，精确到秒</li><li>-t 被裁剪后的时长。</li></ul><p><strong>视频合并</strong></p><p>首先创建一个 inputs.txt 文件，文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file &#39;1.flv&#39;</span><br><span class="line">file &#39;2.flv&#39;</span><br><span class="line">file &#39;3.flv&#39;</span><br></pre></td></tr></table></figure><p>然后执行下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f concat -i inputs.txt -c copy output.flv</span><br></pre></td></tr></table></figure><p><strong>音频合并</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i text.mp3 -i silenceall.mp3 -filter_complex &#39;[0:0] [1:0] concat&#x3D;n&#x3D;2:v&#x3D;0:a&#x3D;1 [a]&#39; -map [a] test.mp3</span><br></pre></td></tr></table></figure><p><strong>音频混音</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.mp4 -i test.mp3 -filter_complex &quot;[0:a] [1:a]amerge&#x3D;inputs&#x3D;2[aout]&quot; -map &quot;[aout]&quot; -ac 2 mix_amerge.aac</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i INPUT1 -i INPUT2 -i INPUT3 -filter_complex &#39;amix&#x3D;inputs&#x3D;3:duration&#x3D;first:dropout_transition&#x3D;3&#39; OUTPUT</span><br></pre></td></tr></table></figure><ul><li>inputs: The number of inputs. If unspecified, it defaults to 2.//输入的数量，如果没有指明，默认为2.</li><li>duration: How to determine the end-of-stream.//决定了流的结束</li><li>longest: The duration of the longest input. (default)//最长输入的持续时间</li><li>shortest: The duration of the shortest input.//最短输入的持续时间</li><li>first: The duration of the first input.//第一个输入的持续时间</li><li>dropout_transition: The transition time, in seconds, for volume renormalization when an input stream ends. The default value is 2 seconds.//输入流结束时（音频）容量重整化的转换时间（以秒为单位）。 默认值为2秒。</li></ul><blockquote><p>注： amerge 与amix 的区别<br>amerge terminates with the shortest input (always) and amix terminates with the longest input, by default. So the former will always truncate when streams are of different length.</p></blockquote><p><strong>hls切片</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -c:v libx264 -c:a libfdk_aac -strict -2 -f hls  out.m3u8</span><br></pre></td></tr></table></figure><ul><li>-strict -2 指明音频使有AAC。</li><li>-f hls 转成 m3u8 格式。</li></ul><p><strong>将ts文件按时间切片</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg  -i somefile.ts  -f segment -segment_time 3  -c copy out%03d.ts</span><br></pre></td></tr></table></figure><h2 id="视频图片互转"><a href="#视频图片互转" class="headerlink" title="视频图片互转"></a>视频图片互转</h2><p><strong>视频转JPEG</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.flv -r 1 -f image2 image-%3d.jpeg</span><br></pre></td></tr></table></figure><p><strong>视频转gif</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -ss 00:00:00 -t 10 out.gif</span><br></pre></td></tr></table></figure><p><strong>图片转视频</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg  -f image2 -i image-%3d.jpeg images.mp4</span><br></pre></td></tr></table></figure><p><strong>一张图片转成5秒视频</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -loop 1 -i .&#x2F;xxx.jpeg -pix_fmt yuv420p -c:v libx264 -preset veryfast -r 25 -t 5 b.mp4</span><br></pre></td></tr></table></figure><h2 id="直播相关"><a href="#直播相关" class="headerlink" title="直播相关"></a>直播相关</h2><p><strong>推流</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -i out.mp4 -c copy -f flv rtmp:&#x2F;&#x2F;server&#x2F;live&#x2F;streamName</span><br></pre></td></tr></table></figure><ul><li>re的含义 ，Read input at native frame rate. Mainly used to simulate a grab device, or live input stream (e.g. when reading from a file). Should not be used with actual grab devices or live input streams (where it can cause packet loss). By default ffmpeg attempts to read the input(s) as fast as possible. This option will slow down the reading of the input(s) to the native frame rate of the input(s). It is useful for real-time output (e.g. live streaming).</li></ul><p><strong>推rtsp流</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -i input -f rtsp -muxdelay 0.1 rtsp:&#x2F;&#x2F;server&#x2F;live.sdp</span><br></pre></td></tr></table></figure><p><strong>循环推流</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -stream_loop 1 -i out.mp4  -c copy -f flv rtmp:&#x2F;&#x2F;server&#x2F;live&#x2F;streamName</span><br></pre></td></tr></table></figure><p><strong>拉流保存</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i rtmp:&#x2F;&#x2F;server&#x2F;live&#x2F;streamName -c copy dump.flv</span><br></pre></td></tr></table></figure><p><strong>转流</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i rtmp:&#x2F;&#x2F;server&#x2F;live&#x2F;originalStream -c:a copy -c:v copy -f flv rtmp:&#x2F;&#x2F;server&#x2F;live&#x2F;h264Stream</span><br></pre></td></tr></table></figure><p><strong>实时推流</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -framerate 15 -f avfoundation -i &quot;1&quot; -s 1280x720 -c:v libx264  -f  flv rtmp:&#x2F;&#x2F;localhost:1935&#x2F;live&#x2F;room</span><br></pre></td></tr></table></figure><h2 id="ffplay"><a href="#ffplay" class="headerlink" title="ffplay"></a>ffplay</h2><p><strong>播放YUV 数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffplay -pix_fmt nv12 -s 192x144 1.yuv</span><br></pre></td></tr></table></figure><p><strong>播放YUV中的 Y平面</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffplay -pix_fmt nv21 -s 640x480 -vf extractplanes&#x3D;&#39;y&#39; 1.yuv</span><br></pre></td></tr></table></figure><h2 id="查看多媒体文件详细信息"><a href="#查看多媒体文件详细信息" class="headerlink" title="查看多媒体文件详细信息"></a>查看多媒体文件详细信息</h2><p><strong>输出每路流最详细的信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffprobe -print_format json -show_streams 多媒体文件</span><br></pre></td></tr></table></figure><p><strong>输出帧信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffprobe -show_frames  多媒体文件</span><br></pre></td></tr></table></figure><p><strong>输出包信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffprobe -show_packets 多媒体文件</span><br></pre></td></tr></table></figure><h2 id="我的ffmpeg视频课地址"><a href="#我的ffmpeg视频课地址" class="headerlink" title="我的ffmpeg视频课地址"></a>我的ffmpeg视频课地址</h2><p><a href="http://www.imooc.com/u/4873493/courses?sort=publish" target="_blank" rel="noopener">课程主页地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;http://upload-images.jianshu.io/upload_images/5956443-29b1eff4f8ce0e61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1600&quot; alt=&quot;ffmpegX.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;FFMPEG是特别强大的专门用于处理音视频的开源库。你既可以使用它的API对音视频进行处理，也可以使用它提供的工具，如 ffmpeg, ffplay, ffprobe，来编辑你的音视频文件。&lt;/p&gt;
&lt;p&gt;本文将简要介绍一下 FFMPEG 库的基本目录结构及其功能，然后详细介绍一下我们在日常工作中，如何使用 ffmpeg 提供的工具来处理音视频文件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="音视频" scheme="https://blog.avdancedu.com/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="ffmpeg" scheme="https://blog.avdancedu.com/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>深入剖析WebRTC之事件机制Slot</title>
    <link href="https://blog.avdancedu.com/a35f406b/"/>
    <id>https://blog.avdancedu.com/a35f406b/</id>
    <published>2020-07-07T13:05:13.000Z</published>
    <updated>2020-07-07T13:09:13.053Z</updated>
    
    <content type="html"><![CDATA[<p>我最早了解到 sigslot 大概是在 2007年 左右，当时在QT中大量使用了 sigslot 的概念。 现在 WebRTC 中也大量使用了 sigslot 这种机制来处理底层的事件。它对我们阅读WebRTC代码至关重要。本篇文章就详细介绍一下 sigslot。</p><a id="more"></a><h2 id="Sigslot作用"><a href="#Sigslot作用" class="headerlink" title="Sigslot作用"></a>Sigslot作用</h2><p>Sigslot 的作用一句话表式就是为了<strong>解耦</strong>。例如，有两个类 A 和 B，如果 B 使用 A, 就必须在 B 类中写入与 A 类有关的代码。看下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">B(A&amp; a)&#123;</span><br><span class="line">m_a = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcB</span><span class="params">()</span></span>&#123;</span><br><span class="line">m_a.funcA(); <span class="comment">//这里调用了A类的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">A m_a; <span class="comment">//引用 A 类型成员变量。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">A a;</span><br><span class="line"><span class="function">B <span class="title">b</span><span class="params">(a)</span></span>;</span><br><span class="line">b.funcB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<strong>弊端</strong>是 B 中必须要声名使用 A。如果我们的项目特别复杂，这样的使用方式在后期维护时很容易让我们掉入“陷阱”。有没有一种通用的办法可以做到在 B 中不用使用 A 也可以调用 A 中的方法呢？答案就是使用 <strong>sigslot</strong>。我们看下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> sigslot::has_slot&lt;&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">funcA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    sigslot::signal0&lt;&gt; sender;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在运行时才将 a 和 b 绑定到一起</span></span><br><span class="line">b.sender.<span class="built_in">connect</span>(&amp;a, &amp;A::funcA);</span><br><span class="line">b.sender();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码我们可以看到 B 中没有一行与 A 相关的代码。只在 main 函数中（也就是在运行时）才知道 A 与 B 有关联关系。是不是觉得很神奇呢？下面我们就看一下它的实现原理。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>sigslot的原理其实非常简单，它就是一个变化的观察者模式。观察者模式如下所示：</p><p><img data-src="http://upload-images.jianshu.io/upload_images/5956443-cd6a57418c8ff9fc.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""></p><p>观察者模式，首先让 Observer(“观察者”)对象 注册到 Subject(“被观察者”) 对象中。当 Subject 状态发生变化时，遍历所有注册到自己的 Observer 对象，并调用它们的 notify方法。</p><p>sigslot与观察者模式类似，它使用signal(“信号”)和slot(“槽”)，区别在于 signal 主动连接自己感兴趣的类及其方法，将它们保存到自己的列表中。当发射信号时，它遍历所有的连接，调用 slot（“槽”） 方法。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>下面我们看一下 WebRTC 中是如何使用 sigslot 的。</p><ul><li>首先，定义 slot(“槽”)，也就是事件处理函数。在WebRTC中定义槽必须继承 has_slots&lt;&gt;。如下图所示：</li></ul><p><img data-src="http://upload-images.jianshu.io/upload_images/5956443-9db34af78eb1e4ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""></p><ul><li><p>其次，定义 signal (“信号”) ，也就是发送的信号。</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sigslot::signal1&lt;AsyncSocket*,</span><br><span class="line">           sigslot::multi_threaded_local&gt; SignalWriteEvent;</span><br></pre></td></tr></table></figure></li><li><p>然后，将 signal 与 slot 连接到一起。在这里就是将 AsyncUDPSocket和 OnWriteEvent方法与signal绑定到一起。</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">socket_-&gt;SignalWriteEvent.<span class="built_in">connect</span>(<span class="keyword">this</span>,</span><br><span class="line">&amp;AsyncUDPSocket::OnWriteEvent);</span><br></pre></td></tr></table></figure></li><li><p>最后，发送信号。在 WebRTC中根据参数的不同定义了许多 signal，如 signal1 说明带一个参数，signal2说明带两个参数。</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SignalWriteEvent(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><p>下面是对 sigslog 的类关系图及关键代码与其详细注释。</p><p><img data-src="http://upload-images.jianshu.io/upload_images/5956443-e2f8002c19fa7338.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// On our copy of sigslot.h, we set single threading as default.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGSLOT_DEFAULT_MT_POLICY single_threaded</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(SIGSLOT_PURE_ISO) ||                   \</span></span><br><span class="line">    (!defined(WEBRTC_WIN) &amp;&amp; !defined(__GNUG__) &amp;&amp; \</span><br><span class="line">     !defined(SIGSLOT_USE_POSIX_THREADS))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SIGSLOT_SINGLE_THREADED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(WEBRTC_WIN)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SIGSLOT_HAS_WIN32_THREADS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(WIN32_LEAN_AND_MEAN)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"webrtc/rtc_base/win32.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__GNUG__) || defined(SIGSLOT_USE_POSIX_THREADS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SIGSLOT_HAS_POSIX_THREADS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SIGSLOT_SINGLE_THREADED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SIGSLOT_DEFAULT_MT_POLICY</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _SIGSLOT_SINGLE_THREADED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGSLOT_DEFAULT_MT_POLICY single_threaded</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGSLOT_DEFAULT_MT_POLICY multi_threaded_local</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> change this namespace to rtc?</span></span><br><span class="line"><span class="keyword">namespace</span> sigslot &#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//这面这大段代码是为了实现智能锁使用的。</span></span><br><span class="line"><span class="comment">//它会根据不同的平台初始化不同的互斥量，并调用不同的锁函数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是 Window 平台</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _SIGSLOT_HAS_WIN32_THREADS</span></span><br><span class="line"><span class="comment">// The multi threading policies only get compiled in if they are enabled.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是全局线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">multi_threaded_global</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  multi_threaded_global() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> isinitialised = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isinitialised) &#123;</span><br><span class="line">      InitializeCriticalSection(get_critsec());</span><br><span class="line">      isinitialised = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; EnterCriticalSection(get_critsec()); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; LeaveCriticalSection(get_critsec()); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function">CRITICAL_SECTION* <span class="title">get_critsec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> CRITICAL_SECTION g_critsec;</span><br><span class="line">    <span class="keyword">return</span> &amp;g_critsec;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是本地线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">multi_threaded_local</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  multi_threaded_local() &#123; InitializeCriticalSection(&amp;m_critsec); &#125;</span><br><span class="line"></span><br><span class="line">  multi_threaded_local(<span class="keyword">const</span> multi_threaded_local&amp;) &#123;</span><br><span class="line">    InitializeCriticalSection(&amp;m_critsec);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~multi_threaded_local() &#123; DeleteCriticalSection(&amp;m_critsec); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; EnterCriticalSection(&amp;m_critsec); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; LeaveCriticalSection(&amp;m_critsec); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  CRITICAL_SECTION m_critsec;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// _SIGSLOT_HAS_WIN32_THREADS</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//非window平台</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _SIGSLOT_HAS_POSIX_THREADS</span></span><br><span class="line"><span class="comment">// The multi threading policies only get compiled in if they are enabled.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是全局线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">multi_threaded_global</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; pthread_mutex_lock(get_mutex()); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; pthread_mutex_unlock(get_mutex()); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span>* <span class="title">get_mutex</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是本地线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">multi_threaded_local</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  multi_threaded_local() &#123; pthread_mutex_init(&amp;m_mutex, <span class="literal">nullptr</span>); &#125;</span><br><span class="line">  multi_threaded_local(<span class="keyword">const</span> multi_threaded_local&amp;) &#123;</span><br><span class="line">    pthread_mutex_init(&amp;m_mutex, <span class="literal">nullptr</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ~multi_threaded_local() &#123; pthread_mutex_destroy(&amp;m_mutex); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; pthread_mutex_lock(&amp;m_mutex); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; pthread_mutex_unlock(&amp;m_mutex); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">pthread_mutex_t</span> m_mutex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// _SIGSLOT_HAS_POSIX_THREADS</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据不同的策略调用不同的锁。</span></span><br><span class="line"><span class="comment">//这里的策略就是不同的平台</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">mt_policy</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">lock_block</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  mt_policy* m_mutex;</span><br><span class="line"></span><br><span class="line">  lock_block(mt_policy* mtx) : m_mutex(mtx) &#123; m_mutex-&gt;lock(); &#125;</span><br><span class="line"></span><br><span class="line">  ~lock_block() &#123; m_mutex-&gt;unlock(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">signal_base_interface</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">has_slots_interface</span> &#123;</span></span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">signal_connect</span><span class="params">(_signal_base_interface* sender)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">signal_disconnect</span><span class="params">(_signal_base_interface* sender)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">disconnect_all</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">signal_base_interface</span> &#123;</span></span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">slot_disconnect</span><span class="params">(has_slots_interface* pslot)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">slot_duplicate</span><span class="params">(<span class="keyword">const</span> has_slots_interface* poldslot,</span></span></span><br><span class="line"><span class="function"><span class="params">                      has_slots_interface* pnewslot)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该类是一个特别重要的类</span></span><br><span class="line"><span class="comment">// signal与slot绑定之前，必须先将槽对象与槽方法组成 connection</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">opaque_connection</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">emit_t</span>)</span><span class="params">(<span class="keyword">const</span> _opaque_connection*)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//联合结构体，用于函数转换</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> FromT, <span class="keyword">typename</span> ToT&gt;</span><br><span class="line">  <span class="keyword">union</span> union_caster &#123;</span><br><span class="line">    FromT from;</span><br><span class="line">    ToT to;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//信号发射函数指针</span></span><br><span class="line">  <span class="keyword">emit_t</span> pemit;</span><br><span class="line">  <span class="comment">//存放“槽”对象</span></span><br><span class="line">  has_slots_interface* pdest;</span><br><span class="line">  <span class="comment">// Pointers to member functions may be up to 16 bytes for virtual classes,</span></span><br><span class="line">  <span class="comment">// so make sure we have enough space to store it.</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> pmethod[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  <span class="comment">//在构造connect时，要传入槽对象和槽类方法指针</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> DestT, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  _opaque_connection(DestT* pd, <span class="keyword">void</span> (DestT::*pm)(Args...)) : pdest(pd) &#123;</span><br><span class="line">    <span class="comment">//定义成员函数指针，与C语言中的函数指针是类似的</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(DestT::*<span class="keyword">pm_t</span>)</span><span class="params">(Args...)</span></span>;</span><br><span class="line">    <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(<span class="keyword">pm_t</span>) &lt;= <span class="keyword">sizeof</span>(pmethod),</span><br><span class="line">                  <span class="string">"Size of slot function pointer too large."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">memcpy</span>(pmethod, &amp;pm, <span class="keyword">sizeof</span>(<span class="keyword">pm_t</span>));</span><br><span class="line"></span><br><span class="line"> <span class="comment">//定义了一个函数指针</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">em_t</span>)</span><span class="params">(<span class="keyword">const</span> _opaque_connection* self, Args...)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过下面的方法，将 pemit 函数变理指向了 emitter 函数。</span></span><br><span class="line">    union_caster&lt;<span class="keyword">em_t</span>, <span class="keyword">emit_t</span>&gt; caster2;</span><br><span class="line">    <span class="comment">//注意 emitter后面的是模版参数，不是函数参数，这里不要弄混了。</span></span><br><span class="line">    caster2.from = &amp;_opaque_connection::emitter&lt;DestT, Args...&gt;;</span><br><span class="line">    pemit = caster2.to;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回"槽"对象</span></span><br><span class="line">  <span class="function">has_slots_interface* <span class="title">getdest</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> pdest; &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">//因为在构造函数里已经将 pemit 设置为 emitter 了，</span></span><br><span class="line">  <span class="comment">//所以下面的代码就是调用 emitter 函数。为里只不过做了一次函数指针类型转换。</span></span><br><span class="line">  <span class="comment">//也就是说调用 connect 的 emit 方法，实际调的是 emitter。</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">emit</span><span class="params">(Args... args)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">em_t</span>)</span><span class="params">(<span class="keyword">const</span> _opaque_connection*, Args...)</span></span>;</span><br><span class="line">    union_caster&lt;<span class="keyword">emit_t</span>, <span class="keyword">em_t</span>&gt; caster;</span><br><span class="line">    caster.from = pemit;</span><br><span class="line">    (caster.to)(<span class="keyword">this</span>, args...);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> DestT, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">emitter</span><span class="params">(<span class="keyword">const</span> _opaque_connection* self, Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//pm_t是一个成员函数指针，它指向的是传进来的成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(DestT::*<span class="keyword">pm_t</span>)</span><span class="params">(Args...)</span></span>;</span><br><span class="line">    <span class="keyword">pm_t</span> pm;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">memcpy</span>(&amp;pm, self-&gt;pmethod, <span class="keyword">sizeof</span>(<span class="keyword">pm_t</span>));</span><br><span class="line">    <span class="comment">//调用成员方法</span></span><br><span class="line">    (<span class="keyword">static_cast</span>&lt;DestT*&gt;(self-&gt;pdest)-&gt;*(pm))(args...);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//signal_with_thread_policy类的父类。</span></span><br><span class="line"><span class="comment">//该类最主要的作用是存有一个conn list。</span></span><br><span class="line"><span class="comment">//在 signal_with_thread_policy中的connect方法就是对该成员变量的操作。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">mt_policy</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> _<span class="title">signal_base</span> :</span> <span class="keyword">public</span> _signal_base_interface, <span class="keyword">public</span> mt_policy &#123;</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;_opaque_connection&gt; connections_list;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">//在 _signal_base 中定义了一个connection list，用于绑定的 slots.</span></span><br><span class="line">  connections_list m_connected_slots;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该类是"槽"的实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">mt_policy</span> = <span class="title">SIGSLOT_DEFAULT_MT_POLICY</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">has_slots</span> :</span> <span class="keyword">public</span> has_slots_interface, <span class="keyword">public</span> mt_policy &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt;_signal_base_interface*&gt; sender_set;</span><br><span class="line">  <span class="keyword">typedef</span> sender_set::const_iterator const_iterator;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  has_slots()</span><br><span class="line">      : has_slots_interface(&amp;has_slots::do_signal_connect,</span><br><span class="line">                            &amp;has_slots::do_signal_disconnect,</span><br><span class="line">                            &amp;has_slots::do_disconnect_all) &#123;&#125;</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  has_slots&amp; <span class="keyword">operator</span>=(has_slots <span class="keyword">const</span>&amp;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//静态函数，用于与signal绑定，由父类调用</span></span><br><span class="line">  <span class="comment">//它是在构造函数时传给父类的</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_signal_connect</span><span class="params">(has_slots_interface* p,</span></span></span><br><span class="line"><span class="function"><span class="params">                                _signal_base_interface* sender)</span> </span>&#123;</span><br><span class="line">    has_slots* <span class="keyword">const</span> self = <span class="keyword">static_cast</span>&lt;has_slots*&gt;(p);</span><br><span class="line">    <span class="function">lock_block&lt;mt_policy&gt; <span class="title">lock</span><span class="params">(self)</span></span>;</span><br><span class="line">    self-&gt;m_senders.insert(sender);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//静态函数，用于解绑signal，由父类调用</span></span><br><span class="line">  <span class="comment">//它是在构造函数时传给父类的</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_signal_disconnect</span><span class="params">(has_slots_interface* p,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   _signal_base_interface* sender)</span> </span>&#123;</span><br><span class="line">    has_slots* <span class="keyword">const</span> self = <span class="keyword">static_cast</span>&lt;has_slots*&gt;(p);</span><br><span class="line">    <span class="function">lock_block&lt;mt_policy&gt; <span class="title">lock</span><span class="params">(self)</span></span>;</span><br><span class="line">    self-&gt;m_senders.erase(sender);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//该集合中存放的是与slog绑定的 signal</span></span><br><span class="line">  sender_set m_senders;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该类是信号的具体实现</span></span><br><span class="line"><span class="comment">//为了保证信号可以在不同的平台是线程安全的，所以这里使用了策略模式</span></span><br><span class="line"><span class="comment">//mt_policy参数表式的是，不同的平台使用不同的策略</span></span><br><span class="line"><span class="comment">//该类中有两个重要的函数，一个是connect用于与槽进行绑定；另一个是 emit用于发射信号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">mt_policy</span>, <span class="title">typename</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">signal_with_thread_policy</span> :</span> <span class="keyword">public</span> _signal_base&lt;mt_policy&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">desttype</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">void</span> <span class="title">connect</span>(<span class="title">desttype</span>* <span class="title">pclass</span>, <span class="title">void</span> (<span class="title">desttype</span>:</span>:*pmemfun)(Args...)) &#123;</span><br><span class="line">    <span class="comment">//这是一个智能锁，当函数结束时，自动释放锁。</span></span><br><span class="line">    <span class="function">lock_block&lt;mt_policy&gt; <span class="title">lock</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="comment">//先将对象与"槽"组成一个conn,然后存放到 signal的 conn list里</span></span><br><span class="line">    <span class="comment">//当发射信号时，调用 conn list中的每个conn的 emit方法。</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_connected_slots.push_back(_opaque_connection(pclass, pmemfun));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在槽对象中也要保存 signal 对象。</span></span><br><span class="line">    pclass-&gt;signal_connect(<span class="keyword">static_cast</span>&lt;_signal_base_interface*&gt;(<span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//遍历所有的连接，并调用 conn 的emit方法。最终调用的是绑定"槽"的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">emit</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="function">lock_block&lt;mt_policy&gt; <span class="title">lock</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_current_iterator = <span class="keyword">this</span>-&gt;m_connected_slots.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>-&gt;m_current_iterator != <span class="keyword">this</span>-&gt;m_connected_slots.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      _opaque_connection <span class="keyword">const</span>&amp; conn = *<span class="keyword">this</span>-&gt;m_current_iterator;</span><br><span class="line">      ++(<span class="keyword">this</span>-&gt;m_current_iterator);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//调 conn 的 emit 方法，最终会调用绑定的 "槽" 方法。</span></span><br><span class="line">      conn.emit&lt;Args...&gt;(args...);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//重载（）操作符，这样就从直接调用emit方法变成隐含调用emit方法。</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Args... args)</span> </span>&#123; emit(args...); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的对不同参数信号的定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">using</span> signal = signal_with_thread_policy&lt;SIGSLOT_DEFAULT_MT_POLICY, Args...&gt;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> mt_policy = SIGSLOT_DEFAULT_MT_POLICY&gt;</span><br><span class="line"><span class="keyword">using</span> signal0 = signal_with_thread_policy&lt;mt_policy&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A1, <span class="keyword">typename</span> mt_policy = SIGSLOT_DEFAULT_MT_POLICY&gt;</span><br><span class="line"><span class="keyword">using</span> signal1 = signal_with_thread_policy&lt;mt_policy, A1&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A1,</span><br><span class="line">          <span class="keyword">typename</span> A2,</span><br><span class="line">          <span class="keyword">typename</span> mt_policy = SIGSLOT_DEFAULT_MT_POLICY&gt;</span><br><span class="line"><span class="keyword">using</span> signal2 = signal_with_thread_policy&lt;mt_policy, A1, A2&gt;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace sigslot</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文通过 sigslot作用、实现原理、如何使用以及详细的代码注释四个部分剖析了 WebRTC 中的 sigslot。sigslot是 WebRTC中非常底性的基础代码，它对 WebRTC 事件机制起着关键性的作用。熟悉sigslot，对我们阅读 WebRTC 代码会有非常大的帮助。</p><p>希望本文能对你有所帮助。谢谢！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我最早了解到 sigslot 大概是在 2007年 左右，当时在QT中大量使用了 sigslot 的概念。 现在 WebRTC 中也大量使用了 sigslot 这种机制来处理底层的事件。它对我们阅读WebRTC代码至关重要。本篇文章就详细介绍一下 sigslot。&lt;/p&gt;
    
    </summary>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/categories/WebRTC/"/>
    
    
      <category term="slot" scheme="https://blog.avdancedu.com/tags/slot/"/>
    
  </entry>
  
  <entry>
    <title>聊聊C++中的类型转换</title>
    <link href="https://blog.avdancedu.com/670ef31f/"/>
    <id>https://blog.avdancedu.com/670ef31f/</id>
    <published>2020-07-07T01:33:24.000Z</published>
    <updated>2020-07-07T13:48:35.933Z</updated>
    
    <content type="html"><![CDATA[<p>在C语言中我们经常要做类型转换，例如malloc函数分配内存时需要从<code>void *</code>转换成你指定的类型指针。如下面这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* block = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure><p>上面的代码是将<code>void*</code>转换成<code>int*</code>，这种转换方式在C语言中称为<code>强制转换</code>。它的好处是简洁，灵活；缺点是需要人来决定转换后类型是否正确，因此对开发人员的要求是很高的。</p><a id="more"></a><h2 id="C-的四种类型转换"><a href="#C-的四种类型转换" class="headerlink" title="C++的四种类型转换"></a>C++的四种类型转换</h2><p>C++觉得C的强制转换方式不是很友好，尤其是没法通过编译器或运行时检测工具来提供帮助，光靠人的能力来判断是很不靠谱的事儿。</p><p>而且相对于C来说，分析C++程序的运行轨迹要比分析C复杂得多。因此C++提出了四种新的类型转换方法，这四种类型转换方法分别是：<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>以及<code>reinterpret_cast</code>。</p><p>下面我们就来对这四种类型转换方法做下详细讨论。</p><h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><p>static_cast主要用于不同类型变量之间的转换及左值转右值等。比如说double转int就需要用static_cast转换。我们来举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不同类型之间的转换</span></span><br><span class="line"><span class="keyword">double</span> d = <span class="number">10.1</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(d);</span><br><span class="line"></span><br><span class="line"><span class="comment">//左值转右值</span></span><br><span class="line"><span class="keyword">int</span> lv = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp; rv = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&amp;&amp;&gt;(lv);</span><br></pre></td></tr></table></figure><blockquote><p>这里需要注意的是：int 转 double是隐式转换，右值转左值也是隐性转换，所以对这两种情况是不需要用static_cast进行显示转换的。</p></blockquote><p>上面我们说的是普通类型的转换。而对于类对象来说，static_cast不能直接将一种类对象转成另一种类对象。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    b = <span class="keyword">static_cast</span>&lt;B&gt;(a); <span class="comment">//不允许static_cast将一个对象转成另一个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像上面这种用static_cast将A类型的对象转成B类型对象是不允许的。但你可以利用static_cast将基类指针/引用转成子类指针/引用。如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">A ca;</span><br><span class="line">B &amp; crb = <span class="keyword">static_cast</span>&lt;B&amp;&gt;(ca);</span><br><span class="line">...</span><br><span class="line">A * pa = <span class="keyword">new</span> A();</span><br><span class="line">B * cpb = <span class="keyword">static_cast</span>&lt;B*&gt;(pa);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>但这里有个前提条件，即只有有父子关系的类之间才可以做如上转换，否则编译失败。还有，虽然以上两种使用static_cast的方式都可以编译通过，但用户自己要防止越界访问的问题。</p><p>static_cast除了上面讨论的几种情况外，还有一点需要牢记，即<strong>static_cast不允许不同类型之间指针/引用的转换(有父子关系的类对象除外)</strong>。看个具体的例子：：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">double</span> *pd  = <span class="keyword">new</span> <span class="keyword">double</span>();</span><br><span class="line"><span class="keyword">int</span> * pi = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(pd); <span class="comment">//报错</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面的代码在编译时会报错，因为它不允许不同类型之间的指针或引用转换。对于有父子关系的类对象之间之所以可以转换是因为static_cast把它们当做同一类型看待了。</p><p>所以总结来说，static_cast主要用于不同类型变量之间的转换，指针和引用的转换不能用static_cast，而应该用reinterpret_cast。</p><h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h3><p>reinterpret_cast类似于C语言中不同类型指针间的类型转换，最接近于C的强制转换。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">double</span> *pd  = <span class="keyword">new</span> <span class="keyword">double</span>();</span><br><span class="line"><span class="keyword">int</span> * pi = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(pd);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面的代码是将<code>double*</code> 转成 <code>int*</code>。如果你使用static_cast做这种转换转换是不允许的，但改用reinterpret_cast就一切正常。 当然，如果你用reinterpret_cast做static_cast善长的变量类型转换也会报错。从上面的描述我们应该知道reinterpret_cast与static_cast之间的区别了。</p><p>如果我们像下面这样用reinterpret_cast去做类型变量的转换，编译器会报错：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">10.1</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>&gt;(d);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这样的转换是绝对不允许的。</p><p>reinterpret_cast还有一个特点，它可以将指针转成长整型，也可以将长整型转成指针。如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">long</span> ll = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">long</span>&gt;(&amp;a);</span><br><span class="line"><span class="keyword">double</span> *dd = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">double</span>*&gt;(ll);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面是将一个<code>int*</code>转成long型，又将long型转成<code>double*</code>，这些都是reinterpret_cast善长做的转换。</p><p>reinterpret_cast对于对象指针/引用的转换与普通类型的指针/引用转换是一样的。因此不同类型的对象指针/引用可以随意转换，但转换后是否会引起问题它不关心，这要由开发人员自己保证。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A * pa = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">B b;</span><br><span class="line">B &amp; rb = B();</span><br><span class="line"></span><br><span class="line">C * cc = <span class="keyword">reinterpret_cast</span>&lt;C*&gt;(pa);</span><br><span class="line">C &amp; rcc = <span class="keyword">reinterpret_cast</span>&lt;C&amp;&gt;(rb);</span><br></pre></td></tr></table></figure><p>总结一下，reinterpret_cast是对指针/引用的转换，其中必须至少有一个是指针或引用，否则它会报错。</p><h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h3><p>这个比较简单，它的作用是去掉<strong>指针/引用</strong>中的const限制。这里要注意的是被转换的一定是指针/引用的const，而常数的const是不能去掉的。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b  = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&gt;(a);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面的代码是想通过const_cast将常数的const去掉？这是决对不可以的！！！编译器一定会报错。</p><p>而如果是加了const的指针/引用就没问题了，我们再来一个列子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * pca = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">int</span> * pa = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(pca);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>将一个const 指针转换成非const指针正是const_cast做的事儿。</p><p>我们再来想一种case，是否可以将一种类型的const指针转换成另一种类型的非const指针呢？如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * pca = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">double</span> * pa = <span class="keyword">const_cast</span>&lt;<span class="keyword">double</span>*&gt;(pca);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这样也是不允许的。对于const_cast来说，它只能将同一类型的const 指针/引用 转成非const指针/引用。</p><p>所以我们这里总结一下，const_cast是一个专门去掉同一类型的const限制的类型转换方法。它不如static_cast和reinterpret_cast应用的广泛。</p><h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><p>这个转换方法限制比较多，一、它只能处理类对象；二、它只能处理指针；三、它只能用于将子对象转换成父对象这样的操作。我们来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">A * a;</span><br><span class="line">B * b =<span class="keyword">new</span> B();</span><br><span class="line">a = <span class="keyword">dynamic_cast</span>&lt;A*&gt;(b);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>只有上面这一种情况可以编译成功，其它情况都会失败！</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>下面我们总结一下这四种类型转换方法。四种转换方法中，用的比较多的是static_cast和reinterpret_cast这两种转换方法。</p><p>static_cast主要用于普通类型变量的转换，如double到int的转换，或左值转右值。当然它也可以在父对象与子对象之间进行指针转换。</p><p>reinterpret_cast主要用于不同类型指针/引用间的转换。也可以将指针/引用转成长整型或将长整型转成指针类型。但不可以像static_cast一样在两个不同的类型变量间转换。也就是说reinterpret_cast在转换时必须有一个是指针/引用。</p><p>const_cast就比较简单了，它只能将同一类型的const指针转成同一类型的非const指针。</p><p>dynamic_cast只能用于有父子关系的类对象之间的转换，而且只能用于将子对象转换成父对象。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">C++高阶知识：深入分析移动构造函数及其原理</a><br><a href="https://avdancedu.com/9683d88/" target="_blank" rel="noopener">细说智能指针</a><br><a href="https://avdancedu.com/5e7916e3/" target="_blank" rel="noopener">重学C/C++中的const</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在C语言中我们经常要做类型转换，例如malloc函数分配内存时需要从&lt;code&gt;void *&lt;/code&gt;转换成你指定的类型指针。如下面这样：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;* block = (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;*)&lt;span class=&quot;built_in&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的代码是将&lt;code&gt;void*&lt;/code&gt;转换成&lt;code&gt;int*&lt;/code&gt;，这种转换方式在C语言中称为&lt;code&gt;强制转换&lt;/code&gt;。它的好处是简洁，灵活；缺点是需要人来决定转换后类型是否正确，因此对开发人员的要求是很高的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="https://blog.avdancedu.com/categories/C-C/"/>
    
    
      <category term="类型转换" scheme="https://blog.avdancedu.com/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>C++高阶知识：深入分析移动构造函数及其原理</title>
    <link href="https://blog.avdancedu.com/a39d51f9/"/>
    <id>https://blog.avdancedu.com/a39d51f9/</id>
    <published>2020-07-04T04:48:44.000Z</published>
    <updated>2020-07-07T13:53:51.397Z</updated>
    
    <content type="html"><![CDATA[<p>移动构造函数是C++11中新增加的一种构造函数，其作用是提高程序性能。今天我们就细扒一下它的工作原理，看看它是怎么提高性能的。</p><a id="more"></a><h2 id="移动构造函数的由来"><a href="#移动构造函数的由来" class="headerlink" title="移动构造函数的由来"></a>移动构造函数的由来</h2><p>在讲解移动构造函数之间，我们先来了解一下在没有移动构造函数之前哪里有性能瓶颈吧。我们来举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        A()&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A construct..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            ptr_ = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        A(<span class="keyword">const</span> A &amp; a)&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A copy construct ..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            ptr_ = <span class="keyword">new</span> <span class="keyword">int</span>();</span><br><span class="line">            <span class="built_in">memcpy</span>(ptr_, a.ptr_, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~A()&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A deconstruct ..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(ptr_)&#123;</span><br><span class="line">                <span class="keyword">delete</span> ptr_;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A &amp; a) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" A operator= ...."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> * <span class="title">getVal</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ptr_;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> *ptr_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;A&gt; vec;</span><br><span class="line">    vec.push_back(A());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//clang++ -g -o testmove test_move.cpp</span></span><br></pre></td></tr></table></figure><p>上面这段代码很简单对吧，就是定义了一个普通的类A。在main函数中创建一个vector，然后用A类创建一个对象，并把它放入到vector中。这样的程序在C++中是很常见，但就是这样很常见的代码确有非常大的性能问题。为什么呢？因为在将A对象放入vector时，在vector内部又创建了一个A对象，并调用了其拷贝构造函数进行了深拷贝。</p><p>我们看一下上面代码运行的结果就一目了然了，其结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A construct...          &#x2F;&#x2F;main中创建的A对象</span><br><span class="line">A copy construct ...    &#x2F;&#x2F;vector内部创建的A对象</span><br><span class="line">A deconstruct ...       &#x2F;&#x2F;vector内部创建的A对象被析构</span><br><span class="line">A deconstruct ...       &#x2F;&#x2F;main中创建的A对象析构</span><br></pre></td></tr></table></figure><p>上面的运行结果印证了我们之前的讨论，在vector内部确实又创建了一个A对象。如果在A对象中分配的是一个比较大的空间，且vector中要存放大量的A对象时（如 100000个)，就会不断的做分配/释放堆空间的操作，这会造成多在的性能消耗呀！</p><p>有什么办法可以解决这个问题呢？这就要用到我们今天要讲的移动构造函数了。</p><h2 id="移动构造函数的使用"><a href="#移动构造函数的使用" class="headerlink" title="移动构造函数的使用"></a>移动构造函数的使用</h2><p>从C++11开始，类中不光可以有构造函数、拷贝构造函数，还增加了一种新的构造函数即移动构造函数。移动构造函数起什么作用呢？就像它的名子一样，它可以实现指针的移动，即可以将一个对象中的指针成员转移给另一个对象。指针成员转移后，原对象中的指针成员一般要被设置为NULL，防止其再被使用。</p><p>还是以我们上面的代码为例，如果我们有了移动构造函数，那么在将A对象push到vector时，vector内部虽然还是会再分A对象，但在进行数据的拷贝时就不是深拷贝了，而变成了浅拷贝，这样就大大提高了程序的执行效率。</p><p>如何为A增加移动构造函数呢？我们来看一下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        A(A &amp;&amp; a)&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A move construct ..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            ptr_ = a.ptr_;</span><br><span class="line">            a.ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 A 类中增加上面代码即可，上面的代码看起来与普通构造函数好像没什么两样，但你细心观察可以发现该构造函数的参数是 <code>A &amp;&amp; a</code>。咦！<code>&amp;&amp;</code>这在以前还真没见过对吧。它表示的是C++中的右值，也就是只有创建A对象时传入的是右值才会执行该构造函数。</p><p>对于右值后面我们还会做详细介绍，现在我们只要知道要想让这个函数起作用，就必须传给它一个右值就可以了。如么问题来了，我们这个例子中如何传递给它一个右值呢？这就要用到 std::move 函数了。</p><p>std::move可以将任何一值变成右值，所以我们不管3721，在创建A对象时直接调用std::move”造”个右值给它就好了。于是我们修改main代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;A&gt; vec;</span><br><span class="line">    vec.push_back(<span class="built_in">std</span>::<span class="built_in">move</span>(A()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经这样修后，我们运行一下程序看现在它的结果是什么样子吧。结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A construct...          &#x2F;&#x2F;main中创建A对象</span><br><span class="line">A move construct ...    &#x2F;&#x2F;vector内部通过移动构造函数创建A对象，减少了对堆空间的频繁操作</span><br><span class="line">A deconstruct ...       &#x2F;&#x2F;释放vector中的A对象</span><br><span class="line">A deconstruct ...       &#x2F;&#x2F;释放main中创建的A对象</span><br></pre></td></tr></table></figure><p>从上面的结果我们可以看出我们新增加的移动构造函数确实被调用了，这样就大大减了频繁对堆空间的分配/释放操作，从而提高了程序的执行效率。这里需要注意的是，在移动构造函数操作之后原A对象的指针地址已经指向NULL了，因此此时就不能再通过其访问之前的堆空间了。</p><h2 id="C-的左值与右值"><a href="#C-的左值与右值" class="headerlink" title="C++的左值与右值"></a>C++的左值与右值</h2><p>右值是C++从C继承来的概念，最初是指=号右边的值。但现在C++中的右值已经与它最初的概念完全不一样了。在C++中右值指的的临时值或常量，更准确的说法是保存在CPU寄存器中的值为右值，而保存在内存中的值为左值。</p><p>可能有很多同学对计算机系统的底层不太了解，我们这里做一个简单的介绍。计算机是由CPU、内存、主板、总线、各种硬件等组成的，这个大家应该都清楚。而CPU又是由逻辑处理器，算术单元、寄存器等组成的。我们的程序运行时并不是直接从内存中取令运行的，因为内存相对于CPU来说太慢了。一般情况下都是先将一部分指令读到CPU的指令寄存器，CPU再从指令寄存器中取指令然后一条一条的执行。对于数据也是一样，先将数据从内存中读到数据寄存器，然后CPU从数据寄存器读数据。以Intel的CPU为例，它就包括了 EAX、EBX、ECX、EDX…多个通用寄存器，这样就可以让CPU更高效的工作。</p><p>比如说一个常数5，我们在使用它时不会在内存中为其分配一个空间，而是直接把它放到寄存器中，所以它在C++中就是一个右值。再比如说我们定义了一个变量 a，它在内存中会分配空间，因此它在C++中就是左值。那么<code>a+5</code>是左值还是右值呢？当然是右值对吧，因为a+5的结果存放在寄存器中，它并没有在内存中分配新空间，所以它是右值。</p><p>通过上面的描述你就应该对 C++ 中的左值和右值比较清楚了。我们来看个例子吧：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> &amp;&amp; a = <span class="number">5</span>;  <span class="comment">// 正确，5会被直接存放在寄存器中，所以它是右值</span></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;&amp; c = b;  <span class="comment">// 错误，b在内存中有空间，所以是右值；右值不能赋值给左值</span></span><br><span class="line">    <span class="keyword">int</span> &amp;&amp; d = b + <span class="number">5</span>; <span class="comment">// 正确，虽然 b 在内存中，但 b+5 的结果放在寄存器中，它没有在内存中分配空间，因此是右值 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C++中使用<code>&amp;&amp;</code>表示右值引用，在上面的例子中，我首先将常数5赋值给右值引用a，因为常数5是右值，所以这条语句可以编译成功；紧接着我定义了变量b，因为它是左值，所以当将b赋值给右直引用c时，编译器会报错；最后一行将<code>b+5</code>赋值给右值引用d，由于<code>b+5</code>不会在内存中占用空间所以这也是右值，因此最后一句编译也没有任何问题。</p><p>接下来我们看一个有意思的情况，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">int</span> &amp;&amp; e = a;</span><br><span class="line">..</span><br></pre></td></tr></table></figure><p>这种情况是否是合法的呢？实际上当你这么做的时候编译器会报错，因为a是左值而e必须接收右值。那有没有办法将一个左值转成右值呢？这个问题我们前面其实已经回答过了，通过std::move就可以解决这个问题。我们来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">int</span> &amp;&amp; e = <span class="built_in">std</span>::<span class="built_in">move</span>(a);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>之前我们直接将a赋值给e是肯定不行的，但上面的操作编译器就不会报错了，因为通过std::move可以将一个左值转成右值。但这里有一点需要特别注意：<strong>e虽然接收的必须是右值，但它本身是左值。换句话说e是一种特殊的变量，它是只能接收右值的变量。我们再从左值的本质来看，e也是占内存空间的，所以它肯定是左值。</strong></p><h2 id="std-move的实现"><a href="#std-move的实现" class="headerlink" title="std::move的实现"></a>std::move的实现</h2><p>上面我们已经看到了std::move的神奇之处，你可能很好奇std::move是如何做到的呢？实际上std::move就是一个类型转换器，将左值转换成右值而以。我们来看一下它的实现吧！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> static_case&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>std::move的实现还是挺简单的就这么几行代码，但要理解这几行代码可不容易。下面我们就来对它做下详细分析。</p><h3 id="通用引用"><a href="#通用引用" class="headerlink" title="通用引用"></a>通用引用</h3><p>首先我们来看一下move的输入参数，move的输入参数类型称为通用引用类型。什么是通用引用呢？就是它既可以接收左值也可以接收右值。我们来看一下例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"the value is "</span>&lt;&lt; param &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> &amp;&amp; b = <span class="number">5</span>;   <span class="comment">//通用引用，可以接收右值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> &amp;&amp; c = a;    <span class="comment">//错误，右值引用，不能接收左值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> &amp;&amp; d = a;   <span class="comment">//通用引用，可以接收左值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;&amp; e = a; <span class="comment">//错误，加了const就不再是通用引用了</span></span><br><span class="line"></span><br><span class="line">    func(a);         <span class="comment">//通用引用，可以接收左值</span></span><br><span class="line">    func(<span class="number">10</span>);        <span class="comment">//通用引用，可以接收右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面代码中有两种类型的通用引用: 一种是auto，另一种是通过模板定义的T&amp;&amp;。实际上auto就是模板中的T，它们是等价的。下面我们就对这段代码做下详细解读。</p><p>代码中的 a 是个左值，因为它在内存中会分配空间，这应该没什么异义；b 是通过引用。为什么呢？因为通用引用有两个条件：一，必须是T&amp;&amp;的形式，由于auto等价于T，所以auto &amp;&amp; 符合这个要求；二，T类型要可以推导，也就是说它必须是个模板，而auto是模板的一种变型，因此b是通用引用。通用引用即可以接收左值，也可以接收右值，所以b=5是正确的；c不是通用引用，因为它不符合T&amp;&amp;的形式。所经第三行代码是错误的，右值引用只能接收右值；d是通用引用，所以给它赋值a是正确的；e不是通用引用，它多了一个const已不符合T&amp;&amp; 的形式，所以给它左值肯定会出错；最后两个函数调用的形参符合 T&amp;&amp;，又因是模板可以进行类型推导，所以是通用引用，因此给它传左值和右值它都能正确接收。</p><h3 id="模板的类型推导"><a href="#模板的类型推导" class="headerlink" title="模板的类型推导"></a>模板的类型推导</h3><p>通用引用好强大呀！它既可以接收左值又可以接收右值，它是如何做到的呢？这就要讲讲模板的类型推导了。</p><p>模板的类型推导规则还是蛮复杂的，这里我们只简要说明一下，有兴趣的同学可以查一下C++11的规范。我们还是举个具体的例子吧：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br><span class="line"></span><br><span class="line">f(expr);</span><br></pre></td></tr></table></figure><p>上面这个例子是函数模板的通用例子，其中T是根据f函数的参数推到出来的，而ParamType则是根据 T 推导出来的。T与ParamType有可能相等，也可能不等，因为ParamType是可以加修饰的。我们看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;         <span class="comment">// x是int</span></span><br><span class="line">    <span class="keyword">int</span> &amp; rr = x;       <span class="comment">// rr是 int &amp;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> cx = x;   <span class="comment">// cx是const int</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x;  <span class="comment">// rx是const int &amp;</span></span><br><span class="line">    <span class="keyword">int</span> *pp = &amp;x;       <span class="comment">// pp是int *</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面是传值的模板，由于传入参数的值不影响原值，所以参数类型退化为原始类型</span></span><br><span class="line">    f(x);               <span class="comment">// T是int</span></span><br><span class="line">    f(cx);              <span class="comment">// T是int</span></span><br><span class="line">    f(rx);              <span class="comment">// T是int</span></span><br><span class="line">    f(rr);              <span class="comment">// T是int</span></span><br><span class="line">    f(pp);              <span class="comment">// T是int*，指针比较特殊，直接使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面是传引用模板, 如果输入参数类型有引用，则去掉引用;如果没有引用，则输入参数类型就是T的类型</span></span><br><span class="line">    func(x);            <span class="comment">// T为int</span></span><br><span class="line">    func(cx);           <span class="comment">// T为const int</span></span><br><span class="line">    func(rx);           <span class="comment">// T为const int</span></span><br><span class="line">    func(rr);           <span class="comment">// T为int</span></span><br><span class="line">    func(pp);           <span class="comment">// T是int*，指针比较特殊，直接使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面是通用引用模板，与引用模板规则一致</span></span><br><span class="line">    function(x);        <span class="comment">// T为int&amp;</span></span><br><span class="line">    function(<span class="number">5</span>);        <span class="comment">// T为int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中可以将类型推导分成两大类：其中类型不是引用也不是指针的模板为一类; 引用和指针模板为另一类。</p><p>对于第一类其推导时根据的原则是，函数参数传值不影响原值，所以无论你实际传入的参数是普通变量、常量还是引用，它最终都退化为不带任何修修饰的原始类型。如上面的例子中，<code>const int &amp;</code>类型传进去后，退化为int型了。</p><p>第二类为模板类型为引用（包括左值引用和右值引用）或指针模板。这一类在类型推导时根据的原则是去除对等数量的引用符号，其它关键字照般。还是我们上面的例子，<code>func(x)</code>中x的类型为 <code>int&amp;</code>，它与<code>T&amp;</code>放在一起可以知道T为int。另一个例子<code>function(x)</code>，其中x为<code>int&amp;</code>它与T&amp;&amp; 放在一起可知T为<code>int&amp;</code>。</p><p>根据推导原则，我们可以知道通用引用最终的结果是什么了，左值与通用引用放在一推导出来的T仍为左值，而右值与通用引用放在一起推导出来的T仍然为右值。</p><h3 id="move-的返回类型"><a href="#move-的返回类型" class="headerlink" title="move 的返回类型"></a>move 的返回类型</h3><p>实际上上面通过模板推导出的T与move的返回类型息息相关的，要讲明白这一点我们先要把move的返回类型弄明白。下面我们就来讨论一下move的返回类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;</span><br></pre></td></tr></table></figure><p>move的返回类型非常奇特，我们在开发时很少会这样写，它表示的是什么意思呢？</p><p>这就要提到C++的另外一个知识点，即类型成员。你应该知道C++的类成员有成员函数、成员变量、静态成员三种类型，但从C++11之后又增加了一种成员称为类型成员。类型成员与静态成员一样，它们都属于类而不属于对象，访问它时也与访问静态成员一样用<code>::</code>访问。</p><p>了解了这点，我们再看move的返类型是不是也不难理解了呢？它表达的意思是返回remove_reference类的type类型成员。而该类是一个模板类，所以在它前面要加typename关键字。</p><p>remove_reference看着很陌生，接下来我们再分析一下remove_reference类，看它又起什么作用吧。其实，通过它的名子你应该也能猜个大概了，就是通过模板去除引用。我们来看一下它的实现吧。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T type;  <span class="comment">//定义T的类型别名为type</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&lt;T&amp;&gt; //左值引用</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&lt;T&amp;&amp;&gt; //右值引用</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就是remove_reference类的代码，在C++中struct与class基本是相同的，不同点是class默认成员是private，而struct默认是public，所以使用struct代码会写的更简洁一些。</p><p>通过上面的代码我们可以知道，经过remove_reference处理后，T的引用被剔除了。假设前面我们通过move的类型自动推导得到T为int&amp;&amp;，那么再次经过模板推导remove_reference的type成员，这样就可以得出type的类型为int了。</p><p>remove_reference利用模板的自动推导获取到了实参去引用后的类型。现在我们再回过来看move函数的时候是不是就一目了解了呢？之前无法理解的5行代码现然变成了这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int &amp;&amp; move(int&amp;&amp; &amp;&amp; t)&#123;</span><br><span class="line">    return static_case&lt;int&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;或</span><br><span class="line">int &amp;&amp; move(int&amp; &amp;&amp; t)&#123;</span><br><span class="line">    return static_case&lt;int&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经上面转换后，我们看这个代码就清晰多了，从中我们可以看到move实际上就是做了一个类型的强制转换。如果你是左值引用就强制转换成右值引用。</p><h3 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h3><p>上面的代码我们看起来是简单了很多，但其参数<code>int&amp; &amp;&amp;</code>和<code>int &amp;&amp; &amp;&amp;</code>还是让人觉得很别扭。因为C++编译器根本就不支持这两种类型。咦！这是怎么回事儿呢？</p><p>到这里我们就要讲到最后一个知识点引用折叠了。在C++中根本就不存 <code>int&amp; &amp;&amp;</code>、<code>int &amp;&amp; &amp;&amp;</code>这样的语法，但在编译器内部是能将它们识别出来的。换句话说，编译器内部能识别这种格式，但它没有给我们提供相应的接口(语法）。</p><p>实际上，当编译器遇到这类形式的时候它会使用引用折叠技术，将它们变成我们熟悉的格式。其规则如下：</p><ul><li><code>int &amp; &amp;</code> 折叠为 <code>int&amp;</code></li><li><code>int &amp; &amp;&amp;</code> 折叠为 <code>int&amp;</code></li><li><code>int &amp;&amp; &amp;</code> 折叠为 <code>int&amp;</code></li><li><code>int &amp;&amp; &amp;&amp;</code> 折叠为 <code>int &amp;&amp;</code></li></ul><p>总结一句话就是左值引用总是折叠为左值引用，右值引用总是折叠为右值引用。</p><p>经过这一系列的操作之后，对于一个具体的参数类型<code>int &amp; a</code>，std::move就变成了下面的样子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> &amp;&amp; <span class="title">move</span><span class="params">(<span class="keyword">int</span>&amp; t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> static_case&lt;<span class="keyword">int</span>&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一下我们就清楚它在做什么事儿了哈！</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上就是C++高阶知识移动构造函数及其原理的分析。在本文中我首先向你介绍了拷贝构造函数在某些场景下会引起程序性能严重下降，然后讲解了如何使用移动构造函数和std::move函数改善性能。在文章的最后，我带你深入剖析了std::move是如何实现的，最终我们发现它原来就是实现了一个自适应类型的强制类型转换的功能。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://avdancedu.com/9683d88/" target="_blank" rel="noopener">细说智能指针</a><br><a href="https://avdancedu.com/5e7916e3/" target="_blank" rel="noopener">重学C/C++中的const</a><br><a href="https://avdancedu.com/670ef31f/" target="_blank" rel="noopener">聊聊C++中的类型转换</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;移动构造函数是C++11中新增加的一种构造函数，其作用是提高程序性能。今天我们就细扒一下它的工作原理，看看它是怎么提高性能的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="https://blog.avdancedu.com/categories/C-C/"/>
    
    
      <category term="移动构造函数" scheme="https://blog.avdancedu.com/tags/%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>细说智能指针</title>
    <link href="https://blog.avdancedu.com/9683d88/"/>
    <id>https://blog.avdancedu.com/9683d88/</id>
    <published>2020-07-01T03:49:25.000Z</published>
    <updated>2020-07-07T13:57:16.865Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们来聊聊C++的智能指针。C++从1983年诞生到现在已经有30多年历史了，为什么到现在还能如此流行呢(排名第四，2020年6月<a href="https://hellogithub.com/report/tiobe/" target="_blank" rel="noopener">HelloGitHub榜单</a>)？因为它具有很多其它语言所不具备的优势，比如说执行速度快，控制力更强等。同样的，有更多的同学会选择用Java(排名第二)等语言，这是因为它相对C++来说，它更简单，易上手，不用担心内存泄漏！</p><p>确实，<strong>内存泄漏</strong>在很长的一段时间里是影响人们学习C++的一个最重要的原因。不过C++也在不断进步中，智能指针的出现就大大降低了内存泄漏发生的风险。</p><p>下面我们就来细聊一下C++智能指针的方方面面，通过本文让你真正掌握C++智能指针。</p><a id="more"></a><h2 id="内存泄漏的产生"><a href="#内存泄漏的产生" class="headerlink" title="内存泄漏的产生"></a>内存泄漏的产生</h2><p>在C++中内存的分配与释放都是手工操作的(分配内存用<code>new</code>，释放内存用<code>delete</code>)，这种方式本身就很容易产生内存泄漏。因为人们在开发过程中需要内存时很自然的就用new分配一块，但这块内存什么时候释放就说不好了，有可能用完马上就释放，也有可能要等待一个周期才能释放等等。而且随着时间的推移，代码越来越大，需要被释放的内存被遗忘的可能性也就更大。</p><p>我来看一下具体的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *pVal = <span class="keyword">new</span> <span class="keyword">int</span>();</span><br><span class="line">    *pVal = <span class="number">10</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(*pVal == <span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;      <span class="comment">//这里会产生内存泄漏</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">delete</span> pVal;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，使用new在堆空间分配了一个整型大小的空间，在函数结束时通过delete将分配的内存释放。但当<code>pVal==10</code>时，函数没有释放内存就直接退出了，此时就产生了内存泄漏。</p><p>有的同学可能会说，谁会写出这么蠢的代码呢？实际上这样的代码在C++项目中经常出现，很多老手有时都犯这样的错误。你之所以可以一眼就看出上面代码的问题，是因为我将代码简化了。在真实的场景中，由于代码量比较大，你就没那么容易一眼看出问题了。</p><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>上面我们已经看到了，通过new/delete这种方式申请/释放内存存在着很大弊端，有没有什么方法可以在使用时申请内存，在不需要的时自动释放它呢？当然有，<strong>这就是智能指针</strong>。</p><p>下面我们来看看智能指针是怎么做到的吧。实际上，智能指针最朴素的想法是利用类的<code>析构函数</code>和<code>函数栈</code>的自动释放机制来自动管理指针，即用户只要按需分配堆空间，堆空间的释放由智能指针帮你完成。</p><p>在解释这个原理之前，我们先来补充两个基本知识，一是构造函数与析构函数；另一个是堆空间与栈空间。首先来看构造函数与析构函数。</p><h3 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h3><p>类对象的构造与析构是C++最基本的概念了，当创建对象时其构造函数会被调用，销毁对象时其析构函数会被调用。我们来举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        MyClass()&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"construct func"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~MyClass()&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"deconstruct func"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"create MyClass object ..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    MyClass *myclass = <span class="keyword">new</span> MyClass();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"release MyClass object ..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> myclass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译命令 clang++ -g -o myclass test_class.cpp</span></span><br></pre></td></tr></table></figure><p>我们将上面的代码编译执行后，会得到下面的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create MyClass object ...</span><br><span class="line">construct func</span><br><span class="line">release MyClass object ...</span><br><span class="line">deconstruct func</span><br></pre></td></tr></table></figure><p>通过其结果就可以证明我们上面的结论了，即<strong>创建对象时其构造函数会被调用；销毁对像时其析构函数会被调用</strong>。</p><p>下面我们再来看看堆空间与栈空间。</p><h3 id="堆空间与栈空间"><a href="#堆空间与栈空间" class="headerlink" title="堆空间与栈空间"></a>堆空间与栈空间</h3><p>我们以Linux为例，在Linux系统上每个进程都有自己的虚似地址空间，如果你的系统是32位的，那它可以访问的内存空间是：2^32，也就是4G大小。</p><p>在这么大的空间中，内存被分成了几块：内核块、代码块、BSS块、堆空间，栈空间等。</p><ul><li>内核块，由Linux内核使用，应用层不可以访问。</li><li>代码块，用户的二进制应用程序，只读。</li><li>BSS块，全局量，全局常量等。</li><li>堆空间，用new分配的动态空间，可以分配大块内存。</li><li>栈空间，用于函数调用，分配临时变量等。其空间大小有限，<strong>当函数执行完成后其内存会自动回收</strong>。</li></ul><p>其中栈空间有个特点，当函数执行完后，它所用到的栈空间会被自动释放，而这正是智能指针所需要的。当它与构造函数/析构函数结合到一起时就可以实现智能指针了。下面我们来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoPtr</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">AutoPtr</span><span class="params">(T *ptr = <span class="literal">nullptr</span>)</span></span>&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"set new object"</span> &lt;&lt; ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            _ptr = ptr;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~AutoPtr()&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"delete object"</span> &lt;&lt; _ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(_ptr != nulptr)</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T * _ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        MyClass()&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"construct MyClass func"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~MyClass()&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"deconstruct MyClass func"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">AutoPtr&lt;MyClass&gt; <span class="title">myclass</span><span class="params">(<span class="keyword">new</span> MyClass())</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译命令 clang++ -g -o autoptr test_autoptr.cpp</span></span><br></pre></td></tr></table></figure><p>上面例子执行的结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">construct MyClass func</span><br><span class="line">set new object, 0x7f8e25c028c0</span><br><span class="line">delete object, 0x7f8e25c028c0</span><br><span class="line">deconstruct MyClass func</span><br></pre></td></tr></table></figure><p>在上面main函数中创建了一个智能指针<code>AutoPtr&lt;MyClass&gt; myclass</code>，其在堆空间分配了一个MyClass对象交由智能指针管理，即<code>myclass(new MyClass())</code>。当main函数结束时，它会调用智能指针的析构函数，析构函数中执行了<code>delete</code>操作，最终将之前new出来的myclass对象释放掉了。</p><p>通过这个例子我们可以知道，有了智能指针我们就不用再担心内存泄漏了。对于C++开发同学来说像不像中了大奖一样高兴？不过上面的AutoPtr还称不上真正的智能指针，因为它只实现了智能指针最基本的一部分功能，我们还需要对它不断完善才行。</p><h2 id="AutoPtr智能指针"><a href="#AutoPtr智能指针" class="headerlink" title="AutoPtr智能指针"></a>AutoPtr智能指针</h2><p>上面实现的智能指针有什么问题呢？最大的问题就是它不能像真正的指针一样操作，比如说不能执行<code>xxx-&gt;xxx()</code>、<code>*xxx</code>等操作。下面我们就为AutoPtr重载这两个操作符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改AutoPtr，增加 -&gt; 和 * 操作符</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoPtr</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    T* <span class="keyword">operator</span> -&gt; ()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    T&amp; <span class="keyword">operator</span> * ()&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;(<span class="keyword">this</span>-&gt;_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改MyClass类，增加print方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加测试例子</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">AutoPtr&lt;MyClass&gt; <span class="title">myclass</span><span class="params">(<span class="keyword">new</span> MyClass())</span></span>;</span><br><span class="line">    myclass-&gt;<span class="built_in">print</span>();</span><br><span class="line">    (*myclass).<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行该程序，我们可以得到下面的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">construct MyClass func</span><br><span class="line">set new object,0x7f94f44028c0</span><br><span class="line">Hello world!</span><br><span class="line">Hello world!</span><br><span class="line">delete object，0x7f94f44028c0</span><br><span class="line">deconstruct MyClass func</span><br></pre></td></tr></table></figure><p>通过上面的例子我们可以看到AutoPtr确实像一个真正的指针了，既可以通过<code>-&gt;</code>调用MyClass方法，又可以通过<code>*</code>调用MyClass方法。</p><h2 id="AutoPtr缺陷"><a href="#AutoPtr缺陷" class="headerlink" title="AutoPtr缺陷"></a>AutoPtr缺陷</h2><p>虽然上面的AutoPtr实现看着很不错，不过它有非常致命的问题。当两个AutoPtr指针指向同一块堆空间时，在释放资源时会引起crash。咱们看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加测试例子</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">AutoPtr&lt;MyClass&gt; <span class="title">myclass</span><span class="params">(<span class="keyword">new</span> MyClass())</span></span>;</span><br><span class="line">    AutoPtr&lt;MyClass&gt; newPtr = myclass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你在main函数中让两个AutoPtr指向同一块堆空间时就会引起crash。之所以会出现这个问题，是因为堆空间被释放了两次。上面程序的执行结果就可以推出这个结论：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">construct MyClass func</span><br><span class="line">set new object,0x7fdecfc028c0</span><br><span class="line"></span><br><span class="line">delete object，0x7fdecfc028c0     &#x2F;&#x2F;释放第二个对象</span><br><span class="line">deconstruct MyClass func</span><br><span class="line"></span><br><span class="line">delete object，0x7fdecfc028c0     &#x2F;&#x2F;释放第一个对象</span><br><span class="line">deconstruct MyClass func</span><br><span class="line">malloc: *** error for object 0x7fdecfc028c0: pointer being freed was not allocated &#x2F;&#x2F;0x7fdecfc028c0这个空间已经被释放过一次了</span><br></pre></td></tr></table></figure><p>通过上面的运行结果我们可以知道，创建myclass智能指针时它指向了<code>new MyClass</code>所分配的空间。紧接着，程序使用默认<code>=</code>运算符将myclass中的全部内容赋值给newPtr。此时newPtr的<code>_ptr</code>成员会与myclass的<code>_ptr</code>成员指向同一块堆空间(由于使用了默认<code>=</code>运算符，所以过程没有显示出来)。</p><p>当main函数结束时，它会按次序依次调用newPtr的析构函数和myclass的析构函数，所以我们可以看到有两次”delete object，0x7fdecfc028c0”。在C++中，如果对同一地址释放多次就会引起crash，所以我们在显示结果的最后一行看到了”pointer being freed was not allocated” 这条信息表示的就是重复释放了。</p><p>因此我们必须对 AutoPtr 继续改进，防止出现重复释放的情况。如何才能防止重复释放呢？</p><h2 id="谁来独享所有权？"><a href="#谁来独享所有权？" class="headerlink" title="谁来独享所有权？"></a>谁来独享所有权？</h2><p>我们可以想到的最简单的办法是当有多个智能指针指向同一块堆空间时，只能有一个智能指针拥有所有权。什么意思呢？就是这块堆空间的释放只能由其中的一个来完成。</p><h3 id="允许共享，独占所有权"><a href="#允许共享，独占所有权" class="headerlink" title="允许共享，独占所有权"></a>允许共享，独占所有权</h3><p>怎么才能让众多智能指针中的一个拥有所有权呢？简单的办法是在AutoPtr上加个owner就好了。我们将上面的代码修改如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    explicit AutoPtr(T *ptr = nullptr):_ptr(ptr), _owner(true)&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoPtr(AutoPtr&lt;T&gt; &amp; autoptr):_ptr(autoptr._ptr), _owner(<span class="literal">false</span>)&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~AutoPtr()&#123;</span><br><span class="line">        <span class="keyword">if</span>(_owner &amp;&amp; _ptr != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoPtr&amp; <span class="keyword">operator</span>=(AutoPtr&lt;T&gt; &amp; autoptr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;autoptr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(_ptr)&#123;</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>-&gt;_ptr = autoptr._ptr;</span><br><span class="line">            _owner = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _ptr;</span><br><span class="line">    <span class="keyword">bool</span> _owner;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>经上面修改后，<code>new MyClass</code>分配的空间就有了具体的owner，所以再执行之前的测试程序就不会crash了。结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">construct MyClass func</span><br><span class="line">set new object,0x7fb9acc028c0</span><br><span class="line">copy construct, 0x7fb9acc028c0</span><br><span class="line">delete object，0x7fb9acc028c0   &#x2F;&#x2F; 调用newPtr 析构</span><br><span class="line">delete object，0x7fb9acc028c0   &#x2F;&#x2F; 调用 myclass 析构</span><br><span class="line">deconstruct MyClass func        &#x2F;&#x2F; 由于myclass是owner，所以才会真正的释放堆空间</span><br></pre></td></tr></table></figure><p>通过上面的修改问题似乎已经得到了解决，但实际的情况是后创建的智能指针更应该是owner，所以我们再做下微调：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoPtr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    explicit AutoPtr(T *ptr = nullptr):_ptr(ptr), _owner(true)&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoPtr(AutoPtr&lt;T&gt; &amp; autoptr):_ptr(autoptr._ptr), _owner(<span class="literal">true</span>)&#123;</span><br><span class="line">        autoptr._owner = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoPtr&amp; <span class="keyword">operator</span>=(AutoPtr&lt;T&gt; &amp; autoptr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;autoptr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(_ptr)&#123;</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>-&gt;_ptr = autoptr._ptr;</span><br><span class="line">            _owner = <span class="literal">true</span>;</span><br><span class="line">            autoptr._owner = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>经上面修改后，后创建的AutoPtr就取代之前的智能指针成为owner了。我们来看一下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">construct MyClass func</span><br><span class="line">set new object,0x7fe67b4028c0</span><br><span class="line">copy construct, 0x7fe67b4028c0</span><br><span class="line">delete object，0x7fe67b4028c0       &#x2F;&#x2F; 调用newPtr析构函数</span><br><span class="line">deconstruct MyClass func            &#x2F;&#x2F; 堆空间被释放掉了</span><br><span class="line">delete object，0x7fe67b4028c0       &#x2F;&#x2F; 调用myclass析构函数</span><br></pre></td></tr></table></figure><p>通过上面最后三行的输出结果我们可以看出，释放空间的顺序发生了变化，说明owner已经变为最近创建的智能指针newPtr了。</p><p>调整后的AutoPtr还有没有问题呢？当然还有，我们再来看一下例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoPtr</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">T* <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="function">AutoPtr&lt;<span class="keyword">int</span>&gt; <span class="title">oldPtr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>))</span></span>;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">AutoPtr&lt;<span class="keyword">int</span>&gt; <span class="title">newPtr</span><span class="params">(oldPtr)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里出现了野指针</span></span><br><span class="line">        *(oldPtr.<span class="built_in">get</span>())= <span class="number">-100</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"the value is "</span> &lt;&lt; *(oldPtr.<span class="built_in">get</span>()) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我在AutoPtr中增加了一个get方法以便获得智能指针所指的堆空间</p></blockquote><p>在上面的代码中，将newPtr放到一个花括号里，这样它就有了自己的栈空间。当跳出花括号后，newPtr就完成了它的使命，然后它会将持有的资源全部释放掉。由于newPtr从oldPtr获得了<code>new int(100)</code>这块堆空间的控制权，所以当newPtr生命周期结束后，堆空间也被回收了。</p><p>但在newPtr被释放掉之后，oldPtr却还能通过get方法访问原来的堆空间，它还能将<code>-100</code>写入了被释放的堆空间。<strong>这是非常可怕的事情，因为oldPtr通过get方法拿到的已经是野指针了。</strong></p><p>因此，多智能指针共享堆空间并用owner控制最终资源释放的方法并不是特别好的智能指针方案。</p><h3 id="不允许共享，独占所有权"><a href="#不允许共享，独占所有权" class="headerlink" title="不允许共享，独占所有权"></a>不允许共享，独占所有权</h3><p>既然多智能指针共享堆空间存在着这样或那样的问题，那干脆不让他们共享得了。比如下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">AutoPtr</span><span class="params">(T * ptr=<span class="literal">nullptr</span>)</span>: _<span class="title">ptr</span><span class="params">(ptr)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoPtr(AutoPtr&lt;T&gt; &amp; autoptr): _ptr(autoptr._ptr)&#123;</span><br><span class="line">        autoptr._ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~AutoPtr()&#123;</span><br><span class="line">        <span class="keyword">if</span>(_ptr)&#123;</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoPtr&lt;T&gt; &amp; <span class="keyword">operator</span>=(AutoPtr&lt;T&gt; &amp; autoptr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;autoptr) &#123;</span><br><span class="line">            <span class="keyword">if</span>(_ptr != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">            &#125;</span><br><span class="line">            _ptr = autoptr._ptr;</span><br><span class="line">            autoptr._ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">AutoPtr&lt;<span class="keyword">int</span>&gt; <span class="title">oldPtr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>))</span></span>;</span><br><span class="line">    AutoPtr&lt;<span class="keyword">int</span>&gt; newPtr = oldPtr; <span class="comment">//oldPtr已经不指向堆空间了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中我们不允许多个AutoPtr之间共享同一块堆空间，当将一个AutoPtr赋值给另一个AutoPtr时，让原来的AutoPtr指向空地址（nullptr)，新的AutoPtr指向堆空间。上面代码执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set new object,0x7fe905502760</span><br><span class="line">copy construct, 0x7fe905502760          &#x2F;&#x2F;newPtr 指向堆空间</span><br><span class="line">delete object，0x7fe905502760           &#x2F;&#x2F;newPtr 析构</span><br><span class="line">really,delete object，0x7fe90550276     &#x2F;&#x2F;newPtr 指向的堆空间被释放</span><br><span class="line">delete object，0x0                      &#x2F;&#x2F;oldPtr 析构，此时可以看到它指向的地址为nullptr</span><br></pre></td></tr></table></figure><p>通过结果可以证明我们上面修改的代码已经阻止了多个AutoPtr共享同一块堆空间的可能。</p><p>然而上面的实现打破了我们对传统指针的认知，这会给你带来很多麻烦。尤其是多人合作时，如果大家对AutoPtr没有一致的认识，特别容易出现问题。因为既然是指针，那它就应该允许多个指针指向同一块堆空间。因此，当不有了解AutoPtr的同学使用它时，很可能还会认为多个AutoPtr是指向同一块堆空间的，这样当他通过老的AutoPtr向堆空间写数据时就会产生crash。比如像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">*(oldptr.get()) &#x3D; 10;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其运行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set new object,0x7fd93bc028c0</span><br><span class="line">copy construct, 0x7fd93bc028c0</span><br><span class="line">[1]    39662 segmentation fault  .&#x2F;autoptr  &#x2F;&#x2F;这里crash了</span><br></pre></td></tr></table></figure><p>上面的AutoPtr就是C++98规范中的auto_ptr的实现，由于该实现总是存在这样或那样的问题，因此现在auto_ptr已经被废弃掉了。</p><h2 id="scoped-ptr"><a href="#scoped-ptr" class="headerlink" title="scoped_ptr"></a>scoped_ptr</h2><p>我们已经看到上面的AutoPtr有各种弊端，引起这些弊端的最主要的原因是AutoPtr具有控制权的传递性，也就是说它允许从一个AutoPtr赋值给另一个AutoPtr。</p><p>为了彻底解决AutoPtr上面所述的问题，就出现了scoped_ptr。scoped_ptr最早是在C++的boost库中出现的，其出现的原因是从C++98之后C++标准一直没有更新智能指针的规范。因此C++大牛们纷纷发布了自己私有标准，而scoped_ptr就是其中之一。</p><p>scoped_ptr的核心思想是什么呢？既然auto_ptr的所有问题都是因为传递性引起的，所以阻止其传递性就可以解决这个问题了。因此scoped_ptr的实现也特别简单，它将其拷贝构造函数及赋值操作符全部隐藏起来，这样就不会有auto_ptr的问题了。</p><p>下面我们来看一下它的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScopedPtr</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ScopedPtr(T * ptr = <span class="literal">nullptr</span>): _ptr(ptr)&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T* <span class="keyword">operator</span>-&gt;()&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T&amp; <span class="keyword">operator</span>*()&#123;</span><br><span class="line">            <span class="keyword">return</span> *(<span class="keyword">this</span>-&gt;_ptr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">T* <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~ScopedPtr()&#123;</span><br><span class="line">            <span class="keyword">if</span>(_ptr != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        ScopedPtr(ScopedPtr&lt;T&gt; &amp; scopedptr)&#123;&#125;</span><br><span class="line">        ScopedPtr&lt;T&gt; &amp; <span class="keyword">operator</span>=(ScopedPtr&lt;T&gt; &amp; scopedptr)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T *_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">ScopedPtr&lt;<span class="keyword">int</span>&gt; <span class="title">myPtr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>))</span></span>;</span><br><span class="line">    ScopedPtr&lt;<span class="keyword">int</span>&gt; newPtr = myPtr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//clang++ -g -o scopedptr test_scopedptr.cpp</span></span><br></pre></td></tr></table></figure><p>当我们编译上面的代码时，会报下面的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test_scopedptr.cpp:32:29: error: calling a protected constructor of class &#39;ScopedPtr&lt;int&gt;&#39;</span><br><span class="line">    ScopedPtr&lt;int&gt; newPtr &#x3D; myPtr;</span><br><span class="line">                            ^</span><br><span class="line">test_scopedptr.cpp:23:9: note: declared protected here</span><br><span class="line">        ScopedPtr(ScopedPtr&lt;T&gt; &amp; scopedptr)&#123;&#125;</span><br><span class="line">        ^</span><br><span class="line">1 error generated.</span><br></pre></td></tr></table></figure><p>上面的错误正是我们想要的结果。只要你对ScopedPtr进行赋值，在编译时就不让其编译通过，这样就不会再产生AutoPtr的问题了。</p><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>我们上面所讲的scoped_ptr并非是官方的标准，它是C++大牛们自己实现的版本。到了C++11之后官方版本来了，其被命名为unique_ptr。实际上unique_ptr与scoped_ptr功能几乎是一模一样，不过它们之间也有一些细微差别。</p><p>差别是什么呢？就是unique_ptr可以对右值进行转移，<code>对右值转移</code>这是啥意思呢？说明白了就是提供了一种特殊方法可以将unique_ptr赋值给另一个unique_ptr，被转移后的unique_ptr也就不能再处理之前管理的指针了。</p><p>我们还是来看一个具体的例子你就清楚了，只要给我们之前的ScopedPtr加上一个移动构造函数和移动赋值运算符就实现unique_ptrr的转移功能了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class ScopedPtr&#123;</span><br><span class="line">    ...</span><br><span class="line">    ScopedPtr(ScopedPtr&lt;T&gt;&amp;&amp; scopedptr) noexcept : _ptr(scopedptr._ptr)&#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;move construct...&quot; &lt;&lt; std::endl;</span><br><span class="line">        scopedptr._ptr &#x3D;  nullptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ScopedPtr&amp; operator&#x3D;(ScopedPtr&lt;T&gt; &amp;&amp; scopedptr) noexcept &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;move assignment...&quot; &lt;&lt; std::endl;</span><br><span class="line">        if(this !&#x3D; &amp;scopedptr)&#123;</span><br><span class="line">            _ptr &#x3D; scopedptr._ptr;</span><br><span class="line">           scopedptr._ptr &#x3D; nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[])&#123;</span><br><span class="line">    ScopedPtr&lt;int&gt; myPtr(new int(100));</span><br><span class="line">    &#x2F;&#x2F;ScopedPtr&lt;int&gt; newPtr &#x3D; myPtr;            &#x2F;&#x2F;拷贝构造函数已经不能用了</span><br><span class="line">    ScopedPtr&lt;int&gt; newPtr &#x3D; std::move(myPtr);   &#x2F;&#x2F;可以使用移动拷贝构造函数进行转移</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;clang++ -std&#x3D;c++11 -g -o scopedptr test_scopedptr.cpp</span><br></pre></td></tr></table></figure><p>上面main函数中的第二行调用的是拷贝构造函数，由于该函数是不是public属性，所以调用该行时会失败。而第三行会调用移动构造函数，因为我们已经实现了移动构造函数，所以该行可以编译成功。在运行时，当myPtr移动给newPtr后，myPtr也就失去了对原指针的控制权，这在代码中也有体现就是将 scopedptr的<code>_ptr</code>域设置为nullptr了。</p><p>上面就是C++11标准中的unique_ptr的实现，这样一分析下来也是蛮简单的对吧。</p><p>另外，对于移动构造函数，std::move这些概念我在另一篇文章<a href="https://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">《C++高阶知识：深入分析移动构造函数及其原理》</a>中有详细的介绍，对这块知识不了解的同学可以去看一下。</p><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p>虽然unique_ptr已经很好用了，但有时候我们还是需要多个智能指针管理同一块堆内存空间。之前在讲AutoPtr时我们已经介绍了多个智能指针管理同一块内存空间会引起很多问题，有没有更好的方式来解决这些问题呢？</p><p>其中引用计数法是个不错的解决方案，实现起来也比较简单。其基本原理是当有多个智能指针指对同一块堆空间进行管理时，每增加一个智能指针引用计数就增1，每减少一个智能指针引用计数就减少。当引用计数减为0时，就将管理的堆空间释放掉。</p><p>我们还是看一个具体例子吧，其实现是在unique_ptr的基础之上实现的，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScopedPtr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        ScopedPtr(T *ptr = <span class="literal">nullptr</span>): _ptr(ptr), _ref_count(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>))&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ScopedPtr(ScopedPtr&lt;T&gt; &amp; scopedptr): _ptr(scopedptr._ptr), _ref_count(scopedptr._ref_count)&#123;</span><br><span class="line">            ++（*_ref_count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ScopedPtr &amp; <span class="keyword">operator</span>=(ScopedPtr&lt;T&gt; &amp; scopedptr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;scopedptr)&#123;</span><br><span class="line">                _release();</span><br><span class="line">                _ptr(scopedptr._ptr);</span><br><span class="line">                _ref_conut(scopedptr._ptr);</span><br><span class="line">                ++(*_ref_count);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~ScopedPtr()&#123;</span><br><span class="line">            _release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span>* <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> *_ref_count; </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="keyword">void</span> _release() &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"deconstruct...: count="</span> &lt;&lt; ((*_ref_count) <span class="number">-1</span>)  &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(--(*_ref_count) == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">                <span class="keyword">delete</span> _ref_count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">int</span> *_ref_count;   <span class="comment">//引用计数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">ScopedPtr&lt;<span class="keyword">int</span>&gt; <span class="title">myPtr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>))</span></span>;</span><br><span class="line">    ScopedPtr&lt;<span class="keyword">int</span>&gt; pT2 = myPtr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//clang++ -std=c++11 -g -o sharedptr test_sharedptr.cpp</span></span><br></pre></td></tr></table></figure><p>通过上面的修改，我们就可以将unique_ptr修改成shared_ptr了，测试结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">default construct ...</span><br><span class="line">copy construct ...: count&#x3D;2</span><br><span class="line">deconstruct...: count&#x3D;1</span><br><span class="line">deconstruct...: count&#x3D;0</span><br></pre></td></tr></table></figure><p>从结果中我们可以看到创建myPtr时引用计数为 1，将myPtr赋值给pT2时引用计算为2。当main程序结束后首先释放pT2，其引用计数减1。再释放myPtr，引用计数减为0，当引用计数为0时，释放堆空间。</p><p>这样的智能指针还是非常棒的，我们再也不怕内存泄漏了！！！</p><p>等等，我们好像高兴的太早了，当出现循环指向时还是会出现内存泄漏。我们来看一下例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ScopeddPtr&lt;Node&gt; _prev;</span><br><span class="line">    ScopeddPtr&lt;Node&gt; _next;</span><br><span class="line"></span><br><span class="line">    ~Node()</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"delete :"</span> &lt;&lt;<span class="keyword">this</span>&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ScopedPtr&lt;Node&gt; <span class="title">cur</span><span class="params">(<span class="keyword">new</span>(Node))</span></span>;</span><br><span class="line"><span class="function">ScopedPtr&lt;Node&gt; <span class="title">next</span><span class="params">(<span class="keyword">new</span>(Node))</span></span>;</span><br><span class="line">cur-&gt;_next = next;</span><br><span class="line">next-&gt;_prev = cur;</span><br></pre></td></tr></table></figure><p>上面这段代码就会出现内存泄漏，我们来分析一下。</p><p>首先第一行会创建三个Node类型的智能指针，分别是 <code>cur-&gt;_prev</code>、<code>cur-&gt;_next</code> 、<code>cur</code> 此时它们各自的引用计数都是 1；第二行也会创建三个Nodet智能指针，分别是<code>next-&gt;_prev</code>、<code>next-&gt;_next</code>及<code>next</code>; 第三行完成之后，<code>cur-&gt;_next</code>和<code>next</code>的引用计数都为 2；第四行完成后，<code>next-&gt;_prev</code>和<code>cur</code>的引用计数也变成了2；</p><p>当main程序结束时，next和cur分别调用它们的析构函数，因此<code>next</code>和<code>cur-&gt;_next</code>的引用计数变为1，<code>cur</code>和<code>next_prev</code>的引用计数也变成了1，但由于没有减至0，所以资源永会不会被释放掉。这就是产生内存泄露的原因。</p><p>真是辛辛苦苦好几年，一下回到解放前。使用引用计数还是会产生内存泄漏，我们仿佛又回到了起点。</p><p>不过别着急，C++11又给我们提供了新的解决方案，如何解决这个问题呢？</p><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p>weak_ptr就是专门为了解决这个问题而出现的。实际上weak_ptr不能单独称为一个智能指针，它必须与shared_ptr一起使用，起到辅助share_ptr的作用。我们来看看它是如何解决上述问题的吧。</p><p>首先引入weak_ptr后，weak_ptr也要有自己的引用计数，因此我们需要修改之前的ScopedPtr，将它的计数成员变成一个类型，包括它自己的计数和weak_ptr的计数，它看起来像下面的样子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Counter():s(<span class="number">0</span>),w(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> s; <span class="comment">//存放share_ptr引用计数</span></span><br><span class="line">        <span class="keyword">int</span> w; <span class="comment">//存放weak_ptr引用计数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来我们来修改一下ScopedPtr，由于这次修改比较大，所以我给它重新起一个名子，叫作SharedPtr吧，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">WeakPtr</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SharedPtr &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        SharedPtr(T * ptr = <span class="literal">nullptr</span>):_ptr(ptr)&#123;</span><br><span class="line">            _cnt = <span class="keyword">new</span> Counter();</span><br><span class="line">           <span class="keyword">if</span>(_ptr != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                 _cnt-&gt;s = <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~SharedPtr()&#123;</span><br><span class="line">            _release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SharedPtr(SharedPtr&lt;T&gt; &amp; sharedptr): _ptr(sharedptr._ptr), _cnt(sharedptr._cnt)&#123;</span><br><span class="line">            _cnt-&gt;s++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SharedPtr(WeakPtr&lt;T&gt; &amp; weakptr): _ptr(weakptr._ptr), _cnt(weakptr._cnt)&#123;</span><br><span class="line">            _cnt-&gt;s++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SharedPtr &amp; <span class="keyword">operator</span>=(SharedPtr&lt;T&gt; &amp; sharedptr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span> != &amp; sharedptr)&#123;</span><br><span class="line">                _release();</span><br><span class="line">                _ptr = sharedptr._ptr;</span><br><span class="line">                _cnt = sharedptr._cnt;</span><br><span class="line">                _cnt-&gt;s++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T&amp; <span class="keyword">operator</span> *()&#123;</span><br><span class="line">            <span class="keyword">return</span> *_ptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T* <span class="keyword">operator</span> -&gt;()&#123;</span><br><span class="line">            <span class="keyword">return</span> _ptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//friend class WeakPtr&lt;T&gt;;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">       <span class="keyword">void</span> _release()&#123;</span><br><span class="line">            _cnt-&gt;s--;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"release "</span>&lt;&lt;_cnt-&gt;s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(_cnt-&gt;s &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">                <span class="keyword">if</span>(_cnt-&gt;w &lt;<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">delete</span> _cnt;</span><br><span class="line">                    _cnt=<span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T * _ptr;</span><br><span class="line">        Counter * _cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeakPtr</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        WeakPtr():_ptr(<span class="literal">nullptr</span>), _cnt(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">        ~WeakPtr()&#123;</span><br><span class="line">            _release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WeakPtr(WeakPtr&lt;T&gt; &amp; weakptr):_ptr(weakptr._ptr), _cnt(weakptr._cnt)&#123;</span><br><span class="line">            _cnt-&gt;w++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WeakPtr(SharedPtr&lt;T&gt; &amp; sharedptr):_ptr(sharedptr._ptr), _cnt(sharedptr._cnt)&#123;</span><br><span class="line">            _cnt-&gt;w++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WeakPtr &amp; <span class="keyword">operator</span>=(WeakPtr&lt;T&gt; &amp; weakptr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;weakptr)&#123;</span><br><span class="line">                _release();</span><br><span class="line">                _ptr = weakptr._ptr;</span><br><span class="line">                _cnt = weakptr._cnt;</span><br><span class="line">                _cnt-&gt;w++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WeakPtr &amp; <span class="keyword">operator</span>=(SharedPtr&lt;T&gt; &amp; sharedptr)&#123;</span><br><span class="line">            _release();</span><br><span class="line">            _ptr = sharedptr._ptr;</span><br><span class="line">            _cnt = sharedptr._cnt;</span><br><span class="line">            _cnt-&gt;w++;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">SharedPtr&lt;T&gt; <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> SharedPtr&lt;T&gt;(*<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">expired</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(_cnt &amp;&amp; _cnt-&gt;s &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"empty "</span>&lt;&lt;_cnt-&gt;s&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//friend class SharedPtr&lt;T&gt;;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="keyword">void</span> _release()&#123;</span><br><span class="line">            <span class="keyword">if</span>(_cnt)&#123;</span><br><span class="line">                _cnt-&gt;w--;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"weakptr release"</span>&lt;&lt;_cnt-&gt;w&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">if</span>(_cnt-&gt;w &lt; <span class="number">1</span> &amp;&amp; _cnt-&gt;s &lt;<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">//delete cnt;</span></span><br><span class="line">                        _cnt=<span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T * _ptr;</span><br><span class="line">        Counter * _cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    WeakPtr&lt;Node&gt; _prev;</span><br><span class="line">    WeakPtr&lt;Node&gt; _next;</span><br><span class="line"></span><br><span class="line">    ~Node()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"delete :"</span> &lt;&lt;<span class="keyword">this</span>&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">SharedPtr&lt;Node&gt; <span class="title">cur</span><span class="params">(<span class="keyword">new</span>(Node))</span></span>;</span><br><span class="line">    <span class="function">SharedPtr&lt;Node&gt; <span class="title">next</span><span class="params">(<span class="keyword">new</span>(Node))</span></span>;</span><br><span class="line">    cur-&gt;_next = next;</span><br><span class="line">    next-&gt;_prev = cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//clang++ -std=c++11 -g -o weakptr test_weakptr.cpp</span></span><br></pre></td></tr></table></figure><p>以上就是WeakPtr的实现以及SharedPtr的改造，从中我们可以看到，SharedPtr与我们之前的ScopedPtr区别并不是很大，主要做了三点有修改：一、以前只有一个计数器，然在变成了两个，一个是SharedPtr本身的计数，另一个是WeakPtr的计数；二是增加了一个参数为WeakPtr引用的拷贝构造函数;三、<code>_ptr</code>和<code>_cnt</code>的释放都是在SharedPtr中完成的，WeakPtr不做具体的释放工作。</p><p>WeakPtr是新增加的弱指针，它是配合SharedPtr使用的，自己并不能单独使用。WeakPtr也包含<code>_ptr</code>和<code>_cnt</code>两个成员，但它更多是是引用，对它们没有创建和释放权。另外在WeakPtr中会对Counter对象的w字段操作，也就是说多个WeakPtr指向同一个堆空间时，它仅操作Counter中的w字段。</p><p>因此，对于我们之前的SharedPtr形成环后导致的内存泄漏可以通过WeakPtr对其进行改造，这样内存泄漏的问题就迎刃而解了。</p><p>上面修改后的代码我们再来分析一遍。首先第一行会创建两个WeakPtr指针 <code>cur-&gt;_prev</code>、<code>cur-&gt;_next</code> 和一个SharedPtr智能指针<code>cur</code>。此时它们各自的引用计数都是 1；第二行同样也会创建二个WeakPtr指针<code>next-&gt;_prev</code>、<code>next-&gt;_next</code>和一个SharedPtr智能指针<code>next</code>; 第三行完成之后，<code>cur-&gt;_next</code>的_cnt-&gt;w为1，<code>next</code>的_cnt-&gt;s为1；第四行完成后，<code>next-&gt;_prev</code>的_cnt-&gt;w为1，<code>cur</code>的_cnt-&gt;s引用计数也为1；</p><p>当main程序结束时，next和cur分别调用它们的析构函数，因此<code>next</code>引用计数为0，释入Node对象，在Node中又会释放_prev和_next。next释放完成后开始释放<code>cur</code>，同里cur所持有的资源也一并释放。因此就不会再有内存泄漏了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文的篇幅有点长，不过每一部分都是不可或缺的。在本文中向你详细讲解了 auto_ptr、scoped_ptr、unique_ptr、shared_ptr以及与之配套的 weak_ptr的衍化过程。通过这样一个过程让你知道了这几个智能指针的作用是什么，应该用在地方，以及该如何使用。</p><p>相信通过本文你会对C++中的智能指针有了深刻的理解。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">C++高阶知识：深入分析移动构造函数及其原理</a><br>[重学C/C++中的const][<a href="https://avdancedu.com/5e7916e3/]" target="_blank" rel="noopener">https://avdancedu.com/5e7916e3/]</a><br><a href="http://localhost:4000/670ef31f/" target="_blank" rel="noopener">聊聊C++中的类型转换</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我们来聊聊C++的智能指针。C++从1983年诞生到现在已经有30多年历史了，为什么到现在还能如此流行呢(排名第四，2020年6月&lt;a href=&quot;https://hellogithub.com/report/tiobe/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HelloGitHub榜单&lt;/a&gt;)？因为它具有很多其它语言所不具备的优势，比如说执行速度快，控制力更强等。同样的，有更多的同学会选择用Java(排名第二)等语言，这是因为它相对C++来说，它更简单，易上手，不用担心内存泄漏！&lt;/p&gt;
&lt;p&gt;确实，&lt;strong&gt;内存泄漏&lt;/strong&gt;在很长的一段时间里是影响人们学习C++的一个最重要的原因。不过C++也在不断进步中，智能指针的出现就大大降低了内存泄漏发生的风险。&lt;/p&gt;
&lt;p&gt;下面我们就来细聊一下C++智能指针的方方面面，通过本文让你真正掌握C++智能指针。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="https://blog.avdancedu.com/categories/C-C/"/>
    
    
      <category term="智能指针" scheme="https://blog.avdancedu.com/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>重学C/C++中的const</title>
    <link href="https://blog.avdancedu.com/5e7916e3/"/>
    <id>https://blog.avdancedu.com/5e7916e3/</id>
    <published>2020-06-30T06:09:42.000Z</published>
    <updated>2020-07-07T13:50:26.952Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/const/const.jpg" alt=""></p><p>使用<code>C/C++</code>语言的同学应该对<code>const</code>都比较了解，但对于初学者来说，<code>const</code>确是一个难肯的骨头，理解起来困难重重。今天我就带你重新学习一下C/C++的中的<code>const</code>。</p><a id="more"></a><h2 id="const-与-define-的区别"><a href="#const-与-define-的区别" class="headerlink" title="const 与 #define 的区别"></a>const 与 #define 的区别</h2><p>在<code>C/C++</code>中定义常量通常使用<code>const</code>关键字，当然你也可以使有宏<code>#define</code>来定义。这两种方式定义常量如下所示：</p><ul><li>const 定义常量  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int PI &#x3D; 3.14;</span><br></pre></td></tr></table></figure></li><li>宏定义常量  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define PI &#x3D; 3.14</span><br></pre></td></tr></table></figure></li></ul><p>这两种定义常量的方式有什么区别呢？</p><p>要回答这个问题，我们需要了解一点编译原理的知识。编译器在编译我们写好C/C++程序时，其编译器过程为：<strong>预编译-&gt;编译-&gt;链接</strong>。<code>C/C++</code>中宏的替换就是在预编译阶段完成的，也就是说在预编译阶段将C/C++中的所有用到的宏都用宏定义中的值替换掉。</p><p>而<code>const</code> 定义的常量则与宏定义的常量不同，它是在编译阶段进行检测，而且还可以对其类型进行检测。因此我们可以总结出使用<code>const</code>定义的常量与宏定义的常量有如下区别:</p><ul><li>宏是在预编译时进行宏展开，而const是在编译时检测，所以两者操作的时期不同</li><li>由于宏在预编译时被操作，所以无法进行类型检测；而const则可以进行类型检测</li><li>因在编译阶段可以形成符号表，所以const定义的常量可以通过调试器进行调试；而宏在展开后就消失了，所以无法通过调试器进行调试</li></ul><p>以上就是<code>const</code>与<code>宏</code>的最主要的区别。所以一般情况下我们都建议使用const来定义常量。</p><h2 id="const常量与const常量指针"><a href="#const常量与const常量指针" class="headerlink" title="const常量与const常量指针"></a>const常量与const常量指针</h2><p>上面我们已经列举过const如何定义常量，这里就不再赘述了。现在咱们来看一下const常量指针，它该如何定义呢?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int * ptr; &#x2F;&#x2F;const常量指针</span><br></pre></td></tr></table></figure><p>上面就是const常量指针的定义，也挺好理解的对吧。我们将const常量和const常量指针放在一起看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int i;    &#x2F;&#x2F;const常量</span><br><span class="line">const int* ptr; &#x2F;&#x2F;const常量指针</span><br></pre></td></tr></table></figure><p>将他们放在一起比较着看，你就更容易理解const常量指针了，无非就是将const常量中的类型变成指针而已。</p><h2 id="const常量指针的作用"><a href="#const常量指针的作用" class="headerlink" title="const常量指针的作用"></a>const常量指针的作用</h2><p><strong>那么常量指针的作用是什么呢？</strong>，我们来看个例子你就清楚了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const int i &#x3D; 100;     &#x2F;&#x2F; 定义一个常量</span><br><span class="line">i &#x3D; 100;               &#x2F;&#x2F; 不允许修改常量</span><br><span class="line"></span><br><span class="line">int *p &#x3D; &amp;i;           &#x2F;&#x2F; 老的编译器是被允许的，这实际存在安全问题</span><br><span class="line">                       &#x2F;&#x2F; 为了解决这个问题，新的编译器报错，非常量指针不允许指向常量地址</span><br><span class="line"></span><br><span class="line">const int * ptr &#x3D; &amp;i;  &#x2F;&#x2F; 常量指针指向常量地址</span><br><span class="line">*ptr &#x3D; 100;            &#x2F;&#x2F; 不允许修改常量的内容</span><br></pre></td></tr></table></figure><p>按照常量的定义，常量定义好后其内容就不允许再修改了，因此对于上面代码中的前两行相信你不会有什么异义。</p><p>但在较老的编译器上，存在一个漏洞，它允许你用普通指针指向常量地址。这样你就可以通过该指针修改常量的内容了，这是非常大的安全漏洞。为了消除这个安全隐患，在新的编译器上已经不允许普通指针指向const常量了。</p><p>为什么在老编译器上指针可以指向常量地址并修改其内容呢？究其原因是因为const定义的常量实际是在内存的可读写空间，只是由于编译器限制你才不能修改它。而老的编译器却没有这方面的限制，所以才会出现通过普通指针修改常量的可能。</p><p>我们再来看代码的最后两行。使用const常量指针指向常量地址，此时你无论用新编译器还是老编译器，都无法通过该指针修改常量的内容。所以代码的最后一行当你修改常量内容时就会报错。</p><p>通过上面的讲解，你应该对常量指针的概念比较清楚了。常量指针不能修改常量内容，但能不能让常量指针指向另外一个常量的地址呢？比如下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const int i &#x3D; 100;</span><br><span class="line">const int n &#x3D; 1000;</span><br><span class="line"></span><br><span class="line">const int * ptr &#x3D; &amp;i;   &#x2F;&#x2F;常量指针先指向 i 常量的地址</span><br><span class="line">ptr &#x3D; &amp;n;               &#x2F;&#x2F;又修改为指向 n 常量的地址</span><br></pre></td></tr></table></figure><p>这样做当然是可以的，因为常量指针限制的是不能修改常量内容，但并没有限制它指向哪个常量。</p><h2 id="const变形"><a href="#const变形" class="headerlink" title="const变形"></a>const变形</h2><p>上面我们已经清楚了const常量指针是什么，它起了什么作用。但它还有一点你不知道，就是它会变型。我们来看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int * ptr;</span><br><span class="line">int const * ptr;</span><br></pre></td></tr></table></figure><p>上面这两行代码很像是不是？第二行代码将 const 放到了 int 类型之后，它表达的是什么意思呢？<strong>其实两行表示的是同一个意思，都是常量指针</strong>。只是有的人喜欢将const写在最前面，有的人喜欢将const 写在类型后面罢了。这里有一个记忆的小巧门，我们只要记住const是在 <code>*</code> 左边它就表示的是常量指针就OK了，</p><h2 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h2><p>上面的内容清楚之后，我们再来一个复杂的<strong>指针常量</strong>。看到这个词相信很多同学立马晕了，上面是常量指针，这又来个指针常量是这是说绕口令吗？先别急，我们先来看个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int * const ptr;</span><br></pre></td></tr></table></figure><p>上面这行代码是不是与前面的很相似？一模一样? 如果你这样认为说明你没有仔细观察。之前的常量指针const是在<code>*</code>号左边，这次的const跑到<code>*</code>号右边了。</p><p>它表示的是什么意思呢？</p><p>前面我已经说了，对于常量指针来说，你是不能修改它所指向的内容的，因为内容是常量，但它可以让它指向不同的常量地址。新需求来了，有没有可能让指针指向一个地址就不动了呢？或者换个思考的角度，既然const可以定义常量，能不能定义一个指针常量呢？<strong>这就是指针常量的由来</strong>。</p><p>C/C++编译器的作者考虑的一下这个需求，觉得这个需求是合理的，决定实现它。但怎么才能表示指针常量呢？于是就有了 <code>const int * const ptr</code> 这个写法，const 放在<code>*</code>后面表达对ptr的限制。</p><p>了解了指针变量的由来，下面我们来看一下它的用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 100;</span><br><span class="line">int n &#x3D; 1000;</span><br><span class="line"></span><br><span class="line">int * const ptr &#x3D;  &amp;i; &#x2F;&#x2F; 正确，初始指向某个变量</span><br><span class="line">ptr &#x3D; &amp;n;              &#x2F;&#x2F; 错误，ptr是常量，不能再发生变化</span><br><span class="line"></span><br><span class="line">*ptr &#x3D; 20;             &#x2F;&#x2F; 正确，因为我们没有对指针指向的内容做限制</span><br></pre></td></tr></table></figure><p>上面代码中定义了两个变量 i 和 n，ptr是针指常量，因此它只能在初始化时指向某个变量的地址，之后它就不能更改变指向其它地址了，因为它是<strong>常量</strong>。<strong>但需要注意的是ptr指向的内容是可以被修改的</strong>。</p><h2 id="指向常量的指针常量"><a href="#指向常量的指针常量" class="headerlink" title="指向常量的指针常量"></a>指向常量的指针常量</h2><p>看这个标题就觉得好复杂啊！没错我们又要升级难度了。先看个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int * const ptr1;</span><br><span class="line">int const * const ptr2;</span><br></pre></td></tr></table></figure><p>天呐，一条语句中出列了两个const，如果我们没有基础的话，这两行代码简直无法理解。不过，有了上面的基础我们再来看这两句还是能猜出它要干什么的对吧？</p><p>这两条语句的含义是一样的，表示的是ptr1/ptr2指向的地址不能再改变，而且它指向的地址里的内容也不能再改变。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在本文中我向你详细介绍了C/C++中的<code>const</code>的含义和用法，总结一下包括以下几种：</p><ul><li>定义常量, 内容不能改变，<code>const int a;</code></li><li>定义常量指针，指向的内容不能改变，<code>const int * ptr;</code> 或 <code>int const * ptr;</code></li><li>定义指针常量，指针不能改变，但指向的内容可以改变。<code>int * const ptr</code></li><li>定义指向常量的针指常量，指针不能改变，内容也不能改变。<code>const int * const ptr</code> 或 <code>int const * const ptr</code></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">C++高阶知识：深入分析移动构造函数及其原理</a><br><a href="https://avdancedu.com/9683d88/" target="_blank" rel="noopener">细说智能指针</a><br><a href="https://avdancedu/670ef31f/" target="_blank" rel="noopener">聊聊C++中的类型转换</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/const/const.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;C/C++&lt;/code&gt;语言的同学应该对&lt;code&gt;const&lt;/code&gt;都比较了解，但对于初学者来说，&lt;code&gt;const&lt;/code&gt;确是一个难肯的骨头，理解起来困难重重。今天我就带你重新学习一下C/C++的中的&lt;code&gt;const&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="https://blog.avdancedu.com/categories/C-C/"/>
    
    
      <category term="const" scheme="https://blog.avdancedu.com/tags/const/"/>
    
  </entry>
  
  <entry>
    <title>分析WebRTC，重学Windows开发</title>
    <link href="https://blog.avdancedu.com/2fb1b8c6/"/>
    <id>https://blog.avdancedu.com/2fb1b8c6/</id>
    <published>2020-06-29T14:47:36.000Z</published>
    <updated>2020-06-29T15:39:27.749Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/windows/win95.jpg" alt=""></p><p>N多年没有写过 Window 程序了。为了研究 WebRTC 源码，这两天重新学习一下。还记得上大学的时候看过 《Windows95 程式设计》台湾版，对那本书印象极为深刻。一是当时国内确实没有一本写的那么深入的书籍，二是那本书翻译的特别好，让人一看就特别明白。10多年过多了，当时的情景还记忆犹新，也可见那本书写的有多好了。</p><a id="more"></a><p>Windows开发有很多知识点，窗口啊，句柄啊，消息啊，重绘啊，baba …..，但一个 Windows 程序的核心就是一个消息处理机制。</p><h2 id="Windows程序运行的基本原理"><a href="#Windows程序运行的基本原理" class="headerlink" title="Windows程序运行的基本原理"></a>Windows程序运行的基本原理</h2><p>Windows程序是消息为驱动的，所以它的核心就是消息的传递与处理。如鼠标消息、键盘消息，Timer消息，窗口的创建与消毁等等。那么，Windows程序是在哪儿处理消息呢？是否掌握了它，就控制了Windows程序的核心呢？答案是肯定的，它就是 WndProc 函数。所有的消息都要经过这个函数处理。</p><p>Windows 程序有两种消息，一种是队列消息，它通过 DispatchMessage 函数分发给 WndProc 函数，像鼠标消息、键盘消息，Timer消息都是这类消息。另一种是非队列消息，它是系统函数直接发送给 WndProc 函数的，像窗口的创建与消毁消息，WM_COMMON消息等等都是非队列消息。</p><h2 id="最简单的-Windows-程序"><a href="#最简单的-Windows-程序" class="headerlink" title="最简单的 Windows 程序"></a>最简单的 Windows 程序</h2><p>一个最简单的 Windows 程序都包括哪些内容呢？下面我们详细介绍一下：</p><h3 id="WinMain-函数"><a href="#WinMain-函数" class="headerlink" title="WinMain 函数"></a>WinMain 函数</h3><p>我们都知道无论是Windows程序，还是Linux程序，也无论是C/C++，还是 Java语言，它们都有一个 main 函数。更准确点说应该叫“程序入口点”。</p><p>我们写程序时，一般都以 main 开头，编译器在编译该程序时，会将 main 函数地址写入到可执行文件的文件头中，这就是“程序入口点”了。</p><p>在执行程序时，操作系统首先通过程序加载器将要运行的程序加载到内存中，然后重新计算符号地址表。一切准备就绪后，才跳到程序入口点，将一条条指令送入CPU流水线开始执行程序。这就是程序的运行的基本流程。</p><p>因此，我们可以知道每个程序都有一个入口点。但是否一定以 main 开头呢? 其实，只要编译器能识别出入口点就可以，不必非要以 main 为标志。对于 Windows 程序就是这样，它就不使用 main作为入口点，而是换成了 WinMain 作为程序入口点。格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int CALLBACK WinMain(</span><br><span class="line">   _In_  HINSTANCE hInstance,</span><br><span class="line">   _In_  HINSTANCE hPrevInstance,</span><br><span class="line">   _In_  LPSTR lpCmdLine,</span><br><span class="line">   _In_  int nCmdShow</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="实现消息中心函数-WndProc"><a href="#实现消息中心函数-WndProc" class="headerlink" title="实现消息中心函数 WndProc()"></a>实现消息中心函数 WndProc()</h3><p>前面我已经介绍了 WndProc 是 Windows 程序的消息中心，所有的消息都要在这个函数中处理。如 窗口创建时发送的 WM_CREATE 消息，如果我们不处理它，Windows 操作系统就不会显示创建的窗口。</p><p>但 Windows 中有那么多消息，我们每个都处理岂不是要累死人？所以 Windows 很贴心的提供了一个API，就是 DefWindowProc 函数。该函数对所有的 Windows 消息都做了默认处理，如果我们很懒的话，可以将所有消息都交由它就好了。</p><p>有没有坐过山车的感脚？开始觉得很苦闷，突然又拨云见日了。嘿嘿！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CALLBACK WndProc(</span><br><span class="line">        _In_  HWND hwnd,</span><br><span class="line">        _In_  UINT uMsg,</span><br><span class="line">        _In_  WPARAM wParam,</span><br><span class="line">        _In_  LPARAM lParam</span><br><span class="line">) &#123;</span><br><span class="line">return DefWindowProc(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册窗口类"><a href="#注册窗口类" class="headerlink" title="注册窗口类"></a>注册窗口类</h3><p>我们在创建窗口之前要注册一个窗口类，它是干啥用的呢？就是告诉操作系统，我要创建个什么样子的窗口，是啥背景色，鼠标是啥样子的，程序叫啥名子等等。</p><p>有了这个窗口类，我们就可以创建不同样式的窗口了，这样是不是觉得很方便呢？当然，一般情况下我们都使用默认样式！</p><p>这个窗口类除了设置样式外，其实它<strong>更重要的作用</strong>是指定 WndProc 函数，也就是为 Window 程序指定 “消息处理中心”。消息中心是谁，完全是由 RegisterClass 说了算，它说消息处理中心是 WndProc 就是 WndProc，它说 ABC 那就是 ABC。</p><p>一般我们调用注册窗口的代码都长的像下面这样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 类名</span><br><span class="line">WCHAR* cls_Name &#x3D; L&quot;My Class&quot;;</span><br><span class="line">&#x2F;&#x2F; 设计窗口类</span><br><span class="line">WNDCLASS wc &#x3D; &#123; &#125;;</span><br><span class="line">wc.hbrBackground &#x3D; (HBRUSH)COLOR_WINDOW;</span><br><span class="line">wc.lpfnWndProc &#x3D; WndProc;</span><br><span class="line">wc.lpszClassName &#x3D; cls_Name;</span><br><span class="line">wc.hInstance &#x3D; hInstance;</span><br><span class="line">&#x2F;&#x2F; 注册窗口类</span><br><span class="line">RegisterClass(&amp;wc);</span><br></pre></td></tr></table></figure><h3 id="创建窗口"><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h3><p>创建窗口就比较简单了，高多少，宽多少，透明的还是非透明的，可显示还是不可显示，标题栏上要写啥字等等，这些都是由<code>创建窗口</code>说了算。形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建窗口</span><br><span class="line">      HWND hwnd &#x3D; CreateWindow(</span><br><span class="line">      cls_Name,           &#x2F;&#x2F;类名，要和刚才注册的一致</span><br><span class="line">      L&quot;我的应用程序&quot;,  &#x2F;&#x2F;窗口标题文字</span><br><span class="line">      WS_OVERLAPPEDWINDOW, &#x2F;&#x2F;窗口外观样式</span><br><span class="line">      38,                 &#x2F;&#x2F;窗口相对于父级的X坐标</span><br><span class="line">      20,                 &#x2F;&#x2F;窗口相对于父级的Y坐标</span><br><span class="line">      480,                &#x2F;&#x2F;窗口的宽度</span><br><span class="line">      250,                &#x2F;&#x2F;窗口的高度</span><br><span class="line">      NULL,               &#x2F;&#x2F;没有父窗口，为NULL</span><br><span class="line">      NULL,               &#x2F;&#x2F;没有菜单，为NULL</span><br><span class="line">      hInstance,          &#x2F;&#x2F;当前应用程序的实例句柄</span><br><span class="line">      NULL);              &#x2F;&#x2F;没有附加数据，为NULL</span><br></pre></td></tr></table></figure><h3 id="显示窗口"><a href="#显示窗口" class="headerlink" title="显示窗口"></a>显示窗口</h3><p>窗口创建完了，还要主动调<code>ShowWindows</code>函数让窗口显示出来，否则它是不会出来干活的。形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 显示窗口</span><br><span class="line">ShowWindow(hwnd, SW_SHOW);</span><br></pre></td></tr></table></figure><h3 id="循环处理，检索与分发消息"><a href="#循环处理，检索与分发消息" class="headerlink" title="循环处理，检索与分发消息"></a>循环处理，检索与分发消息</h3><p>这部分工作是在 WinMain 函数中要做的事儿。在 WinMain 中写一个循环，不停的从系统消息队列中取消息。</p><p>如果此时没有消息，则该线被程阻塞，并将CPU资源释放；如果有消息，需要判断是不是退出消息？如果不是，使用 DispatchMessage 将该消息分配出去。如果是退出消息，则退出消息循环，程序结束。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void WinMan(...)&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 消息循环</span><br><span class="line">MSG msg;</span><br><span class="line">while(GetMessage(&amp;msg, NULL, 0, 0))</span><br><span class="line">&#123;</span><br><span class="line">    TranslateMessage(&amp;msg);</span><br><span class="line">    DispatchMessage(&amp;msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是一个最简单的窗口 Window 程序。了解了上面这些知识，大家是不是觉得即使不用 MFC 也可以写出一个很不错的 Windows 程序呢？</p><h2 id="重要函数详细介绍"><a href="#重要函数详细介绍" class="headerlink" title="重要函数详细介绍"></a>重要函数详细介绍</h2><h3 id="WinMain"><a href="#WinMain" class="headerlink" title="WinMain"></a>WinMain</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int CALLBACK WinMain(</span><br><span class="line">  _In_ HINSTANCE hInstance, &#x2F;&#x2F;句柄</span><br><span class="line">  _In_ HINSTANCE hPrevInstance, &#x2F;&#x2F;总是 NULL</span><br><span class="line">  _In_ LPSTR     lpCmdLine, &#x2F;&#x2F;在命令行启动程序时的命令</span><br><span class="line">  _In_ int       nCmdShow &#x2F;&#x2F;程序启动时的显示方式</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>hInstance：句柄，就是一个内存地址，在该地址上有该程序的基本信息。</li><li>hPrevInstance：总是NULL，没啥用。</li><li>lpCmdLine： 用命令行启动时的命令，有兴趣的可以自己打印出来。</li><li>nCmdShow：程序启动时的显示方式，是隐藏，还是显示，是最大化，还是最小化显示。</li></ul><h3 id="注册窗口"><a href="#注册窗口" class="headerlink" title="注册窗口"></a>注册窗口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typedef struct tagWNDCLASS &#123;</span><br><span class="line">  UINT      style;</span><br><span class="line">  WNDPROC   lpfnWndProc;</span><br><span class="line">  int       cbClsExtra;</span><br><span class="line">  int       cbWndExtra;</span><br><span class="line">  HINSTANCE hInstance;</span><br><span class="line">  HICON     hIcon;</span><br><span class="line">  HCURSOR   hCursor;</span><br><span class="line">  HBRUSH    hbrBackground;</span><br><span class="line">  LPCTSTR   lpszMenuName;</span><br><span class="line">  LPCTSTR   lpszClassName;</span><br><span class="line">&#125; WNDCLASS, *PWNDCLASS;</span><br><span class="line"></span><br><span class="line">ATOM WINAPI RegisterClass(</span><br><span class="line">  _In_ const WNDCLASS *lpWndClass</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>style ：设置窗口样式。可以不设置。</li><li>lpfnWndProc ：这个字段特别重要，设置消息处理函数，它是消息的中心。</li><li>cbClsExtra ：不用设置。</li><li>cbWndExtra ：不用设置。</li><li>hInstance ：窗口句柄，与WinMain中的一样。</li><li>hIcon ：窗口图标。如果是NULL，使用默认图标。</li><li>hCursor ：设置光标样式。可以不设置</li><li>hbrBackground ：设置窗口背景色。</li><li>lpszMenuName：菜单名。如果为NULL说明没有菜单。</li><li>lpszClassName：这个参数要提供，长度不超过 256。</li></ul><h3 id="创建窗口-1"><a href="#创建窗口-1" class="headerlink" title="创建窗口"></a>创建窗口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HWND WINAPI CreateWindow(</span><br><span class="line">  _In_opt_ LPCTSTR   lpClassName,</span><br><span class="line">  _In_opt_ LPCTSTR   lpWindowName,</span><br><span class="line">  _In_     DWORD     dwStyle,</span><br><span class="line">  _In_     int       x,</span><br><span class="line">  _In_     int       y,</span><br><span class="line">  _In_     int       nWidth,</span><br><span class="line">  _In_     int       nHeight,</span><br><span class="line">  _In_opt_ HWND      hWndParent,</span><br><span class="line">  _In_opt_ HMENU     hMenu,</span><br><span class="line">  _In_opt_ HINSTANCE hInstance,</span><br><span class="line">  _In_opt_ LPVOID    lpParam</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>lpClassName ： 与注册的类名子一致。</li><li>lpWindowName ：窗口标题栏名子。</li><li>dwStyle ：窗口外观样式。</li><li>x ：窗口起始位置 x。</li><li>y ：窗口起始位置 y。</li><li>nWidth ：窗口宽度。</li><li>nHeight ：窗口高度。</li><li>hWndParent ：父窗口，没有的话设置为NULL</li><li>hMenu ：窗口菜单，没有设置为NULL</li><li>hInstance ： 窗口句柄。</li><li>lpParam ：符加数据，没有设置为 NULL</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过上面的介绍，我想你首先知道了Windows程序是由消息驱动的，真正负责消息处理的函数是 WinProc，它是在调用 RegisterClass 时指定的。通过 RegisterClass 我们还可以给窗口指定样式，并最终由 CreateWindow 创建出来。同时我们还可以总结出，通过 6 大步既可以创建出一个最简单的 Windows程序，这6步分别是：</p><ul><li>设置入口点，WinMain。</li><li>创建 WinProc 函数。</li><li>注册窗口类。</li><li>创建窗口。</li><li>显示窗口。</li><li>循环处理，检索与分发消息</li></ul><p>至此，一个Windows程序窗口已经展现在你面前了。 希望本文能对你有所帮助!</p><p> 谢谢！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/garrylea/SimpleWindow" target="_blank" rel="noopener">github地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/windows/win95.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;N多年没有写过 Window 程序了。为了研究 WebRTC 源码，这两天重新学习一下。还记得上大学的时候看过 《Windows95 程式设计》台湾版，对那本书印象极为深刻。一是当时国内确实没有一本写的那么深入的书籍，二是那本书翻译的特别好，让人一看就特别明白。10多年过多了，当时的情景还记忆犹新，也可见那本书写的有多好了。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>janus的线程模型</title>
    <link href="https://blog.avdancedu.com/8f43ddc9/"/>
    <id>https://blog.avdancedu.com/8f43ddc9/</id>
    <published>2020-06-29T05:33:58.000Z</published>
    <updated>2020-06-29T06:16:06.150Z</updated>
    
    <content type="html"><![CDATA[<p>我们要想把一个系统搞清楚，首先要把它的线程模型弄明白。比如它是单线程的还是多线程的？如果它是单线程的，那逻辑就比较简单了，像mediasoup就是单进程多实例的模型；如果是多线程的，那它的线程是如何分配的？每个线程的作用是什么？我们必须把这些都要弄清楚才行，否则我们就无法将这个系统彻底搞明白。</p><a id="more"></a><p>在分析 <code>janus</code> 的时候，我们也应尊循上面的原则。因此在分析<code>janus</code>之前，我们先来问几个问题，<code>janus</code>是多线程的模式吗？如果是多线程模式，那它一共有几个线程呢？ 这些线程又分别起什么作用？</p><p>如果我们将上面的问题回答好了，我想我们基本上就将<code>janus</code>的线程模型搞清楚了，搞清了它的线程模型也就撑握了<code>janus</code>的系统大体脉络。</p><h1 id="janus是多线程模式吗？"><a href="#janus是多线程模式吗？" class="headerlink" title="janus是多线程模式吗？"></a>janus是多线程模式吗？</h1><p>其实这个问题非常好回答，通过查看<code>janus</code>的主文件janus.c我们就能知道答案了。在janus.c中我们可以发现下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">GThread *watchdog &#x3D; g_thread_try_new(&quot;timeout watchdog&quot;, &amp;janus_sessions_watchdog, watchdog_loop, &amp;error);</span><br><span class="line">...</span><br><span class="line">GThread *requests_thread &#x3D; g_thread_try_new(&quot;sessions requests&quot;, &amp;janus_transport_requests, NULL, &amp;error);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>janus</code>是基于Linux 的GLIB库开发出来的，因此所有对系统的调用都是使用的GLIB库的API。而<code>g_thread_try_new</code>函数正中GLIB中用来创建线程的，在<code>g_thread_try_new</code>的底层真正调用的是<code>pthread</code>的相关API。</p><p><strong>通这上面的分析，我们可以知道janus是多线程的模式。</strong></p><h1 id="janus一共有几个线程？"><a href="#janus一共有几个线程？" class="headerlink" title="janus一共有几个线程？"></a>janus一共有几个线程？</h1><p>除了我们上面介绍的两个线程外，<code>janus</code>还使用了线程池的概念。在<code>janus</code>的初始化阶段就将线程池创建出来了。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">tasks &#x3D; g_thread_pool_new(janus_transport_task, NULL, -1, FALSE, &amp;error);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>查看<code>g_thread_pool_new</code>API的帮助文档，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GThreadPool *</span><br><span class="line">g_thread_pool_new (GFunc func,</span><br><span class="line">                   gpointer user_data,</span><br><span class="line">                   gint max_threads,</span><br><span class="line">                   gboolean exclusive,</span><br><span class="line">                   GError **error);</span><br></pre></td></tr></table></figure><p>通过这个定义我们可以知道<code>janus</code>创建的线程池时并没有对线程数进制控制。也就是说它可以开出系统可以支持的最大限度的线程个数。<strong>会在高并发时出现性能问题呢？这个还要等我们后面的深入分析才能清楚，目前来说这行代码还是有风险的。</strong></p><p>下面我们总结一下，通过对janus.c文件的分析，我们现在可以知道<code>janus</code>的线程模型是由两个专用线程<code>watchdog</code>、<code>request</code>和一个通用任务线程池构成的。如下图所示：</p><p><img data-src="https://cdn.avdancedu.com/image/article/janus_thread/janus_thread.jpg" alt="janus线程模型"></p><p>了解了<code>janus</code>的线程模型后，下面我们来看一下 <code>janus</code> 每个线程的作用吧。</p><h1 id="每个线程的作用"><a href="#每个线程的作用" class="headerlink" title="每个线程的作用"></a>每个线程的作用</h1><p>通过阅读代码，我们可以了解到这几个线程的主要作用是什么，下面我们来一一介绍一下。</p><p><strong>首先是主线程</strong>，这个线程的主要作用就是初始化的工作。主要包括以下几方面的工作：</p><ul><li>从配置文件中读配置信息，然后根据配置信息进行初始化工作</li><li>启动其它线程</li><li>动态加载plugin</li></ul><p><strong>WatchDog 线程</strong>，通过名子我们基本上就可以清楚它的作用了。它是监控线程，它每隔２秒做一次扫描，查看transport的session是否过期了。如果过期了，则给对应的transport发通知让transport结束处理。需要注意的是，这里的 trasnport代表的是不同协议的接入口，如RabbitMQ、MQTT、HTTP等。</p><p><strong>Request线程</strong>，用于处理接口请求。一般将接口请求分为两大类，文本类请求和命令类请求。如果是文本类请求的，则会启动新线程（从线程池中获取）进行处理；如果是命令的类的，则可以直接处理。当然对于命令类型的Request可能处理上会比较复杂，有可能会分成多个阶段处理，而在每个不同的阶段又会生成新的Request。</p><p><strong>最后一个就是线程池了</strong>，线程池的作用上面我已经介绍了，就是在处理Request时会从线程池中分配线程，然后执行Request任务，任务完成后再回收到线程池里。　</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>通过上面的描述我们可以看到<code>janus</code>的线程模型并不复杂，它启动了两个专门的线程，一个用于处理transport的session是否过期；另一个用于处理Request请求，当收到Request请求后，它又会把请求交给新的线程做延时处理。</p><p>以上我们就将 <code>janus</code> 的线程模型分析完了，读到这里我相信你已经对<code>janus</code>的线程模型有了一个大体的了解了。当然你仍然会很许多疑惑，这只能对照着<code>janus</code>的代码分析才能让你体会的更深刻！</p><p>谢谢！</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门》</a></li><li><a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">《百万级高并发WebRTC流媒体服务器设计与开发》</a></li><li><a href="https://time.geekbang.org/column/intro/207" target="_blank" rel="noopener">《从0打造音视频直播系统》</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们要想把一个系统搞清楚，首先要把它的线程模型弄明白。比如它是单线程的还是多线程的？如果它是单线程的，那逻辑就比较简单了，像mediasoup就是单进程多实例的模型；如果是多线程的，那它的线程是如何分配的？每个线程的作用是什么？我们必须把这些都要弄清楚才行，否则我们就无法将这个系统彻底搞明白。&lt;/p&gt;
    
    </summary>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/categories/WebRTC/"/>
    
    
      <category term="thread" scheme="https://blog.avdancedu.com/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>深入理解janus中的plugin管理</title>
    <link href="https://blog.avdancedu.com/26c3d930/"/>
    <id>https://blog.avdancedu.com/26c3d930/</id>
    <published>2020-06-29T05:05:29.000Z</published>
    <updated>2020-06-29T05:24:24.710Z</updated>
    
    <content type="html"><![CDATA[<p><code>janus</code>中的<code>plugin</code>是其非常重要的一部分内容，今天我们就来对这块内容做一下分析，看看<code>janus</code>是如何实现<code>plugin</code>的，以及它的工作原理是怎样的。</p><a id="more"></a><h2 id="janus的架构模型"><a href="#janus的架构模型" class="headerlink" title="janus的架构模型"></a>janus的架构模型</h2><p><code>janus</code>的最大特色就是可以以插件的方式对业务模块进行管理。比如当你想实现新业务时，按照<code>janus Plugin</code>的要求写一个<code>plugin</code>，然后将它放到指定目录下，这样<code>janus</code>在启动时就可以将它加载到内存中。</p><p>下面这张图是janus的整体架构图：</p><p><img data-src="https://cdn.avdancedu.com/image/article/janus_plugin/janus_plugin.png" alt="janus架构图"></p><p>从上面这张图我们可以看到，<code>janus</code>在设计时被分成了两层，即<code>核心层</code>和<code>插件层</code>。核心层主要用于资源的分配（如线程的启动与分配）、底层事件处理、各种WebRTC协议的实现及处理等；插件层用于业务处理，各种传输类型命令的处理等。</p><p>从中我们可以知道，这样的架构设计及管理方式特别适合变化比较快的业务模型。因为我们可以随时生成一个新的janus插件，并将它加载到内存中。</p><p>OK，了解了<code>janus</code>的架构，我们再来看看janus是如何实现插件管理的吧。</p><h2 id="Linux-系统下动态库的动态加载"><a href="#Linux-系统下动态库的动态加载" class="headerlink" title="Linux 系统下动态库的动态加载"></a>Linux 系统下动态库的动态加载</h2><p>要想真正理解janus的插件管理，我们首先要知道Linux系统是如何动态加载库的，这是我们理解 janus 插件管理的基础。</p><p>在Linux系统中，动态加载库其实很容易，只要用两个API 就可以了，即 <strong>dlopen</strong> 和 <strong>dlsym</strong> 。它们的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;dlfcn.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  path: 被加载到内存中的动态库路径</span><br><span class="line"> *  mode: RTLD_LAZY，用时加载；RTLD_NOW，立即加载；</span><br><span class="line"> *  return: handle，即被加载的动态库的内存地址</span><br><span class="line"> *&#x2F;</span><br><span class="line">void* dlopen(const char* path, int mode);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * handle: dlopen 的返回值</span><br><span class="line"> * symbol: 指向动态库中的符号，如函数，变量等</span><br><span class="line"> * return: 返回在内存中的符号地址</span><br><span class="line"> *&#x2F;</span><br><span class="line">void* dlsym(void* handle, const char* symbol);</span><br></pre></td></tr></table></figure><p>其中，<strong>dlopen</strong> 用于将动态库加载到内存中；<strong>dlsym</strong> 用于查找被加载到内存中的动态库的函数或变量的地址。</p><p>接下来我们就使用这两个API 来演示一下如何在 Linux 系统下动态加载库。</p><p>要想做这个演示，首先我们要写一个动态库。这个动态库特别简单，就一个函数 <strong>add()</strong> ， 用于加法运算。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;源码</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int add(int a, int b)&#123;</span><br><span class="line">  return a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;编译</span><br><span class="line">gcc -shared -o add.so add.c</span><br></pre></td></tr></table></figure><p>通过上面的操作我们就有了一个add.so的动态库。接下来我们再来看看如何使用 <strong>dlopen</strong> 及 <strong>dlsym</strong> 将上面生成的库动态库加载到内存中，并调用它的 <strong>add()</strong> 方法吧。具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include &lt;dlfcn.h&gt;</span><br><span class="line"></span><br><span class="line">typedef int(*FUNC)(int,int);</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])&#123;</span><br><span class="line">  void* handler &#x3D; dlopen(&quot;.&#x2F;add.so&quot;, RTLD_NOW);</span><br><span class="line">  if(!handler)&#123;</span><br><span class="line">    printf(&quot;Failed to load so!\n&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  FUNC func &#x3D; (FUNC)dlsym(handler, &quot;add&quot;);</span><br><span class="line">  int r &#x3D; func(10, 20);</span><br><span class="line">  printf(&quot;the result is : %d\n&quot;, r);</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;编译</span><br><span class="line">gcc -g -o loadso mytest.c</span><br></pre></td></tr></table></figure><p>上面的这段代码是不是很简单？短短的几行代码就向你展示了在 Linux/Mac 系统下动态加载并调用动态库中方法的具体步骤。有了上面的知识，我们再来看janus的实现就很容易理解它是如何做的了。</p><h2 id="janus-加载Plugin"><a href="#janus-加载Plugin" class="headerlink" title="janus 加载Plugin"></a>janus 加载Plugin</h2><p>janus实现加载插件的代码量很大，但核心代码就那么几行，只要我们将核心代码抽取出来，我们就会发现其实它与我们上面讲的代码几乎是一模一样的。下面我们来看看janus 是如何动态加载库的吧。</p><p>为了方便janus专门创建了一个目录用于存放插件。在janus启动时它会遍历该目录，并将目录中的插件一个个动态加载到内存中。经整理后的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>((pluginent = readdir(dir))) &#123;</span><br><span class="line">  ......</span><br><span class="line">  g_snprintf(pluginpath, <span class="number">1024</span>, <span class="string">"%s/%s"</span>, path, pluginent-&gt;d_name);</span><br><span class="line">  <span class="keyword">void</span> *plugin = dlopen(pluginpath, RTLD_NOW |   RTLD_GLOBAL);</span><br><span class="line">  ......</span><br><span class="line">  create_p *create = (create_p*) dlsym(plugin, <span class="string">"create"</span>);</span><br><span class="line">  ......</span><br><span class="line">  janus_plugin *janus_plugin = create();</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的这段核心代码是不是与我们上面 <strong>Linux 系统下动态库的动态加载</strong> 一节介绍的几乎是一样的？所以我们只要把基础知识撑握好了，再看一些复杂的实现时也就不会感觉很难了。</p><p>从上面的代码中我们还可以看到，janus 中的每个插件都实现了create 函数。该函数会返回一个包含多个函数的结构体。这些函数是我们实现janus插件必须要实现的，它们包括:</p><ul><li><code>init()</code>: 该函数是插件的初始化函数，像读取配置文件等操作都应该在这个函数中实现。</li><li><code>destroy()</code>: 插件被关闭的时候被调用</li><li><code>get_api_compatibility()</code>: 该方法只需要返回janus的API版本即可，用于控制不同janus版本是否兼容</li><li><code>get_version()</code>: 返回版本号(例如 3)</li><li><code>get_version_string()</code>: 返回字符串格式的版本号(例如, “v1.0.1”)</li><li><code>get_description()</code>: 返回插件的详细信息</li><li><code>get_name()</code>: 返回插件的短名子</li><li><code>get_package()</code>:返回插件的唯一包标识 (例如., “janus.plugin.myplugin”);</li><li><code>create_session()</code>: 在你和客户端之间创建一个session</li><li><code>handle_message()</code>: 处理对方发送给你的消息</li><li><code>handle_admin_message()</code>: 来自Admin API的消息</li><li><code>setup_media()</code>: 创建socket，建立与客户端<code>peerConnection</code>之间的连接</li><li><code>incoming_rtp()</code>: 接收客户端发过来的<code>rtp</code>包</li><li><code>incoming_rtcp()</code>: 接收客户端发过来的<code>rtcp</code>消息</li><li><code>incoming_data()</code>: 接收客户端通过<code>SCTP DataChannel</code>发过来的数据</li><li><code>data_ready()</code>: 检查数据是否可以通过<code>SCTP DataChannel</code>发送了</li><li><code>slow_link()</code>: 客户端发过来很多<code>NACK</code>，说是此时网络质量变差了</li><li><code>hangup_media()</code>: 客户端关闭了<code>PeerConnection</code></li><li><code>query_session()</code>: 查询在你与客户端之间的<code>session</code>信息</li><li><code>destroy_session()</code>: 销毁<code>session</code></li></ul><p>对于一个插件来讲，上面的方法中除了 <code>incoming_rtp</code> 、<code>incoming_rtcp</code>、<code>incoming_data</code> 可以不实现外，其它的方法都必须实现。只有这样当插件被<code>janus</code>核心层加载之后，才可以被顺利的调用。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我重点向你介绍了<code>janus</code>是如何使用和管理<code>plugin</code>的，同时向你简要的介绍了<code>janus</code>的架构模型以及要实现一个<code>janus</code>插件要实现哪些函数。</p><p>当然，我们这里只是对<code>plugin</code>做了一个大体的讲解，很多细节这里并没有讲到，我会在后面的文档中做更详细的介绍 。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门》</a></li><li><a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">《百万级高并发WebRTC流媒体服务器设计与开发》</a></li><li><a href="https://time.geekbang.org/column/intro/207" target="_blank" rel="noopener">《从0打造音视频直播系统》</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;janus&lt;/code&gt;中的&lt;code&gt;plugin&lt;/code&gt;是其非常重要的一部分内容，今天我们就来对这块内容做一下分析，看看&lt;code&gt;janus&lt;/code&gt;是如何实现&lt;code&gt;plugin&lt;/code&gt;的，以及它的工作原理是怎样的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/categories/WebRTC/"/>
    
    
      <category term="plugin" scheme="https://blog.avdancedu.com/tags/plugin/"/>
    
  </entry>
  
  <entry>
    <title>janus深入分析系列文章</title>
    <link href="https://blog.avdancedu.com/aafa6b93/"/>
    <id>https://blog.avdancedu.com/aafa6b93/</id>
    <published>2020-06-29T02:04:44.000Z</published>
    <updated>2020-06-29T06:26:50.507Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/janus_deep/janus_deep.jpg" alt=""></p><p>说到WebRTC流媒体服务器就不得不提<code>janus</code>，它是WebRTC众多流媒体服务器中的重要一员，其以优越的性能、丰富的功能、灵活的配置而著称。由于工作的原因，最近这段时间一直在分析<code>janus</code>，陆续整理出了我对janus的一些分析，希望这些文章对你了解<code>janus</code>能有所帮助。</p><a id="more"></a><h2 id="janus系列文章"><a href="#janus系列文章" class="headerlink" title="janus系列文章"></a>janus系列文章</h2><p>下面的这些文章是按照<strong>认知</strong>、<strong>使用</strong>、<strong>逐步深入</strong>的顺序做了编排，这种阅读顺序应该会使你更容易理解<code>janus</code>的整个运行机制。</p><ul><li><a href="http://avdancedu.com/947c722a/" target="_blank" rel="noopener">WebRTC流媒体服务器比较</a></li><li><a href="https://avdancedu.com/ed54b3d4/" target="_blank" rel="noopener">音视频会议系统-janus的编译与布署</a></li><li><a href="https://avdancedu.com/fdfe2594/" target="_blank" rel="noopener">janus各文件及目录的作用</a></li><li><a href="https://avdancedu.com/8f43ddc9/" target="_blank" rel="noopener">janus的线程模型</a></li><li><a href="https://avdancedu.com/26c3d930/" target="_blank" rel="noopener">深入理解janus的插件管理</a></li><li><a href="https://avdancedu.com/bb906872/" target="_blank" rel="noopener">janus的videoroom插件信令实现</a></li><li><a href="https://avdancedu.com/d7281c13/" target="_blank" rel="noopener">janus.js源码分析</a></li><li><a href="https://avdancedu.com/5ae5ee2f/" target="_blank" rel="noopener">janus.js的使用</a></li></ul><p>更深入的文章还在不断整理中，会陆续加到这个系列文章中来。如果你感兴趣也可以将你的分析心得放到这里，与大家一起分享。</p><p>另外，也欢迎大家一起讨论，文中有描述的不清楚的地方也希望大家指正批评！ </p><p>谢谢！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://coding.imooc.com/class/415.html" target="_blank" rel="noopener">音视频系统入门</a></li><li><a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">WebRTC入门与实战</a></li><li><a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">百万级WebRTC流媒体服务器设计与开发</a></li><li><a href="https://time.geekbang.org/column/article/132863" target="_blank" rel="noopener">从0开始打造音视频直播系统</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/janus_deep/janus_deep.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;说到WebRTC流媒体服务器就不得不提&lt;code&gt;janus&lt;/code&gt;，它是WebRTC众多流媒体服务器中的重要一员，其以优越的性能、丰富的功能、灵活的配置而著称。由于工作的原因，最近这段时间一直在分析&lt;code&gt;janus&lt;/code&gt;，陆续整理出了我对janus的一些分析，希望这些文章对你了解&lt;code&gt;janus&lt;/code&gt;能有所帮助。&lt;/p&gt;
    
    </summary>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/categories/WebRTC/"/>
    
    
      <category term="janus" scheme="https://blog.avdancedu.com/tags/janus/"/>
    
  </entry>
  
  <entry>
    <title>janus各文件及目录的作用</title>
    <link href="https://blog.avdancedu.com/fdfe2594/"/>
    <id>https://blog.avdancedu.com/fdfe2594/</id>
    <published>2020-06-28T11:57:29.000Z</published>
    <updated>2020-06-29T05:31:43.573Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/janus_file/janus_arch.jpg" alt="janus架构图"></p><p>在<a href="https://avdancedu.com/ed54b3d4/" target="_blank" rel="noopener">《音视频会议系统-janus的安装与布署》</a>一文中我已经向你介绍了如何布署<code>janus</code>，今天我们再来了解一下<code>janus</code>的源码，看看<code>janus</code>包括哪些文件以及它们所起的作用是什么。</p><a id="more"></a><h2 id="下载-janus-源码"><a href="#下载-janus-源码" class="headerlink" title="下载 janus 源码"></a>下载 janus 源码</h2><p><code>janus</code>源码可以在<a href="https://github.com/meetecho/janus-gateway" target="_blank" rel="noopener">这里</a>找到，执行下面命令就可将其下载下来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;meetecho&#x2F;janus-gateway.git</span><br><span class="line">cd janus-gateway</span><br></pre></td></tr></table></figure><h2 id="janus各源码文件的作用"><a href="#janus各源码文件的作用" class="headerlink" title="janus各源码文件的作用"></a>janus各源码文件的作用</h2><p>下载好<code>janus</code>源码后，你可以看到<code>janus</code>目录下有很多文件，这里我列出了比较重要的几个文件，下面来说明一下它们起所的作用是什么。目录列表如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">events           # 主要用于各种事件消息的分析</span><br><span class="line">plugins          # 各种业务插件，所有的业务应用都在这里实现</span><br><span class="line">transports       # 用于处理各种网络信令，HTTP、WebSocket、MQTT等</span><br><span class="line">docs             <span class="meta"># janus的文档，它是通过 Doxygen 生成的，janus的文档还是很全面的</span></span><br><span class="line">html             # Web端的Demo都放在这里</span><br><span class="line">rtcp.h           # RTCP 是RTP的控制协议</span><br><span class="line">rtcp.c           # RTCP 协议的具体实现</span><br><span class="line">rtp.c            # RTP协议的实现，它用于传输音视频数据</span><br><span class="line">rtp.h            # RTP 协议的头文件</span><br><span class="line">rtpsrtp.h        # SRTP 协议</span><br><span class="line">sctp.c           # SCTP 协议的实现</span><br><span class="line">sctp.h           # SCTP 协议的头文件</span><br><span class="line">sdp.c            # SDP 协议的实现</span><br><span class="line">sdp.h            # SDP 协议的头文件</span><br><span class="line">sdp-utils.c      # 处理 SDP 的常用工具</span><br><span class="line">sdp-utils.h</span><br><span class="line">test             # 测试文件所在目录</span><br><span class="line">record.c         <span class="meta"># janus的录制功能在该文件中实现</span></span><br><span class="line">record.h</span><br><span class="line">ice.c            <span class="meta"># janus 使用 libnice 实现 ICE 功能，该文件是对libnice库的封装</span></span><br><span class="line">ice.h</span><br><span class="line">janus.c          # 该文件是janus的主框架程序，里边做了很多事儿</span><br><span class="line">janus.h</span><br><span class="line"><span class="built_in">log</span>.c            # 日志</span><br><span class="line"><span class="built_in">log</span>.h</span><br><span class="line">dtls-bio.c       # DTLS 中 BIO 的实现</span><br><span class="line">dtls-bio.h</span><br><span class="line">dtls.c           # DTLS 协议实现</span><br><span class="line">dtls.h</span><br><span class="line">events.c         # 配合events插件与janus core连接用的</span><br><span class="line">events.h</span><br></pre></td></tr></table></figure><p>对于上面的文件我们可能将它们分成几大类：</p><ul><li>业务插件，<code>plugins</code>目录下的所有文件都属于该类，其主要作用是实现不同的业务逻辑的服务端，如<code>echotest</code>、<code>videoroom</code>、<code>videocall</code>等。</li><li>事件分析，<code>events</code>目录下的所有文件以及<code>events.c|h</code>，其作用是收集事件消息，做分析使用。这个功能只能高级用户才会用，对于一般用户来说可以不关注它。</li><li>协议，包括 <code>rtp.c|h</code>、<code>rtcp.c|h</code>、<code>rtpsrtp.h</code>、<code>stcp.c|h</code>、<code>sdp.c|h</code>、<code>dtls.c|h</code>、<code>dtls-bio.c|h</code>，这些都是用于处理不同协议的，每个文件都比较独利。</li><li>日志，包括 <code>log.c|h</code>，这个应该一眼就可以看出来。</li><li>浏览器Demo，<code>html</code>目录中的所有文件，主要包括一些demo程序，如videoroom、echotest等。</li><li>信令传输，<code>transports</code>目录下的文件属于该类，作用是接收不同传输协议发送过来的消息，并使用同样的协议将响应消息返回。</li><li>数据传输，<code>ice.c|h</code>，它是对<code>libnice</code>库的封装，用于媒体数据的传输。</li><li>janus核心，<code>janus.c|h</code>，这是<code>janus</code>中最核心的文件，程序的启动，插件的加载，数据的流转都是通过它来实现的。</li></ul><p>在上面几个类别中， <strong>janus核心</strong>、<strong>数据传输</strong>、<strong>信令传输</strong>、<strong>业务插件</strong>、<strong>浏览器Demo</strong> 中的代码是比较重要的，所以是你在阅读代码时需要重点看的内容。由于<strong>信令传输</strong>、<strong>业务插件</strong>、<strong>浏览器Demo</strong>都是目录，里边还包括了很多文件，所以下面我们再来看看这三个目录中都包括了那些文件。</p><h3 id="信令传输"><a href="#信令传输" class="headerlink" title="信令传输"></a>信令传输</h3><p>进入到 <code>transports</code> 目录，你会它有以下几个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">transport.h             # 定义了&#96;信令传输&#96;插件的接口</span><br><span class="line">transport.c             # 定义了几个通用的释放资源的函数</span><br><span class="line">janus_http.c            # HTTP 接口，默认使用的接口</span><br><span class="line">janus_mqtt.c            # MQTT 接口，编译时需要明确指定才会编入janus</span><br><span class="line">janus_pfunix.c          # UNIX 接口</span><br><span class="line">janus_nanomsg.c         # NanoMSG 接口</span><br><span class="line">janus_rabbitmq.c        # RabbitMQ 接口</span><br><span class="line">janus_websockets.c      # Websocket 接口</span><br></pre></td></tr></table></figure><p><code>janus</code>支持的信令接口方式还是蛮全的，这是它的一大优势。用户可以选择自己喜欢的接入方式进行接入。通过上面的描述你应该很容易判断出每个文件的作用，你对那个感兴趣就可以专门看那个文件。默认情况下<code>janus</code>使用的是HTTP接口，因此该接口也是最成熟的。</p><h3 id="业务插件"><a href="#业务插件" class="headerlink" title="业务插件"></a>业务插件</h3><p><code>janus</code>支持很多业务插件，这对于很多用户来说也是一个非常棒的特点，我们来看一下它都支持那些插件吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">plugin.h                # 定义了业务插件的接口</span><br><span class="line">plugin.c                # 实现了一些公用的释放资源的函数</span><br><span class="line">janus_echotest.c        # 回显业务插件</span><br><span class="line">janus_videocall.c       # 1:1视频通讯业务插件</span><br><span class="line">janus_videoroom.c       # 会议业务插件</span><br><span class="line">janus_textroom.c        # 文本聊天室插件</span><br><span class="line">janus_streaming.c       # 传输直接流插件，可以播放视频文件，或其它的RTP数据流</span><br><span class="line">streams</span><br><span class="line">janus_recordplay.c      # 录制回放业务插件</span><br><span class="line">recordings</span><br><span class="line">janus_sip.c             # sip 业务插件，主要用于与电话业务的互通</span><br><span class="line">janus_nosip.c           # 包含sip信令业务插件，用它可以中转RTP数据</span><br><span class="line">janus_audiobridge.c     # 音频会议插件</span><br><span class="line">janus_voicemail.c       # 语言信箱业务插件</span><br><span class="line">janus_lua.c             # lua 语言开发插件</span><br><span class="line">janus_lua_extra.h</span><br><span class="line">janus_lua_extra.c</span><br><span class="line">janus_lua_data.h</span><br><span class="line">lua</span><br><span class="line">janus_duktape.c         # duktape语言插件</span><br><span class="line">janus_duktape_extra.h</span><br><span class="line">janus_duktape_extra.c</span><br><span class="line">janus_duktape_data.h</span><br><span class="line">duktape</span><br><span class="line">duktape-deps</span><br></pre></td></tr></table></figure><p>通过上面的文件列表，我们看到<code>janus</code>支持的插件可真不少，有会议视会议的、1：1通话的、SIP、RTP、流…等等。这些插件几乎含盖的所有的业务场景。对于用户来话，要以根据自己的需求选择上面的业务插件进行修改即可完成自己的业务了。</p><p>最后我们再来看看客户端 Demo。</p><h3 id="HTML-Demo"><a href="#HTML-Demo" class="headerlink" title="HTML Demo"></a>HTML Demo</h3><p>在<code>janus</code>的html目录中有很多文件，其中大部分文件是与上面<code>业务插件</code>中的内容是对应的。也就是说一个业务插件对应一个HTML Demo。所以这块的内容大家自己看一下就可以了。我就不在这里一一列出来了。</p><p>通过上面的描述，我们大体上可以知道<code>janus</code>的实现并不是特别复杂。它实现了RTP/RTCP、SRTP、SCTP、DTLS/DTLS-BIO、SDP 等 WebRTC 必要的协议，而对于数据的传输则是使用<code>libnice</code> 库，并通过<code>ice.c|h</code>对libnice 做了一层封装。</p><p>除此之外，它所有的业务层都是以<code>plugin</code>的方式实现的，这对于后面的业务拓展有很大的优势。当我们要实现一个新业务时，只要按照 plugin 的规则进行开发就好了，非常简单。</p><p>另外，janus是用纯C实现的，并且使用了Linux社区丰常优秀的库<code>glib</code>(注意不是glibc)，这个库的性能非常好，对于在Linux 下开发的同学来说对它应该十分熟悉。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过本文，你应该对<code>janus</code>的源码有了一个大体功能的了解。由于<code>WebRTC</code>使用了很多的协议（如 RTP/RTCP、DTLS、SDP等），因此作为服务端的<code>janus</code>也必须实现这些协议，这样才能与<code>WebRTC</code>进行通信。</p><p>对于<code>janus</code>使用的这些协议可能很多同学会觉得一脸懵B，不知道其中的原理和作用，如果你对这块感兴趣的话，可以去看我的网课<a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门》</a>，在课程里我对这些协议都做了详细介绍。</p><p>如果你有一定基础的话，现在应该知道<code>janus</code>的实现并不是特别复杂，但它的架构设计还是很值得借鉴的，尤其是<code>plugin</code>的设计方案。</p><p>今天我只是对<code>janus</code>做个初步分析，后面会对它的一些性能做下详细分析，静请期待！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门》</a></li><li><a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">《百万级高并发WebRTC流媒体服务器设计与开发》</a></li><li><a href="https://time.geekbang.org/column/intro/207" target="_blank" rel="noopener">《从0打造音视频直播系统》</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/janus_file/janus_arch.jpg&quot; alt=&quot;janus架构图&quot;&gt;&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://avdancedu.com/ed54b3d4/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《音视频会议系统-janus的安装与布署》&lt;/a&gt;一文中我已经向你介绍了如何布署&lt;code&gt;janus&lt;/code&gt;，今天我们再来了解一下&lt;code&gt;janus&lt;/code&gt;的源码，看看&lt;code&gt;janus&lt;/code&gt;包括哪些文件以及它们所起的作用是什么。&lt;/p&gt;
    
    </summary>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/categories/WebRTC/"/>
    
    
      <category term="janus" scheme="https://blog.avdancedu.com/tags/janus/"/>
    
  </entry>
  
  <entry>
    <title>音视频会议系统-janus的编译与布署</title>
    <link href="https://blog.avdancedu.com/ed54b3d4/"/>
    <id>https://blog.avdancedu.com/ed54b3d4/</id>
    <published>2020-06-28T11:13:12.000Z</published>
    <updated>2020-06-29T04:13:49.754Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/janus_deploy/janus.jpg" alt=""></p><p>说到WebRTC流媒体服务器就不得不提janus。说实话我以前对这款流媒体服务器并没有进行特别深入的研究，不过2019年10月我有幸作为声网RTC大会 Workshop 分会场的主讲嘉宾及串场人与janus的创始人<strong>Lorenzo Miniero</strong>有了一次深入交流，从中了解到janus的强大，因此决定有时间一定要对janus做下深入分析。</p><a id="more"></a><p><img data-src="https://cdn.avdancedu.com/image/article/janus_deploy/agora.jpg" alt="声网RTC大会"></p><p>正好前段时间忙完了手头的一些工作，终于可以有时间来对janus做详细研究了，而本篇则是对janus分析的第一篇文章。</p><p>下面我们就来看一下如何在一台 Ubuntu 系统下安装布署 janus。</p><h1 id="janus的布署方法"><a href="#janus的布署方法" class="headerlink" title="janus的布署方法"></a>janus的布署方法</h1><p>不得不说janus提供的文档还是非常全面的，如果你英文比较好的话，完全可以按它的文档进行操作。但对于一些新手来说，通过阅读本文可以让你快速的在本机搭建出janus Demo，所以本文对你仍然是非常有意义的。</p><h2 id="布署环境"><a href="#布署环境" class="headerlink" title="布署环境"></a>布署环境</h2><p>janus的官方文档建议你把它安装在Linux系统上，可以是 Ubuntu、CentOS等。当然你也可以在MacOS上安装它，而文档中明确说明它不支持Ｗindows系统，因此千万不要再在Windows上浪费时间了。</p><p>对于我来说，我一直比较倾向于使用Ubuntu系统，最主要的原因是安装依赖包比较方便。如果你是Linux新手，我更是强烈推建你使用Ubuntu，这样可以让你更快速入门Linux。而CentOS安装依赖包则会麻烦得多，虽然它也提供yum（类似Ubuntu中的apt）工具，但有很多库都必须通过源码编译的方式安装，这样很繁琐。</p><p>今天我们就使用<strong>Ubuntu系统</strong>作为janus的布署环境，而且这个环境是一台<strong>本地主机</strong>，而不是云主机，这样可以大大减少很多不必要的麻烦。</p><h2 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h2><p>在我们正式布署janus之前，需要先在Ubuntu系统上安装上必要的依赖包。在Ubuntu上安装依赖包非常方便，只要执行下面的命令就好了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libmicrohttpd-dev libjansson-dev \</span><br><span class="line">       libssl-dev libsofia-sip-ua-dev libglib2.0-dev libopus-dev \</span><br><span class="line">       libogg-dev libcurl4-openssl-dev liblua5.3-ev libconfig-dev\</span><br><span class="line">       pkg-config gengetopt libtool automake libscrtp-dev \</span><br><span class="line">               libwebsockets-dev  librabbitmq-dev libnanomsg-dev libnice-dev \</span><br><span class="line">               gtk-doc-tools doxygen graphviz</span><br></pre></td></tr></table></figure><p>除了以上这些可以通过 apt工具安装的依赖包外，还有一个依赖库是必须通过源码安装的，它就是libsrtp库。</p><p>libsrtp库的主要作用是对数据进行加密。之所以要通过源码安装，是因为在apt源上的libsrtp库没有将ssl库编译上，而janus又需要使ssl库对数据做最终的加密，所以我们只能使用源码的方式安装了。具体操作步骤如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;cisco&#x2F;libsrtp&#x2F;archive&#x2F;v2.2.0.tar.gz</span><br><span class="line">tar xfv v2.2.0.tar.gz</span><br><span class="line">cd libsrtp-2.2.0</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr --enable-openssl</span><br><span class="line">make shared_library &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure><h2 id="编译安装janus"><a href="#编译安装janus" class="headerlink" title="编译安装janus"></a>编译安装janus</h2><p>布署环境搭建好之后，编译安装janus还是非常简单的，就按下面的三步执行就好了：</p><ul><li>下载 janus 源码</li><li>执行 ./configure 生成 Makefile 文件</li><li>执行 make -j 4 &amp; sudo make install</li></ul><p>首先我们来看看如何下载janus的源码，操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;meetecho&#x2F;janus-gateway.git</span><br><span class="line">cd janus-gateway</span><br></pre></td></tr></table></figure><p>源码下载好后，执行./configure就可以生成Makefile文件了。但需要注意的是，在执行./configure之前，先要执行autogen.sh脚本，这样才能生成./configure文件。具体操作步骤如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;autogen.sh</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;janus</span><br></pre></td></tr></table></figure><p>当./configure执行完成后，Makefile文件就生成了，紧接着我们要开始编译安装 janus 了。按下面的执行步骤操作就好了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make -j 4</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>通过上面的步骤，我们就将janus编译好并成功安装了。</p><h1 id="启动janus"><a href="#启动janus" class="headerlink" title="启动janus"></a>启动janus</h1><p>安装好janus 后，启动它非常容易，但在启动之前，我们还要为它准备好配置文件。</p><p>janus在启动时会分析配置文件，然后按照配置文件中的信息启动加载对应的模块。该如何构建配置文件呢？对于初学janus的新手来说，看到janus有一堆的参数，在构造配置文件时可能就有点懵了。</p><p>不过janus已经为我们想好了解决方案，就是从它的配置文件模板中拷贝一份作为janus的配置文件。其中最简单的就是将 janus.jcfg.sample作为配置文件即可。具体操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;installdir&gt;&#x2F;etc&#x2F;janus&#x2F;</span><br><span class="line">cp janus.jcfg.sample janus.jcfg</span><br></pre></td></tr></table></figure><p>有了janus配置文件之后，我们就可以直接启动janus了，执行如下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;janus</span><br></pre></td></tr></table></figure><p>OK，到目前为止，我们就已经将janus启动好了。此时，如果有用户连接janus的话，你就可以从终端上看到对应的连接信息。</p><p>上面的启动方式非常适合于我们观察和调试janus，但如果你想让它像服务器一样一直运行，则需要让janus到Linux系统的后台运行。这该如何实现呢？其实操作也很简单，只要执行下面的命令就好了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;janus &amp;</span><br></pre></td></tr></table></figure><h1 id="janus-Demo的布署"><a href="#janus-Demo的布署" class="headerlink" title="janus Demo的布署"></a>janus Demo的布署</h1><p>通过上面的步骤我们已经将janus网关布署好了，但此时janus Demo还无法使用，我们还必须搭建一台WebServer，将janus Demo 客户端发布出来才行。</p><p>关于WebServer的搭建方法我这里就不做详细介绍了，大家应该在网上都可以找到方法，比如使用 nginx、nodejs、Apache、Tomcat等都是可以的。</p><p>当WebServer搭建好后，将/usr/local/janus/share/janus/demo目录中的内容全部拷贝到WebServer的发布目录下即可，这样我们就大功告成了！</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>通过上面的描述，我们就将如何搭建janus Demo的步骤向你做了详细的介绍，让你知道了如何在Ubuntu下搭建janus服务，又该如何将janus Demo布署好。总结起来就是以下三步：</p><ul><li>安装依赖包</li><li>编译安装janus</li><li>布署WebServer，并将 janus Demo 代码放到 WebServer发布目录下</li></ul><p>需要注意的是，我这里提供的方法只适用于本机，如果你想在云服务器上布署 janus的话，还有其它一些工作要做。对于这一点，我在这里就不做详细论述了，有兴趣的同学可以去参考我在慕课网的课程。</p><p>谢谢！</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">《百万级高并发WebRTC流媒体服务器设计与开发》</a></li><li><a href="https://time.geekbang.org/column/intro/207" target="_blank" rel="noopener">《从0打造音视频直播系统》</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/janus_deploy/janus.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;说到WebRTC流媒体服务器就不得不提janus。说实话我以前对这款流媒体服务器并没有进行特别深入的研究，不过2019年10月我有幸作为声网RTC大会 Workshop 分会场的主讲嘉宾及串场人与janus的创始人&lt;strong&gt;Lorenzo Miniero&lt;/strong&gt;有了一次深入交流，从中了解到janus的强大，因此决定有时间一定要对janus做下深入分析。&lt;/p&gt;
    
    </summary>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/categories/WebRTC/"/>
    
    
      <category term="janus" scheme="https://blog.avdancedu.com/tags/janus/"/>
    
  </entry>
  
  <entry>
    <title>正确理解glib main loop</title>
    <link href="https://blog.avdancedu.com/40f49286/"/>
    <id>https://blog.avdancedu.com/40f49286/</id>
    <published>2020-06-26T15:08:55.000Z</published>
    <updated>2020-06-27T10:07:29.817Z</updated>
    
    <content type="html"><![CDATA[<p>我想应该很多人都不太了解<code>glib</code>库，只有那些长时间在Linux系统上搞开发的同学才知道这个库。但即便知道有这么一个库，使用它的人也少之又少。</p><p><code>glib</code>库是<code>Linux</code>系统下极重要的一个<code>C</code>语言开发的开源库，Linux系统下很多开具都是以它为基础的，比如说<code>GTK</code>、<code>gstreamer</code>以及我向大家介绍的<code>janus</code>程序。</p><a id="more"></a><p><code>glib</code>库涉及的内容很多，今天我主要给大家介绍一下<code>glib</code>中的<code>main loop</code>机制。实际<code>glib</code>的<code>main loop</code>在它的官方文档中有清晰的说明，地址在<a href="https://developer.gnome.org/glib/stable/glib-The-Main-Event-Loop.html#g-main-loop-new" target="_blank" rel="noopener">这里</a>大家可以自己阅读一下。</p><h2 id="什么是Main-Loop"><a href="#什么是Main-Loop" class="headerlink" title="什么是Main Loop"></a>什么是Main Loop</h2><p>实际上，<code>GLib</code>的<code>Main Loop</code>就是对 <code>select</code>、<code>pool</code>、<code>epoll</code>的封装。它可以处理不同类型的<code>源</code>，像文件描述符（普通文件、管道、socket)和超时。新的事件源类型可以通过<code>g_source_attach</code>添加到<code>Main Loop</code>上。</p><p>为了可以在不同的线程中处理不同的<code>源</code>集，每个<code>源</code>都与一个<code>GMainContext</code>相关。一个<code>GMainContext</code>只能运行在一个线程中，但<code>源</code>是可以跨线程的。在GMainContext或内置GSource上运行的所有函数都是线程安全的。</p><p>每个<code>源</code>都有没一个优先级，默认是<code>G_PRIORITY_DEFAULT</code>，也就是0。小于0的值有更高的优先权。高优先级的<code>源</code>总是优先于低优先级的<code>源</code>得到处理。</p><p>idle函数也能添加到<code>MainLoop</code>中，当没有任何更高优先级的事件需要处理时就会执行它。</p><p><code>GMainLoop</code>表示一个主循环。它由<code>g_main_loop_new</code>函数创建。添加了初始化事件源后，就可以调用<code>g_main_loop_run()</code>函数了。该函数会持续的检测每个事件源是否有新事件，然后处理这些新事件。当不需要处理事件时，可以调用<code>g_main_loop_quit()</code>退出<code>main loop</code>。</p><h2 id="如何创建一个新的事件源"><a href="#如何创建一个新的事件源" class="headerlink" title="如何创建一个新的事件源"></a>如何创建一个新的事件<code>源</code></h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我想应该很多人都不太了解&lt;code&gt;glib&lt;/code&gt;库，只有那些长时间在Linux系统上搞开发的同学才知道这个库。但即便知道有这么一个库，使用它的人也少之又少。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;glib&lt;/code&gt;库是&lt;code&gt;Linux&lt;/code&gt;系统下极重要的一个&lt;code&gt;C&lt;/code&gt;语言开发的开源库，Linux系统下很多开具都是以它为基础的，比如说&lt;code&gt;GTK&lt;/code&gt;、&lt;code&gt;gstreamer&lt;/code&gt;以及我向大家介绍的&lt;code&gt;janus&lt;/code&gt;程序。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="glib" scheme="https://blog.avdancedu.com/tags/glib/"/>
    
  </entry>
  
  <entry>
    <title>janus.js的使用</title>
    <link href="https://blog.avdancedu.com/5ae5ee2f/"/>
    <id>https://blog.avdancedu.com/5ae5ee2f/</id>
    <published>2020-06-24T12:48:27.000Z</published>
    <updated>2020-06-29T05:30:35.457Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/janus_jscall/jscall.jpg" alt=""></p><p>之前我在<a href="https://avdancedu.com/d7281c13/" target="_blank" rel="noopener">《janus前端核心库源码分析》</a>一文中已经向你详细分析了<code>janus.js</code>文件的实现，但对于大多同学来说，知道如何使用它才是最重要的。那具体我们该如何使用它呢？janus中的<code>videoroomtest.js</code>是一个不错的例子，今天就来分析一下<code>videoroomtest.js</code>，看看它是是如何使用<code>janus.js</code>的。</p><a id="more"></a><p>通过分析<code>videoroomtest.js</code>文件，你会发现使用<code>janus.js</code>的步骤很简单，只要下面三步即可：</p><ul><li>初始化<code>janus.js</code></li><li>创建<code>Janus</code>对象</li><li>attach 音视频流</li></ul><p>下面我就按上面的顺序向你逐一介绍<code>videoroomtest.js</code>是如何使用<code>janus.js</code>的。</p><h2 id="janus的初始化"><a href="#janus的初始化" class="headerlink" title="janus的初始化"></a>janus的初始化</h2><p>我们使用<code>janus.js</code>之前，第一步就是调用<code>Janus</code>的<code>类</code>方法<code>init</code>来初始化<code>janus.js</code>。方法的原型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Janus.init &#x3D; function(options)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>init</code>方法需要一个<code>JSON</code>格式的输入参数，它包括两个<code>域</code>: <code>debug</code>和一个回调函数<code>callback</code>。这样当<code>init</code>执行完成后，就可以通过<code>callback</code>将结果返回到应用层了。<code>videoroomtest.js</code>调用<code>Janus.init</code>的代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Janus.init(</span><br><span class="line">            &#123;</span><br><span class="line">                debug: &quot;all&quot;,</span><br><span class="line">                callback: function()&#123;...&#125;</span><br><span class="line">            &#125;</span><br><span class="line">          );</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面的代码非常简单，关键的一点是我们要知道传入的参数是<code>JSON</code> 格式的，它有两个域<code>debug</code>和<code>callback</code>即可。知道如何调用了，接下来我们再来看看<code>init</code>函数的实现。</p><p><code>janus.js</code>的<code>init</code>方法实现了什么功能呢？我们把<code>Janus.init</code>方法中的主干逻辑抽取出来，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Janus.init &#x3D; function(options) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if(Janus.initDone) &#123;</span><br><span class="line">        options.callback();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ...</span><br><span class="line">        Janus.initDone &#x3D; true;</span><br><span class="line">        options.callback();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中的<code>initDone</code>表示的是之前是否初始化过<code>janus.js</code>？而<code>options</code>是<code>init</code>方法的输入参数，通过它可以回调应用层。通过上面的代码我们可以知道<code>init</code>方法的功能其实蛮简单的，就是将<code>initDone</code>置位，并回调应用层。</p><p>接下来我们看一下<code>init</code>回调应用层后，在应用层又做了什么事儿。 输入参数<code>options</code>的<code>callback</code>方法在<code>videoroomtest.js</code>中是一个<code>匿名函数</code>，其主干逻辑代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">callback: function() &#123;</span><br><span class="line">    $(&#39;#start&#39;).one(&#39;click&#39;, function() &#123; ... &#125; )</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>正如你上面看到的，<code>callback</code>函数只有一行关键代码，即给<code>start</code> 键钮绑定了一个<code>click</code>方法。当用户点击<code>start</code>时执行该方法。那么应用层在<code>start</code>方法中又做了哪些事儿呢？</p><h2 id="创建Janus对象"><a href="#创建Janus对象" class="headerlink" title="创建Janus对象"></a>创建Janus对象</h2><p>下面的代码就是<code>start</code>方法的主逻辑，从中我们可以知道<code>start</code>方法中完成了使用<code>janus.js</code>的第二个关键步骤，即创建<code>Janus</code>对象。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">if(!Janus.isWebrtcSupported()) &#123;</span><br><span class="line">    ...</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">janus &#x3D; new Janus(</span><br><span class="line">                    &#123;</span><br><span class="line">                        server: server,</span><br><span class="line">                        success: function() &#123; ... &#125;,</span><br><span class="line">                        error: function(error) &#123; ... &#125;,</span><br><span class="line">                        destroyed: function() &#123; ... &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                 );</span><br></pre></td></tr></table></figure><p>在该方法中首先判断<code>浏览器</code>是否支持<code>WebRTC</code>，如果不支持则直接退出，否则创建<code>Janus</code>对象。在创建<code>Janus</code>对象时，需要给它传入了一个<code>JSON</code>格式的参数，该<code>JSON</code>对象包括以下几个<code>域</code>：</p><ul><li>server，Janus服务器地址</li><li>success，连接成功后执行的回调函数</li><li>error，连接失败后执行的回调函数</li><li>destroyed，连接销毁时的回调函数</li></ul><p>在上述几个<code>域</code>中，最关键的是<code>success</code>回调函数。它的含义是当Janus对象创建成功后，回调该函数到应用层。但对于这个回调函的详细介绍我们先<code>暂时</code>放一放，现在我们先来看看创建<code>Janus</code>对象时都做了哪些事儿，然后再来分析<code>success</code>回调函数。</p><p>Janus类的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function Janus(gatewayCallbacks) &#123;</span><br><span class="line">    ...</span><br><span class="line">    createSession(gatewayCallbacks);</span><br><span class="line">    ...</span><br><span class="line">    this.attach &#x3D; function(callbacks) &#123; createHandle(callbacks); &#125;;</span><br><span class="line">    function handleEvent(json, skipTimeout) &#123; ... &#125;;</span><br><span class="line">    function keepAlive() &#123;&#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建Session</span><br><span class="line">    function createSession(callbacks) &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F;与服务器相连</span><br><span class="line">        Janus.httpAPICall(server,</span><br><span class="line">                          &#123;</span><br><span class="line">                            ...</span><br><span class="line">                            &#x2F;&#x2F;处理服务器发过来的消息</span><br><span class="line">                            success: handleEvent(...)&#123; ... &#125;;</span><br><span class="line">                            ...</span><br><span class="line">                          &#125;);</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;绑定媒体流</span><br><span class="line">    function createHandle(callbacks) &#123;...&#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>通过上面的代码我们可以知道，在创建<code>Janus</code>对象时它会调用<code>createSession</code>函数。而在<code>createSession</code>函数内部会通过<code>Janus</code>的<code>类</code>方法<code>httpAPICall</code>与服务端建立<code>HTTP</code>连接。连接建立成功后，会回调<code>success</code>函数，也就是类中的<code>handleEvent</code>方法。</p><p><code>handleEvent</code>的功能我在<a href="https://avdancedu.com/d7281c13/" target="_blank" rel="noopener">《janus前端核心库源码分析》</a>一文中已经介绍过，它用于处理服务端发来的消息，并根据不同的消息类型做不同的逻辑处理。</p><p>现在我们可以总结一下创建<code>Janus</code>对象所做的事儿啦，其实就两件事儿：一与<code>janus</code>服务器建立连接(HTTP/WebSocket/…)；二处理<code>janus</code>服务器发来的各种消息。</p><p>接下来我们再来讨论一下<code>Janus</code>对象创建成功后，回调<code>success</code>干了些什么吧！</p><h2 id="attach-绑定媒体流"><a href="#attach-绑定媒体流" class="headerlink" title="attach 绑定媒体流"></a>attach 绑定媒体流</h2><p>正如上面所说，<code>Janus</code>创建成功后会回调输入参数中的<code>success</code>函数。这个函数<code>特别重要</code>，下面我们来看看在该函数中实现了什么逻辑吧。</p><p>实际上，<code>success</code> 回调函数做的事儿也很简单，只是调用了 <code>janus.attach</code> 方法，<strong>而attach正是我们使用janus.js的第三步</strong>。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">success: function() &#123;</span><br><span class="line">    janus.attach(</span><br><span class="line">                    &#123;</span><br><span class="line">                        plugin: &quot;janus.plugin.videoroom&quot;,</span><br><span class="line">                        opaqueId: opaqueId,</span><br><span class="line">                        success: function(pluginHandle) &#123; ... &#125;,</span><br><span class="line">                        error: function(error) &#123; ... &#125;,</span><br><span class="line">                        consentDialog: function(on) &#123; ... &#125;,</span><br><span class="line">                        iceState: function(state) &#123; ... &#125;,</span><br><span class="line">                        mediaState: function(medium, on) &#123; ... &#125;,</span><br><span class="line">                        webrtcState: function(on) &#123; ... &#125;,</span><br><span class="line">                        onmessage: function(msg, jsep) &#123; ... &#125;,</span><br><span class="line">                        onlocalstream: function(stream) &#123; ... &#125;,</span><br><span class="line">                        onremotestream: function(stream) &#123; ... &#125;,</span><br><span class="line">                        oncleanup: function() &#123; ... &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，该方法的作用在<a href="https://avdancedu.com/d7281c13/" target="_blank" rel="noopener">《janus前端核心库源码分析》</a>一文中也已经做过介绍，该方法可以让浏览器与服务端的<code>videoroom插件</code>绑定，以便获取媒体流。</p><blockquote><p>这里<code>绑定</code>的真实含义是建立WEBRTC连接。</p></blockquote><p>在调用<code>attach</code>方法时，也要传一个<code>JSON</code>格式的对象。在该对像包含了很多属性，这些属性的含义如下：</p><ul><li>plugin，要绑定的<code>janus</code>插件，这里要绑定插件为<code>janus.plugin.videoroom</code>。</li><li>opaqueId，一个随机值，插件的唯一ID。</li><li>success，<code>attach</code>方法执行成功后的回调函数。</li><li>error，<code>attach</code>方法执行失败后的回调函数。</li><li>consentDialog,</li><li>iceState，可以通过该函数更新ICE状态。在<code>videoroomtest.js</code>中没有做任何处理。</li><li>mediaState，可以通过该函数更新媒体状态。该方法也没有做任你可事儿。</li><li>webrtcState，更改WebRTC状态的回调函数。</li><li>onmessage，收到事件消自己的回调函数。</li><li>onlocalstream，收到本地流时的回调函数。</li><li>onremotestream，收到远端流时的回调函数。</li><li>oncleanup，销毁时的回调函数。</li></ul><p>在上面属性中，比较关键的是<code>success</code>、<code>webrtceState</code>、<code>onmessage</code>、<code>onlocalstream</code>和<code>onremotestream</code> 。这几个属性都是回调函数，在不同的情况下<code>janus.js</code>会调不同的回调函数。下面我们就对这几个回调函数做一下详细分析。</p><h3 id="success回调函数"><a href="#success回调函数" class="headerlink" title="success回调函数"></a>success回调函数</h3><p>当调用<code>attach</code>方法成功与<code>janus</code>服务器<code>插件</code>绑定之后，<code>janus.js</code>会回调<code>success</code>函数。代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">this.attach &#x3D; function(callbacks) &#123; createHandle(callbacks); &#125;;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">function createHandle(callbacks) &#123;</span><br><span class="line">    ...</span><br><span class="line">    Janus.httpAPICall( server + &quot;&#x2F;&quot; + sessionId,</span><br><span class="line">                       &#123;</span><br><span class="line">                            verb: &#39;POST&#39;,</span><br><span class="line">                            withCredentials: withCredentials,</span><br><span class="line">                            body: request,</span><br><span class="line">                            success: function() &#123;</span><br><span class="line">                                var pluginHandle &#x3D; &#123; ... &#125;;</span><br><span class="line">                                callbacks.success(pluginHandle);</span><br><span class="line">                            &#125;,</span><br><span class="line">                            error: function() &#123; ... &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                     );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面代码的执行过程如下，<code>janus.js</code>向<code>janus</code>服务器发送<code>attach</code>请求，服务器收到<code>attach</code>请求后进行处理，然后根据处理结果返回<code>success</code>或<code>error</code>。如果浏览器收到的是服务器返回的<code>success</code>响应，那么就会回调<code>success</code>函数。</p><p>接下来我们看一下<code>success</code>回调到应用层<code>videoroomtest.js</code>后做了哪些事儿吧! 代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">janus.attach(</span><br><span class="line">                &#123;</span><br><span class="line">                    ...</span><br><span class="line">                    success: function(pluginHandle) &#123;</span><br><span class="line">                                ...</span><br><span class="line">                                sfutest &#x3D; pluginHandle;</span><br><span class="line">                                ...</span><br><span class="line">                             &#125;</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>从上面的代码中我们可以看到，应用层<code>success</code>的逻辑非常简单，只是将<code>janus.js</code>层创建的<code>pluginHanle</code>保存起来以备后用，剩下的其它的一些代码是与界面相关的，我们这里就不介绍了。</p><h3 id="onmessage"><a href="#onmessage" class="headerlink" title="onmessage"></a>onmessage</h3><p><code>onmessagee</code>实现的是对<code>janus</code>服务端返回事件的处理逻辑。我们依然还是先看看在<code>janus.js</code>中是如何调用该函数的。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function handleEvent(json, skipTimeout) &#123;</span><br><span class="line">    ...</span><br><span class="line">    else if(json[&quot;janus&quot;] &#x3D;&#x3D;&#x3D; &quot;event&quot;) &#123;</span><br><span class="line">        ...</span><br><span class="line">        var sender &#x3D; json[&quot;sender&quot;];</span><br><span class="line">        var pluginHandle &#x3D; pluginHandles[sender];</span><br><span class="line">        ...</span><br><span class="line">        var plugindata &#x3D; json[&quot;plugindata&quot;];</span><br><span class="line">        ...</span><br><span class="line">        var jsep &#x3D; json[&quot;jsep&quot;];</span><br><span class="line">        var callback &#x3D; pluginHandle.onmessage;</span><br><span class="line">        if(callback) &#123;</span><br><span class="line">            callback(data, jsep);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是<code>janus.js</code>中的<code>handleEvent</code>函数的主逻辑，当<code>janus.js</code>收到janus服务端发来的<code>event</code>事件后，从中取出必要的信息，然后调用<code>pluginHandle.onmessage</code>方法回调应用层。</p><p>应用层的<code>onmessage</code>函数<code>非常重要</code>，可以说它是应用层最<code>核心的代码</code>。它根据从janus服务端收到的不同消息类型做不同的逻辑处理，其主逻辑框架如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">onmessage: function(msg, jsep) &#123;</span><br><span class="line">            var event &#x3D; msg[&quot;videoroom&quot;];</span><br><span class="line">            if(event) &#123;</span><br><span class="line">                if(event &#x3D;&#x3D;&#x3D; &quot;joined&quot;) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                    publishOwnFeed(true);</span><br><span class="line">                    ...</span><br><span class="line">                &#125; else if(event &#x3D;&#x3D;&#x3D; &quot;destroyed&quot;) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                &#125; else if(event &#x3D;&#x3D;&#x3D; &quot;event&quot;) &#123;</span><br><span class="line">                    if(msg[&quot;publishers&quot;]) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125; else if(msg[&quot;leaving&quot;]) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125; else if(msg[&quot;unpublished&quot;]) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125;else if(msg[&quot;error&quot;]) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(jsep) &#123;</span><br><span class="line">                ...</span><br><span class="line">                sfutest.handleRemoteJsep(&#123; jsep: jsep &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>通过上面的代码我们可以看到，消息包括以下3种：</p><ul><li>joined，表示作为<code>发布者</code>加入成功</li><li>destroyed, 表示用户成功<code>销毁</code>房间</li><li>event，子事件，<code>event</code>又有四个子事件：<ul><li>publishers，发布者列表</li><li>leaving，有用户离开了</li><li>unpublished，用户取消发布流</li><li>error，出错</li></ul></li></ul><p>在<code>onmessage</code>函数中会对3种事件消息做处理，下面我们分别对这几个事件消息做一下分析。</p><h4 id="joined-事件"><a href="#joined-事件" class="headerlink" title="joined 事件"></a>joined 事件</h4><p><code>joined</code>消息的含义我在<a href="https://avdancedu.com/bb906872/" target="_blank" rel="noopener">《janus的videoroom插件》</a>一文中已经向你做过介绍了，即当你作为<code>发布者</code>加入到房间里时，如果成功则会收到<code>joined</code>事件消息。</p><p>此时你可以从该消息中取出<code>publishers</code>列表，该列表中的每一个<code>publisher</code>都是会中的一个<code>发布者</code>(或称为一路流）。由于<code>发布者</code>也是房间的<code>订阅者</code>，所以你应该订阅每个<code>发布者</code>的媒体流，因此你要与列表中的每个<code>publisher</code>进行一次<code>媒体协商</code>，并进行<code>attach</code>。这样就可以接收<code>发布者</code>的媒体流啦。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">if(event &#x3D;&#x3D;&#x3D; &quot;joined&quot;) &#123;</span><br><span class="line">    ...</span><br><span class="line">    publishOwnFeed(true); &#x2F;&#x2F;创建 Offer</span><br><span class="line">    if(msg[&quot;publishers&quot;]) &#123;</span><br><span class="line">        var list &#x3D; msg[&quot;publishers&quot;];</span><br><span class="line">        for(var f in list) &#123;</span><br><span class="line">            var id &#x3D; list[f][&quot;id&quot;];</span><br><span class="line">            var display &#x3D; list[f][&quot;display&quot;];</span><br><span class="line">            var audio &#x3D; list[f][&quot;audio_codec&quot;];</span><br><span class="line">            var video &#x3D; list[f][&quot;video_codec&quot;];</span><br><span class="line">            newRemoteFeed(id, display, audio, video); &#x2F;&#x2F;attach插件，并向插件发送 join 消息</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>从代码中我们可以看到，因为它是一个<code>发布者</code>所以它首先执行<code>publishOwnFeed(true)</code>创建<code>Offer</code>与janus服务端作媒体协商。之后遍历<code>publishers</code>列表，取出每个<code>publisher</code>执行<code>newRemoteFeed</code>方法，在该方法中又会调用<code>attach</code>方法获取其它<code>发布者</code>的媒体流。</p><h4 id="publishers-事件"><a href="#publishers-事件" class="headerlink" title="publishers 事件"></a>publishers 事件</h4><p>当有<code>发布者</code>加入到房间后，房间内的所有<code>订阅者</code>都会收到<code>publishers</code>事件消息。浏览器收到该消息后，应该对消息中的每个未绑定的<code>publisher</code>都进行<code>attach</code>操作，这样就可以接收<code>发布者</code>的媒体流了。 其主逻辑代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">if(msg[&quot;publishers&quot;]) &#123;</span><br><span class="line">    var list &#x3D; msg[&quot;publishers&quot;];</span><br><span class="line">    for(var f in list) &#123;</span><br><span class="line">        var id &#x3D; list[f][&quot;id&quot;];</span><br><span class="line">        var display &#x3D; list[f][&quot;display&quot;];</span><br><span class="line">        var audio &#x3D; list[f][&quot;audio_codec&quot;];</span><br><span class="line">        var video &#x3D; list[f][&quot;video_codec&quot;];</span><br><span class="line">        newRemoteFeed(id, display, audio, video);&#x2F;&#x2F;attach插件</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这段代码与<code>joined</code>消息的处理逻辑几乎是一样的，只不过<code>订阅者</code>此时不需要与janus服务器进行媒体协商，所以它没有调用<code>publishOwnFeed</code>方法，其它的逻辑都是一样的了。</p><h4 id="leaving-unpublished-事件"><a href="#leaving-unpublished-事件" class="headerlink" title="leaving/unpublished 事件"></a>leaving/unpublished 事件</h4><p>当一个<code>发布者</code>取消发布时，janus会向房间内的其它用户发送<code>unpublished</code>消息。另外，当有用户离开房间时，janus会给房间内的其它人发送<code>leaving</code>消息。另外，如果离开的用户是一个<code>发布者</code>的话，它同时也会发<code>unpublished</code>消息，所以这里我们将两个消息放在一起讨论。</p><p>这两个消息处理的核心逻辑如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">var remoteFeed &#x3D; null;</span><br><span class="line">for(var i&#x3D;1; i&lt;6; i++) &#123;</span><br><span class="line">    if(feeds[i] &amp;&amp; feeds[i].rfid &#x3D;&#x3D; unpublished) &#123;</span><br><span class="line">        remoteFeed &#x3D; feeds[i];</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(remoteFeed !&#x3D; null) &#123;</span><br><span class="line">    ...</span><br><span class="line">    feeds[remoteFeed.rfindex] &#x3D; null;</span><br><span class="line">    remoteFeed.detach();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面这段代码有点不太好理解，我这里解释一下你就清楚了。首先我们来看看循环中的固定数字<code>6</code>，表示什么含义呢？实际上我在<a href="https://avdancedu.com/bb906872/" target="_blank" rel="noopener">《janus的videoroom插件》</a>一文中有解释过，在janus中一个房间内最多可以支持<code>6</code>路流，这个<code>6</code>表过的正是这个意思。所以当收到<code>leaving</code>和<code>unpublished</code>消息时，客户端会遍历全局变量<code>feeds</code>(保存所有订阅的流），如果在<code>feeds</code>中找到了该流，则需要与该流进行<code>detach</code>操作。</p><p>现在我们再读这段代码时是不是就理解它要表达的意思了呢？</p><h3 id="onlocalstream-消息"><a href="#onlocalstream-消息" class="headerlink" title="onlocalstream 消息"></a>onlocalstream 消息</h3><p>当收到<code>onlocalstream</code>消息时，说明本地流已经准备就绪了，此时我们需要让本地流的视频在浏览器里显示出来。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">onlocalstream: function(stream) &#123;</span><br><span class="line">    mystream &#x3D; stream;</span><br><span class="line">    ...</span><br><span class="line">    Janus.attachMediaStream($(&#39;#myvideo&#39;).get(0), stream);</span><br><span class="line">    $(&quot;#myvideo&quot;).get(0).muted &#x3D; &quot;muted&quot;;</span><br><span class="line">    ...</span><br><span class="line">    var videoTracks &#x3D; stream.getVideoTracks();&#125;</span><br><span class="line">    &#x2F;&#x2F;显示video标签</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这段代码的含议非常简单了，就是获取本地址，然后从<code>HTML</code>中拿到一个<code>video</code>标签，最后将<code>video</code>与本地流绑定到一起，这样就可以看到捕获的本地视频了。</p><h3 id="onremotestream-消息"><a href="#onremotestream-消息" class="headerlink" title="onremotestream 消息"></a>onremotestream 消息</h3><p><code>onremotestream</code>消息与<code>onlocalstream</code>是类似的，只不过它表示的是远端的视频流。当收到远端的视频流时，我们也同样在本地创建一个<code>video</code>，然后将远端视频流与<code>video</code>绑定即可。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我向你详细介绍了janus中的<code>videoroom</code>是如何使用<code>janus.js</code>文件的，其总的步骤是先调用<code>Janus.init</code>方法进行初始化；然后创建<code>Janus</code>对象，即与janus服务器建立连接，并接收来自服务器端的消息; 最后调用<code>attach</code>与业务服务器绑定，再根据消息进行推流或拉流。</p><p>总的来看，使用<code>janus.js</code>库大大减轻了我们开发<code>webrtc</code>应用程序的工作量，提高了工作效率。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://avdancedu.com/bb906872/" target="_blank" rel="noopener">《janus的videoroom插件》</a><br><a href="https://avdancedu.com/d7281c13/" target="_blank" rel="noopener">《janus前端核心库源码分析》</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/janus_jscall/jscall.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;之前我在&lt;a href=&quot;https://avdancedu.com/d7281c13/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《janus前端核心库源码分析》&lt;/a&gt;一文中已经向你详细分析了&lt;code&gt;janus.js&lt;/code&gt;文件的实现，但对于大多同学来说，知道如何使用它才是最重要的。那具体我们该如何使用它呢？janus中的&lt;code&gt;videoroomtest.js&lt;/code&gt;是一个不错的例子，今天就来分析一下&lt;code&gt;videoroomtest.js&lt;/code&gt;，看看它是是如何使用&lt;code&gt;janus.js&lt;/code&gt;的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/categories/WebRTC/"/>
    
    
      <category term="janus" scheme="https://blog.avdancedu.com/tags/janus/"/>
    
  </entry>
  
  <entry>
    <title>音视频学习路线图</title>
    <link href="https://blog.avdancedu.com/12dc77f9/"/>
    <id>https://blog.avdancedu.com/12dc77f9/</id>
    <published>2020-06-23T01:41:26.000Z</published>
    <updated>2020-06-23T15:12:25.597Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/av_path/av_learn_path.jpg" alt=""></p><p>这是我制订的一个<a href="https://coding.imooc.com/learningpath/route?pathId=39" target="_blank" rel="noopener">音视频学习线路图</a>，希望对学习音视频的同学能所有帮助!</p><p>从2018年制作第一门音视频课<a href="https://coding.imooc.com/class/279.html" target="_blank" rel="noopener">《ffmpeg精讲》</a>开始，到今年3月我已经陆续录制了4门与音视频相关的课程和一个专栏，分别是<a href="https://coding.imooc.com/class/415.html" target="_blank" rel="noopener">《音视频系统入门》</a>、<a href="https://coding.imooc.com/class/279.html" target="_blank" rel="noopener">《ffmpeg精讲》</a>、<a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门与实战》</a>、<a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">《百万级WebRTC流媒体服务器》</a>以及<a href="https://time.geekbang.org/column/article/107916" target="_blank" rel="noopener">《从0开始打造音视频直播系统》</a>，他们基本覆盖了音视频从入门到高阶的所有内容。</p><a id="more"></a><p>如果你对音视频感兴趣的话，可以根据自己的情况选择自己感兴趣的课程学习，当然也可以按照下面的路线图进行学习，</p><p>首先是<a href="https://coding.imooc.com/class/415.html" target="_blank" rel="noopener">《音视频系统入门》</a>，这门课是学习音视频至关重要的课程，是所有其它课程的基础。如果你之前对音视频没有任何概念，或者基础不牢的话，建议先从这门课开始学起。这门课讲解了最基本的音视频知识，如音频三要素、PCM、AAC编码、YUV、H264编码原理、音视频数据采集、FLV/RTMP、可商用的RTMP流媒体服务器等知识。课程中包括了大量实战，而且是手把手带你一行一行代码写起，特别适合于新入门的同学。这门课的知识是每个搞音视频研发的同学必须 100% 撑握的内容，很多音视频面试题也是考的这部分内容。</p><p>学完<a href="https://coding.imooc.com/class/415.html" target="_blank" rel="noopener">《音视频系统入门》</a>之后，你可以继续学习高阶的<a href="https://coding.imooc.com/class/279.html" target="_blank" rel="noopener">《ffmpeg精讲》</a>，这门课详细讲解了ffmpeg的运行机制，重点讲解了音视频同步，音视频线程的协作等。并通过这些知识实现了一个播放器内核。如果你的工作是做音视频编辑(如音视频的裁剪、音视拆分合并等）、音视频的编解码、音视频播放器研发的工作，那这门课就特别适合你。</p><p>当然，如果你想做实时互动直播（如音视频会议、在线教育）产品，那么WebRTC是你必须要学习的内容。WebRTC现在越来越强大，强大到你通过浏览器编写几行代码就可能实现1对1的实时通信。因此你可以选择学习<a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门与实战》</a> 和<a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">《百万级WebRTC流媒体服务器》</a>。 这两门课一门是讲解客户端的一门是讲解服务端的。</p><p><a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门与实战》</a>讲解了WebRTC的工作原理，如如何采集音视频，媒体协商，以及理底层的ICE、P2P、DTLS-SRTP、RTP/RTCP、STUN等，但其侧重点还是教你如何使用WebRTC库实现实时通信。在这门课中实现了浏览器端、Android、iOS三个端。并且三个端之间都可以彼此进行 1对1 的实时通信。</p><p>另一门课<a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">《百万级WebRTC流媒体服务器》</a>是讲解WebRTC流媒体服务器的高阶课程，这门课里面详细讲解了如何在Linux上开发高并发流媒体服务器，讲解了信号处理、多进程/多线程、select/poll/epoll/libevent/libev异步事件处理机制等，并重点对性能最好的WebRTC流媒体服务器<code>mediasoup</code>做了深入剖析。相信学完这门课后你去应聘相关的工作时，技术上已经不会有任何问题了。甚至是各大厂争抢的人才。</p><p>上面的视频课都是针对于某一方面做的重点讲解，但如果你想对整个音视频技术做全面了解，并且对更愿意阅读文字的话，阅读我的专栏 <a href="https://time.geekbang.org/column/article/107916" target="_blank" rel="noopener">《从0开始打造音视频直播系统》</a>是个不错的选择。专栏中我对上面所有的内容做了概括性的讲解，如 WebRTC的使用、WebRTC流媒体服务器的分析、传统RTMP直播技术以及各种播放器都做了讲解。如果你对音视频各方面知识都有了一定的了解，建议你再读一下这个专栏，它会对你的音视频知识做一个系统的梳理，从而让你对音视频的认知更上一个台阶。</p><p><img data-src="https://cdn.avdancedu.com/image/article/av_path/path.jpg" alt="音视频知识图谱"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/av_path/av_learn_path.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这是我制订的一个&lt;a href=&quot;https://coding.imooc.com/learningpath/route?pathId=39&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;音视频学习线路图&lt;/a&gt;，希望对学习音视频的同学能所有帮助!&lt;/p&gt;
&lt;p&gt;从2018年制作第一门音视频课&lt;a href=&quot;https://coding.imooc.com/class/279.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《ffmpeg精讲》&lt;/a&gt;开始，到今年3月我已经陆续录制了4门与音视频相关的课程和一个专栏，分别是&lt;a href=&quot;https://coding.imooc.com/class/415.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《音视频系统入门》&lt;/a&gt;、&lt;a href=&quot;https://coding.imooc.com/class/279.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《ffmpeg精讲》&lt;/a&gt;、&lt;a href=&quot;https://coding.imooc.com/class/329.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《WebRTC入门与实战》&lt;/a&gt;、&lt;a href=&quot;https://coding.imooc.com/class/387.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《百万级WebRTC流媒体服务器》&lt;/a&gt;以及&lt;a href=&quot;https://time.geekbang.org/column/article/107916&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《从0开始打造音视频直播系统》&lt;/a&gt;，他们基本覆盖了音视频从入门到高阶的所有内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="音视频" scheme="https://blog.avdancedu.com/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="https://blog.avdancedu.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>janus的videoroom插件</title>
    <link href="https://blog.avdancedu.com/bb906872/"/>
    <id>https://blog.avdancedu.com/bb906872/</id>
    <published>2020-06-19T16:04:10.000Z</published>
    <updated>2020-06-29T05:31:16.443Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/videoroom/videoroom.jpg" alt="videoroom"></p><p>在Janus的众多插件中，大家最感兴趣的恐怕就是<code>VideoRoom</code>插件了。因为它实现的是一个音视频会议的场景，这正是大多数同学所需要的。而且在Janus众多的插件中<code>VideoRoom</code>应该也是最复杂的一个，如果你们撑握了它，再去看其它插件的实现就容易多了。</p><p>在<code>VideoRoom</code>中，包括了很多API，这些API是我们打开<code>VideoRoom</code>的一把钥匙，所以本文的重点就是讲解这些API。我相信当你把这些API都撑握之后，再去看<code>VideoRoom</code>插件的代码时就会更加游刃有余了。</p><a id="more"></a><h2 id="VideoRoom插件"><a href="#VideoRoom插件" class="headerlink" title="VideoRoom插件"></a>VideoRoom插件</h2><p><code>VideoRoom</code>是Janus的一个插件，实现了一个SFU（Selective Forwarding Unit）型的音视频会议。如果你从数据转发的角度看，也可以把它认为是一个音视频<code>路由器</code>。</p><p><code>VideoRoom</code>实现的音视频会议是基于<code>发布/订阅</code>模式。每个<code>参与方</code>都可以发布自己的实时音视频流，因此它可以实现几种不同的场景，比如泛娱乐化直播或多人的实时互动产品(如音视频会议、在线教育小班课等）。</p><p>考虑到此插件允许一个<code>参与方</code>可以打开多个WebRTC <code>PeerConnection</code>（如每个<code>参与方</code>可以有1个用于推流的<code>PeerConnection</code>和N个拉流的<code>PeerConnection</code>），所以每个<code>参与方</code>需要为订阅不同的流<code>attach</code>到<code>VideoRoom</code>插件几次(每<code>attach</code>一次就会生成一个<code>Handle</code>，每个<code>Handle</code>就是一个上下文)。</p><p>因此，对于每个<code>参与方</code>至少要有一个<code>Handle</code>用于管理与插件的关系（如加入一个房间，离开一个房间，静音/取消静音，发布，接收事件）。</p><p>每当<code>参与方</code>需要订阅另一个参与方发布的音视频流时，它需要创建一个新的<code>Handle</code>。新创建的<code>Handle</code>在逻辑上属于<strong>“从”</strong><code>Handle</code>，它不能像<strong>“主”</strong><code>Handle</code>一样可以做取消房间静音这样的操作。因此，<strong>从</strong><code>Handle</code>唯一目的是提供一个上下文，在该上下文中创建一个<code>recvonly</code>类型的<code>PeerConnection</code>来订阅发布者的音视频流。</p><p>通过上面的描述我们可以知道，主Handle用于管理，而从Handle用于订阅音视频流。</p><blockquote><p>注意，现在<code>WebRTC</code>已经实现了SSRC复用（Unified Plan），这意味着你可以使用相同的<code>Janus Handle</code> 和<code>PeerConnection</code>同时接收多路音视频流。</p></blockquote><p>VideoRoom插件功能非常强大，也很灵活，它有很多的配置项，你可以通过<code>conf/janus.plugin.videoroom.jcfg</code>来修改它们。当然Janus也支持动态API修改配置，如通过API创建房间等。</p><p>要增加更多房间或修改现有房间信息，你可以向Janus发送下面格式的请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">room- &lt;唯一的房间ID&gt;：&#123;</span><br><span class="line">        description &#x3D; 房间的描述信息</span><br><span class="line">        is_private &#x3D; true | false（是否是私有房间? 如果创建的是私有房间，则无法通过list指令进行查看）</span><br><span class="line">        secret &#x3D; &lt;可选项，操作房间所需的密码，如果设置了，则像做销毁房间这样的操作时你要带上它才行&gt;</span><br><span class="line">        PIN &#x3D; &lt;可选项，加入会议房间的密码&gt;</span><br><span class="line">        require_pvtid &#x3D; true | false（是否订阅音视频流时，需要提供一个与发布者相关的有效private_id， 默认为false）</span><br><span class="line">        publishers &#x3D;  &lt;房间内发布者的最大数&gt;（例如，一个视频会议可以有6个发布者，而广播只有一个，默认&#x3D; 3）</span><br><span class="line">        bitrate &#x3D; &lt;房间里发布者发送数据的最大比特率&gt;（例如128000）</span><br><span class="line">        fir_freq &#x3D; &lt;向发布者发送FIR指令的频率&gt;（0 &#x3D;禁用）</span><br><span class="line">        audiocodec &#x3D; opus | g722 | pcmu | pcma | isac32 | isac16（发布者可以使用的音频编解码器列表，默认为opus。编码器按优先顺序以逗号分隔）</span><br><span class="line">        videocodec &#x3D; vp8 | vp9 | h264 | av1 | h265（发布者可以使用的视频编解码器列表，默认为vp8。可以按优先级顺序用逗号分隔，例如，vp9，vp8，h264）</span><br><span class="line">        vp9_profile &#x3D; VP9首选的profile(&quot;2&quot; 表示 &quot;profile-id &#x3D; 2&quot; ）</span><br><span class="line">        h264_profile &#x3D; H.264首选的profile（&quot;42e01f&quot; 表示 &quot;profile-level-id &#x3D; 42e01f&quot; ）</span><br><span class="line">        opus_fec &#x3D; true | false（是否使用带内FEC；仅适用于Opus，默认为false）</span><br><span class="line">        video_svc &#x3D; true | false（是否启用SVC支持；仅适用于VP9，默认为false）</span><br><span class="line">        audiolevel_ext &#x3D; true | false（对于发布者是否使用RTP扩展ssrc-audio-level？默认为 true）</span><br><span class="line">        audiolevel_event &#x3D; true | false（是否将audiolevel事件发送给其他用户）</span><br><span class="line">        audio_active_packets &#x3D; 100（音频保活包个数，默认值&#x3D; 100，2秒）</span><br><span class="line">        audio_level_average &#x3D; 25（音频音量级别的平均值，127 &#x3D;静音，0 &#x3D;&#39;太大声&#39;，默认&#x3D; 25）</span><br><span class="line">        videoorient_ext &#x3D; true | false（发布者是否使用RTP扩展video-orientation? 默认&#x3D; true）</span><br><span class="line">        playoutdelay_ext &#x3D; true | false（发布者是否使用RTP扩展playout-delay? 默认&#x3D; true）</span><br><span class="line">        transport_wide_cc_ext &#x3D; true | false（发布者是否使用RTP扩展 transport-wide-cc? 默认&#x3D; true）</span><br><span class="line">        record &#x3D; true | false（该房间是否启录制？默认&#x3D; false）</span><br><span class="line">        rec_dir &#x3D; &lt;启用录制后，录制文件存放的目录&gt;</span><br><span class="line">        lock_record &#x3D; true | false（是否锁定录制状态? 默认&#x3D; false）</span><br><span class="line">        notify_joining &#x3D; true | false（可选，当有新的参与方加入房音后，是否通知房间里的所有参与者?</span><br><span class="line">                                       Videoroom插件默认仅通知发布者，启用此功能可能会导致额外的通知传输。</span><br><span class="line">                                       该功能与require_pvtid一起启用时，对管理员管理仅收听的参与者特别有用。默认&#x3D; false）</span><br><span class="line">        require_e2ee &#x3D; true | false（是否启用端到端加密? 默认&#x3D; false）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Video-Room-可以使用的API"><a href="#Video-Room-可以使用的API" class="headerlink" title="Video Room 可以使用的API"></a>Video Room 可以使用的API</h2><p><code>VideoRoom</code> 插件支持很多API。这些API中，一些是同步请求，一些则是异步请求。但无论是同步还是异步请求，当遇到无效的JSON格式或无效的请求时，都使用同步进行错误响应。</p><p>接下来，我们首先看看都有那些同步请求API。<code>create</code>，<code>destroy</code>，<code>edit</code>，<code>exists</code>，<code>list</code>，<code>allowed</code>，<code>kick</code>和<code>listparticipants</code>是同步请求API。<code>create</code>允许您动态创建一个新的音视频房间；<code>edit</code>允许您动态编辑房间的属性（例如 修改PIN码）；<code>destroy</code>首先释放视频资源，然后踢除房间里的所有用户，最后销毁音视频房间；<code>exists</code>检查指定的音视频房间是否存在；<code>list</code>列出所有有效的音视频房间; <code>listparticipants</code>列出指定房间中所有激活的参与者及其详细信息。</p><p>异步请求API有：<code>join</code>，<code>joinandconfigure</code>，<code>configure</code>，<code>publish</code>，<code>unpublish</code>，<code>start</code>，<code>pause</code>，<code>switch</code>和<code>leave</code>。<code>join</code>允许你加入指定的音视频房间；<code>configure</code>可用于修改某些属性（例如，比特率范围）；<code>joinandconfigure</code>的含义是将前两个请求合并为一个请求（该请求仅适用于发布者）；<code>publish</code>发布媒体流给所有订阅者; <code>unpublish</code>正好与<code>publish</code>相反；<code>start</code>允许你开始接收订阅的媒体流；<code>pause</code>暂停发送媒体流；<code>switch</code>更改指定<code>PeerConnection</code>的媒体源（例如，你正在看A，现在改为看B），但无需为此创建新的Handle；<code>leave</code>离开视频房间。</p><p>下面咱们对上面提到的API做一下详细分析，首先看一下<code>create</code>API，它用于创建新的音视频房间，其格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;create&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;可选，房间ID。如果不填，则由插件随机生成&gt;，</span><br><span class="line">        &quot;permanent&quot;：&lt;true | false，是否创建永久房间，默认&#x3D; false&gt;，</span><br><span class="line">        &quot;description&quot;：&quot;&lt;可选，房间的名称&gt;&quot;，</span><br><span class="line">        &quot;secret&quot;：&quot;&lt;可选，编辑&#x2F;销毁房间时用的密码&gt;&quot;，</span><br><span class="line">        &quot;pin&quot;：&quot;&lt;可选，加入房间的密码&gt;&quot;，</span><br><span class="line">        &quot;is_private&quot;：&lt;true | false，是否是私有房间？如果是私有房间则不会出现在房间列表中&gt;，</span><br><span class="line">        &quot;allowed&quot;：[可选，用户加入房间的token数组]，</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的说明已经非常清楚了，这里我就不做简赘述了。</p><p>如果<code>create</code>成功，则会返回<code>created</code>响应，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：“created&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;permanent&quot;：&lt;是否是创建的永久房间？是则为true，否则为false&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，如果你请求创建一个永久房间，但<code>permanet</code>返回的是false，很可能是因为权限的问题导致的。</p></blockquote><p>如果<code>create</code>请求失败，则返回错误信息，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;error_code&quot;：&lt;错误码，每个错误码的含义需要看插件实现代码中的宏定义&gt;，</span><br><span class="line">        &quot;error&quot;：&quot;&lt;错误描述字符串&gt;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里需要注意的是，所有请求的错误响应格式都与上面一样。</p></blockquote><p>默认情况下，所有用户都可以创建房间，但你可以通过在<code>VideoRoom</code>插件的配置文件中增加<code>admin_key</code>项来限制此功能。此时，只有带了正确的<code>admin_key</code>值的<code>create</code>请求才能成功创建房间。你也可以选择将此功能扩展到RTP转发，只转发受信任的客户端的RTP包。</p><p>房间创建好后，您可以用<code>edit</code>API编辑其中的部分（但不是全部）属性。<code>edit</code>允许你修改房间描述，密码，PIN码以及是否为私有。但你将无法修改他的静态属性，例如房间ID，采样率，与扩展相关的内容等。如果你有兴趣更改ACL，还需要查看<code>allowed</code>是否允许。</p><p>一个<code>edit</code>请求格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;edit&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;secret&quot;：&quot;&lt;房间密码&gt;&quot;，</span><br><span class="line">        &quot;new_description&quot;：&quot;&lt;房间的新名称，可选&gt;&quot;，</span><br><span class="line">        &quot;new_secret&quot;：&quot;&lt;房间的新密码，可选&gt;&quot;，</span><br><span class="line">        &quot;new_pin&quot;：&quot;&lt;新PIN码，可选&gt;&quot;，</span><br><span class="line">        &quot;new_is_private&quot;：&lt;true | false，房间是否为私有房间?&gt;，</span><br><span class="line">        &quot;new_require_pvtid&quot;：&lt;true | false，房间是否要求订阅者提供private_id&gt;，</span><br><span class="line">        &quot;new_bitrate&quot;：&lt;比特率&gt;，</span><br><span class="line">        &quot;new_fir_freq&quot;：&lt;发送PLI请求关键帧的时间间隔&gt;，</span><br><span class="line">        &quot;new_publishers&quot;：&lt;房间里发布者的最大数&gt;，</span><br><span class="line">        &quot;new_lock_record&quot;：&lt;true | false，如否可以改变录制状态&gt;，</span><br><span class="line">        &quot;permanent&quot;：&lt;true | false，该房间是否是永久房间？默认&#x3D; false&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>edit</code>请求成功，刚收到<code>edited</code>响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;edited&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们来看看<code>destroy</code>API，无论你是通过动态创建的还是静态创建的房间，均可使用<code>destroy</code>销毁它，其格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;destroy&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;secret&quot;：&quot;&lt;房间密码&gt;&quot;，</span><br><span class="line">        &quot;permanent&quot;：&lt;true | false，是否是永久房间，默认&#x3D; false&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功销毁房间后将收到<code>destroyed</code>响应，其格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;destroyed&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>销毁房间后，在房间内的所有参与者都会收到<code>destroyed</code>事件，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;destroyed&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Janus中还提供了<code>exists</code>API，来检查房间是否存在，该请求的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;exists&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求成功将收到success响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：“success&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        “exists&quot;：&lt;true | false 房间是否存在&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>allowed</code>API可以打开/关闭对令牌的检测，它还可以增加/删除允许的用户，其请求格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;allowed&quot;，</span><br><span class="line">        &quot;secret&quot;：&quot;&lt;房间密码，如果已配置，则是必需的&gt;&quot;，</span><br><span class="line">        &quot;action&quot;：&quot;enable | disable | add | remove&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;allowed&quot;：[</span><br><span class="line">                &#x2F;&#x2F;字符串数组</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功请求将返回success响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：“success&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        “allowed&quot;：[</span><br><span class="line">                &#x2F;&#x2F;更新后完整的令牌列表</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你是房间管理员（即你创建了该房间并可以加密访问），则你可以使用<code>kick</code>API踢除房间内的用户。</p><blockquote><p>注意，这只会将用户踢出房间，但并不能阻止他们重新加入。要禁止他们加入，你需要先从授权用户列表中删除他们（请参阅allowed请求），然后再将其踢掉。<code>kick</code>请求的格式如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;kick&quot;，</span><br><span class="line">        &quot;secret&quot;：&quot;&lt;房间密码&gt;&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;id&quot;：&lt;被踢用户ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求成功将收到success响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;success&quot;，</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你还可以通过<code>list</code>API获取可用房间的列表（不包括配置或创建为私有的房间），其格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：“list&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求成功将返回success响应，响应中会带有有效的房间列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：“成功&quot;，</span><br><span class="line">        &quot;rooms&quot;：[&#x2F;&#x2F;房间对象数组</span><br><span class="line">                &#123;&#x2F;&#x2F; 第一个房间</span><br><span class="line">                        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">                        &quot;description&quot;：&quot;&lt;房间名称&gt;&quot;，</span><br><span class="line">                        &quot;pin_required&quot;：&lt;true | false，是否需要输入PIN吗才能加入此房间&gt;，</span><br><span class="line">                        &quot;max_publishers&quot;：&lt;房间内发布者最大数量，&gt;</span><br><span class="line">                        &quot;bitrate&quot;：&lt;发布者使用的（通过REMB）比特率上限&gt;，</span><br><span class="line">                        &quot;bitrate_cap&quot;：&lt;true | false，上述上限是否可以动态更改?&gt;，</span><br><span class="line">                        &quot;fir_freq&quot;：&lt;发送PLI&#x2F;FIR请求关键帧的时间间隔&gt;，</span><br><span class="line">                        &quot;audiocodec&quot;：&quot;&lt;音频编解码器列表，每个编码器以逗号分隔&gt;&quot;，</span><br><span class="line">                        &quot;videocodec&quot;：&quot;&lt;视频编解码器列表，每个编码器以逗号分隔&gt;&quot;，</span><br><span class="line">                        &quot;record&quot;：&lt;true | false，是否打开了录制功能&gt;，</span><br><span class="line">                        &quot;record_dir&quot;：&quot;&lt;如果开启了录掉，.mjr文件保存的路径&gt;&quot;，</span><br><span class="line">                        &quot;lock_record&quot;：&lt;true | false，是否只能通过密码才能更改房间记录状态&gt;，</span><br><span class="line">                        &quot;num_participants&quot;：&lt;房间内参与人的个数&gt;</span><br><span class="line">                &#125;，</span><br><span class="line">                &#x2F;&#x2F;其他房间</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，你要获取特定房间中的参与者列表，可以使用<code>listparticipants</code>请求，其格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;listparticipants&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求成功将返回一个<code>participants</code>响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;participants&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        “participants&quot;：[&#x2F;&#x2F;参与者对象的数组</span><br><span class="line">                &#123;&#x2F;&#x2F;参与者＃1</span><br><span class="line">                        &quot;id&quot;：&lt;用户ID&gt;，</span><br><span class="line">                        &quot;display&quot;：&quot;&lt;用户名；可选&gt;&quot;，</span><br><span class="line">                        &quot;publisher&quot;：&quot;&lt;true | false，用户是否是房间的发布者&gt;&quot;，</span><br><span class="line">                        &quot;talking&quot;：&lt;true | false，用户是否可以说话（仅当使用音频级别时）&gt;</span><br><span class="line">                &#125;，</span><br><span class="line">                &#x2F;&#x2F;其他参与者</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是Janus中的同步API。异步API都是与<code>参与者</code>有关，即<code>参与者</code>如何发布，订阅或管理他们正在发送或接收的媒体流。</p><h2 id="VideoRoom-发布者"><a href="#VideoRoom-发布者" class="headerlink" title="VideoRoom 发布者"></a>VideoRoom 发布者</h2><p>在VideoRoom中，<code>发布者</code>是指那些能够在房间中发布<code>媒体流</code>的参与者。</p><p>当你以<code>发布者</code>的身份加入到房间里时，您应该发送<code>join</code>请求，并且将ptype设置为<code>publisher</code>。请求的具体格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;join&quot;，</span><br><span class="line">        &quot;ptype&quot;：&quot;pbulisher&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;id&quot;：&lt;发布者ID；可选，如果缺少，将由插件选择&gt;，</span><br><span class="line">        &quot;display&quot;：&quot;&lt;发布者名称；可选&gt;&quot;，</span><br><span class="line">        &quot;token&quot;：&quot;&lt;邀请令牌，如果房间有ACL时需要该字段；可选&gt;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>join</code>请求成功将收到<code>joined</code>事件，其中包含当前激活的<code>发布者</code>列表，以及任选的<code>参加者</code>列表。<code>joined</code>事件格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;joined&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;description&quot;：&lt;房间名，如果有的话&gt;，</span><br><span class="line">        &quot;id&quot;：&lt;用户ID&gt;，</span><br><span class="line">        &quot;private_id&quot;：&lt;与参与者相关联的不同唯一ID；打算是私人的&gt;，</span><br><span class="line">        “publishers&quot;：[</span><br><span class="line">                &#123;</span><br><span class="line">                        &quot;id&quot;：&lt;活动发布者＃1的唯一ID&gt;，</span><br><span class="line">                        &quot;display&quot;：&quot;&lt;发布者＃1的名称，如果有的话&gt;&quot;，</span><br><span class="line">                        &quot;audio_codec&quot;：&quot;&lt;发布者＃1使用的音频编解码器，如果有的话&gt;&quot;，</span><br><span class="line">                        &quot;video_codec&quot;：&quot;&lt;发布者＃1使用的视频编解码器，如果有的话&gt;&quot;，</span><br><span class="line">                        &quot;simulcast&quot;：&quot;&lt;如果发布者使用simulcast，则为true（仅VP8和H.264）&gt;&quot;，</span><br><span class="line">                        &quot;talking&quot;：&lt;true | false，发布者开启语音聊天（仅在使用音频级别的情况下）&gt;，</span><br><span class="line">                &#125;，</span><br><span class="line">                &#x2F;&#x2F;其他活跃的发布者</span><br><span class="line">        ]，</span><br><span class="line">        &quot;attendees&quot;：[&#x2F;&#x2F;仅当房间的notify_joining设置为TRUE时存在</span><br><span class="line">                &#123;</span><br><span class="line">                        &quot;id&quot;：&lt;与会者＃1的唯一ID&gt;，</span><br><span class="line">                        &quot;display&quot;：&quot;&lt;与会者＃1的名称，如果有的话&gt;&quot;</span><br><span class="line">                &#125;，</span><br><span class="line">                &#x2F;&#x2F;其他参加者</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，如果房间中当前没有人，则<code>发布者</code>列表为空。上面格式中的<code>private_id</code>属性只有在用户订阅时才起作用。</p></blockquote><p>对于房间里的订阅者来说，会收到<code>event</code>通知。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        “joining&quot;：&#123;</span><br><span class="line">                &quot;id&quot;：&lt;参与者ID&gt;，</span><br><span class="line">                &quot;display&quot;：&quot;&lt;参与者名称&gt;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你想成为<code>发布者</code>，则发送<code>publish</code>请求。该请求必须跟着一个<code>JSEP SDP Offer</code>，用于协商新的<code>PeerConnection</code>。插件会将其与房间配置进行匹配（例如，确保房间中使用协商的编解码器），并使用<code>JSEP SDP answer</code>进行答复从而完成<code>PeerConnection</code>的设置。建立<code>PeerConnection</code>后，发布者立即处于活动状态，其他参与者就可以订阅它发布的流啦。</p><p><code>publish</code>请求格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;publish&quot;，</span><br><span class="line">        &quot;audio&quot;：&lt;true | false，是否应该转发音频；默认为true&gt;，</span><br><span class="line">        &quot;video&quot;：&lt;true | false，是否应该转发视频；默认为true&gt;，</span><br><span class="line">        &quot;data&quot;：&lt;true | false，是否应该转发数据；默认为true&gt;，</span><br><span class="line">        &quot;audiocodec&quot;：&quot;&lt;在协商协议中首选的音频编解码器；可选&gt;&quot;，</span><br><span class="line">        &quot;videocodec&quot;：&quot;&lt;在协商协议中首选的视频编解码器；可选&gt;&quot;，</span><br><span class="line">        &quot;bitrate&quot;：&lt;通过REMB返回的比特率上限；可选，如果存在则覆盖全局房间值&gt;，</span><br><span class="line">        &quot;record&quot;：&lt;true | false，是否应该记录此发布者；可选&gt;</span><br><span class="line">        &quot;filename&quot;：&quot;&lt;录制文件名；可选&gt;&quot;，</span><br><span class="line">        &quot;display&quot;：&quot;&lt;用户名称；可选&gt;&quot;，</span><br><span class="line">        &quot;audio_level_average&quot;：&quot;&lt;音频音量平均值，此设置覆盖房间的audio_level_average；可选&gt;&quot;，</span><br><span class="line">        &quot;audio_active_packets&quot;：&quot;&lt;音频保活包数，此设置覆盖房间audio_active_packets；可选&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此请求应该与发布者的<code>JSEP SDP Offer</code>一起提供，插件收到此消息后，将协商与之匹配的<code>JSEP SDP Answer</code>。如果成功，<code>configured</code>事件将被返回，其格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;configured&quot;：“ok&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该事件将与准备好的<code>JSEP SDP Answer</code>一起发送给客户端。</p><p>你也可以用<code>configure</code>请求代替<code>publish</code>。两者的功能在<code>发布</code>上是等效的，但从语义的角度来看，<code>publish</code>是发布时要发送的正确消息。<code>configure</code>请求也可以用于更新发布者会话的某些属性，在这种情况下，就不能用<code>publish</code>请求了。</p><blockquote><p>需要注意的是，如果用户已经发送过<code>publish</code>了，再发送<code>publish</code>将导致失败。</p></blockquote><p>其实，您可以将<code>join</code>和<code>publish</code>两个API合并为一个API请求。比如你一开始以<code>参与者</code>的身份加入，随后变为<code>发布者</code>，这时你就可以将他们合并。你可以使用<code>joinandconfigure</code>请求来做到这一点，该请求将这两个请求（join与publish)结合在一起。如果成功，则响应一个<code>joined</code>事件，并且将<code>JSEP SDP Answer</code>一起发送出去。</p><p>一旦<code>PeerConnection</code>设置成功，且发布者处于激活状态，<code>event</code>就会被发向房间中的所有<code>参与者</code>。其格式如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        “publishers&quot;：[</span><br><span class="line">                &#123;</span><br><span class="line">                        &quot;id&quot;：&lt;新发布者的唯一ID&gt;，</span><br><span class="line">                        &quot;display&quot;：&quot;&lt;新发布者的名称，如果有的话&gt;&quot;，</span><br><span class="line">                        &quot;audio_codec&quot;：&quot;&lt;新布者使用的音频编解码器，如果有的话&gt;&quot;，</span><br><span class="line">                        &quot;video_codec&quot;：&quot;&lt;新发布使用的视频编解码器，如果有的话&gt;&quot;，</span><br><span class="line">                        &quot;simulcast&quot;：&quot;&lt;如果发布者使用simucast，则为true（仅VP8和H.264）&gt;&quot;，</span><br><span class="line">                        &quot;talking&quot;：&lt;true | false，发布者是否在讲话（仅在使用音频级别的情况下）&gt;，</span><br><span class="line">                &#125;</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要停止发布并删除相关的<code>PeerConnection</code>，可以使用该<code>unpublish</code>请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：“unpublish&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当插件收到这条请求后，它会删除对应的<code>PeerConnection</code>，并将发布者从活动列表中删除。如果成功，响应如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        “unpublish&quot;：“ok&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>PeerConnection</code>删除后，插件还将向所有其他<code>参与者</code>通知该流不再可用的消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;unpublished&quot;：&lt;发布者的ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，不光收到<code>unpublish</code>消息会触发上面的事件通知，其实无论什么情况下，只要<code>发布者</code>提供的流消失了（例如，句柄已关闭或用户失去连接），都会发同样的<code>事件</code>。此外，你可以使用同一句柄的上下文多次执行<code>发布</code>或<code>取消发布</code>操作。</p></blockquote><p>正如我们上面讲过的，你可以使用<code>configure</code>请求调整发布者会话的某些属性。该请求的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;configure&quot;，</span><br><span class="line">        &quot;audio&quot;：&lt;true | false，取决于是否应该转发音频；默认为true&gt;，</span><br><span class="line">        &quot;video&quot;：&lt;true | false，取决于是否应该转发视频；默认为true&gt;，</span><br><span class="line">        &quot;data&quot;：&lt;true | false，取决于是否应该转发数据；默认为true&gt;，</span><br><span class="line">        &quot;bitrate&quot;：&lt;比特率上限；可选，如果存在则覆盖全局房间值（除非设置了bitrate_cap）&gt;，</span><br><span class="line">        &quot;keyframe&quot;：&lt;true | false，是否向发布者发送关键帧请求&gt;，</span><br><span class="line">        &quot;record&quot;：&lt;true | false，是否开启录制；可选&gt;</span><br><span class="line">        &quot;filename&quot;：&quot;&lt;如果开启了录制，指明录制路径&#x2F;文件；可选&gt;&quot;，</span><br><span class="line">        &quot;display&quot;：&quot;&lt;用户名称；可选&gt;&quot;，</span><br><span class="line">        &quot;audio_active_packets&quot;：&quot;&lt;音频保活包个数，audio_active_packets；可选&gt;&quot;，</span><br><span class="line">        &quot;audio_level_average&quot;：&quot;&lt;音频音量平均值，audio_level_average；可选&gt;&quot;，</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>configure</code>基本上与<code>publish</code>的属性相同。这就是为什么两个请求都可以用来开始发布的原因。如果<code>configure</code>成功，则返回<code>configured</code>事件，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;configured&quot;：“ok&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当发送<code>configure</code>请求RTP扩展<code>ssrc-audio-level</code>时，如果<code>audiolevel_event</code>设置为true ，则可能会向所有发布者发送一些临时事件。这些事件将具有以下格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&lt;&quot;talking&quot;|&quot;stopped-talking&quot;，是否发布者开始或停止发言&gt;，</span><br><span class="line">        &quot;room&quot;：&lt;房间的唯一ID&gt;，</span><br><span class="line">        &quot;id&quot;：&lt;发布者的唯一ID&gt;，</span><br><span class="line">        &quot;audio-level-dBov-avg&quot;：&lt;音平音量的平均值，127 &#x3D;静音，0 &#x3D;&#39;太大声&#39;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>VideoRoom</code>插件的主要目的是从WebRTC源(发布者)获取媒体，并将其转发到WebRTC目的地（订阅者），但实际上存在几种方案，可以将媒体转发给外部（不一定与WebRTC兼容）组件。例如，用于媒体处理，外部录制，转码，级联等等。<code>rtp_forward</code>顾名思义，就是将发布者发送的RTP包（普通或加密）实时转发到远程后端。</p><p>您可以使用<code>rtp_forward</code>请求为现有发布者添加新的RTP转发器，其格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;rtp_forward&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;publisher_id&quot;：&lt;发布者ID&gt;，</span><br><span class="line">        &quot;host&quot;：&quot;&lt;将RTP和数据包转发到的host主机IP地址&gt;&quot;，</span><br><span class="line">        &quot;host_family&quot;：&quot;&lt;ipv4 | ipv6，使用IPv4还是IPv6；默认情况下，无论我们得到什么&gt;&quot;，</span><br><span class="line">        &quot;audio_port&quot;：&lt;音频RTP数据包转发到的端口&gt;，</span><br><span class="line">        &quot;audio_ssrc&quot;：&lt;音频SSRC，用于流式传输；可选&gt;</span><br><span class="line">        &quot;audio_pt&quot;：&lt;音频有效负载类型；可选&gt;</span><br><span class="line">        &quot;audio_rtcp_port&quot;：&lt;接收方接收音频RTCP反馈端口；可选，当前未用于音频&gt;，</span><br><span class="line">        &quot;video_port&quot;：&lt;将视频RTP数据包转发到的端口&gt;，</span><br><span class="line">        &quot;video_ssrc&quot;：&lt;视频 SSRC；可选&gt;</span><br><span class="line">        &quot;video_pt&quot;：&lt;视频有效载荷类型；可选&gt;</span><br><span class="line">        &quot;video_rtcp_port&quot;：&lt;接收方接收视频RTCP反馈端口；可选&gt;</span><br><span class="line">        &quot;video_port_2&quot;：&lt;如果simulcast，则视频第二个的RTP数据端口&gt;，</span><br><span class="line">        &quot;video_ssrc_2&quot;：&lt;如果simulcast，则视频第二个的SSRC；可选&gt;</span><br><span class="line">        &quot;video_pt_2&quot;：&lt;如果simulcast，则视频第二个的有效载荷类型；可选&gt;</span><br><span class="line">        &quot;video_port_3&quot;：&lt;如果simulcast，则视频第三个RTP数据包端口&gt;，</span><br><span class="line">        &quot;video_ssrc_3&quot;：&lt;如果simulcast，则视频第三个SSRC；可选&gt;</span><br><span class="line">        &quot;video_pt_3&quot;：&lt;如果simulcast，则视频第三个的有效载荷类型；可选&gt;</span><br><span class="line">        &quot;data_port&quot;：&lt;数据通道消息端口&gt;，</span><br><span class="line">        &quot;srtp_suite&quot;：&lt;身份验证标签的长度（32或80）；可选&gt;</span><br><span class="line">        &quot;srtp_crypto&quot;：&quot;&lt;用作加密的密钥（如SDES中的base64编码的密钥；可选&gt;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，如上所述，如果您配置了admin_key属性，则在请求中也需要提供它，否则未授权的请求将被拒绝。默认情况下，没有对rtp_forward进行限制。</p></blockquote><p>如果请求成功则返回<code>rtp_forward</code>响应，其中格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;rtp_forward&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;publisher_id&quot;：&lt;发布者ID&gt;</span><br><span class="line">        &quot;rtp_stream&quot;：&#123;</span><br><span class="line">                &quot;host&quot;：&quot;&lt;接收流的主机IP，如果未解析，则与请求相同&gt;&quot;，</span><br><span class="line">                &quot;audio&quot;：&lt;音频RTP端口，与请求相同（如果已配置）&gt;，</span><br><span class="line">                &quot;audio_rtcp&quot;：&lt;音频RTCP端口，与请求相同（如果已配置）&gt;，</span><br><span class="line">                &quot;audio_stream_id&quot;：&lt;分配给音频RTP转发器的唯一数字ID，如果有的话，&gt;</span><br><span class="line">                &quot;video&quot;：&lt;视频RTP端口，与请求相同（如果已配置）&gt;，</span><br><span class="line">                &quot;video_rtcp&quot;：&lt;视频RTCP端口，如果配置，则与请求相同，&gt;</span><br><span class="line">                &quot;video_stream_id&quot;：&lt;分配给主视频RTP转发器的唯一数字ID，如果有的话，&gt;</span><br><span class="line">                &quot;video_2&quot;：&lt;第二个视频端口，与请求相同（如果已配置）&gt;，</span><br><span class="line">                &quot;video_stream_id_2&quot;：&lt;分配给第二层视频RTP转发器的唯一数字ID，如果有的话，&gt;</span><br><span class="line">                &quot;video_3&quot;：&lt;第三个视频端口，与请求相同（如果已配置）&gt;，</span><br><span class="line">                &quot;video_stream_id_3&quot;：&lt;分配给第三个视频RTP转发器的唯一数字ID，如果有，&gt;</span><br><span class="line">                &quot;data&quot;：&lt;数据端口，与请求相同（如果已配置）&gt;，</span><br><span class="line">                &quot;data_stream_id&quot;：&lt;分配给数据通道消息转发器的唯一数字ID（如果有）&gt;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要停止以前创建的RTP转发器，可以使用<code>stop_rtp_forward</code>请求，其格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;stop_rtp_forward&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;publisher_id&quot;：&lt;发布者ID&gt;，</span><br><span class="line">        &quot;stream_id&quot;：&lt;RTP转发器ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求成功，则返回<code>stop_rtp_forward</code>响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;stop_rtp_forward&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;publisher_id&quot;：&lt;发布者ID，与请求相同，&gt;</span><br><span class="line">        &quot;stream_id&quot;：&lt;流ID，与请求相同&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要获取特定房间中所有转发器的列表，可以使用<code>listforwarders</code>请求，其格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;listforwarders&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间的唯一数字ID&gt;，</span><br><span class="line">        &quot;secret&quot;：&quot;&lt;房间密码；如果已配置，则是必需的&gt;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求成功，则返回forwarders响应，其中包括RTP转发器列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;forwarders&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间的唯一ID&gt;，</span><br><span class="line">        &quot;rtp_forwarders&quot;：[&#x2F;&#x2F;具有RTP转发器的发布者数组</span><br><span class="line">                &#123;&#x2F;&#x2F;发布者＃1</span><br><span class="line">                        &quot;publisher_id&quot;：&lt;发布者＃1的唯一数字ID&gt;，</span><br><span class="line">                        &quot;rtp_forwarders&quot;：[&#x2F;&#x2F; RTP转发器数组</span><br><span class="line">                                &#123;&#x2F;&#x2F; RTP转发器＃1</span><br><span class="line">                                        &quot;audio_stream_id&quot;：&lt;音频RTP转发器的唯一ID，如果有的话&gt;，</span><br><span class="line">                                        &quot;video_stream_id&quot;：&lt;视频RTP转发器的唯一ID，如果有的话&gt;，</span><br><span class="line">                                        &quot;data_stream_id&quot;：&lt;数据通道消息转发器的唯一ID（如果有）&gt;，</span><br><span class="line">                                        &quot;ip&quot;：&quot;&lt;接收端IP&gt;&quot;，</span><br><span class="line">                                        &quot;port&quot;：&lt;接收端端口&gt;，</span><br><span class="line">                                        &quot;rtcp_port&quot;：&lt;接收端RTCP端口，如果有的话&gt;，</span><br><span class="line">                                        &quot;ssrc&quot;：&lt;转发器正在使用的SSRC，如果有的话&gt;，</span><br><span class="line">                                        &quot;pt&quot;：&lt;转发器正在使用的有效负载类型&gt;，</span><br><span class="line">                                        &quot;substream&quot;：&lt;视频子流，如果有&gt;，</span><br><span class="line">                                        &quot;srtp&quot;：&lt;true | false，RTP流是否已加密&gt;</span><br><span class="line">                                &#125;，</span><br><span class="line">                                &#x2F;&#x2F;此发布者的其他转发器</span><br><span class="line">                        ]，</span><br><span class="line">                &#125;，</span><br><span class="line">                &#x2F;&#x2F;其他发布者</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在会议进行期间启用或禁用录制，您可以使用<code>enable_recording</code>请求，该请求的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;enable_recording&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;secret&quot;：&quot;&lt;房间密码；如果已配置，则是必需的&gt;&quot;</span><br><span class="line">        &quot;record&quot;：&lt;true | false，是否自动记录此会议室中的参与者&gt;，</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，参与者通常也可以通过configure请求来更改自己的录制状态：这样做是为了获得最大的灵活性，您可能希望单独记录一些流，而不是全局或自动记录一些内容，到特定文件。就是说，如果你希望确保在启用全局录制后参与者不能停止其录制，或者在不应该录制该会议室的情况下启动它，那么您应该确保在创建会议室时使用lock_record属性，将其设置为true。这样，只有在提供了房间密码的情况下，才能更改录制状态，从而确保只有管理员才能执行此操作。</p></blockquote><p>最后，您可以使用<code>leave</code>请求离开会议室。如果您是会议室中的活动发布者，这也将隐式取消你的发布。该leave请求如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;leave&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果成功，响应将如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;leaving&quot;：&quot;ok&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他参与者将收到”leaving”事件，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;leaving：&lt;离开的参与者的唯一ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您是活跃的发布者，则其他用户也将收到相应的<code>unpublish</code>事件，以通知他们该流不再可用。如果您只是潜伏而不是发布者，则其他参与者将仅收到”leave”事件。</p><h2 id="VideoRoom-订阅者"><a href="#VideoRoom-订阅者" class="headerlink" title="VideoRoom 订阅者"></a>VideoRoom 订阅者</h2><p>订阅者在加入房间时，join请求的ptype属性应该设置为<code>subscriber</code>，并指定要订阅的确切的媒体流。该请求的确切语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;join&quot;，</span><br><span class="line">        &quot;ptype&quot;：&quot;subscriber&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;feed&quot;：&lt;发布者ID；强制性&gt;，</span><br><span class="line">        &quot;private_id&quot;：&lt;发起此请求的用户ID；可选的，除非房间配置要求&gt;</span><br><span class="line">        &quot;close_pc&quot;：&lt;true | false，发布者离开时是否应自动关闭PeerConnection；默认为true&gt;，</span><br><span class="line">        &quot;audio&quot;：&lt;true | false，是否转发音频；默认为true&gt;，</span><br><span class="line">        &quot;video&quot;：&lt;true | false，是否转发视频；默认为true&gt;，</span><br><span class="line">        &quot;data&quot;：&lt;true | false，是否转发数据；默认为true&gt;，</span><br><span class="line">        &quot;offer_audio&quot;：&lt;true | false; 是否应该协商音频；如果发布者的音频&gt;，默认为true</span><br><span class="line">        &quot;offer_video&quot;：&lt;true | false; 是否应该协商视频；如果发布者的视频&gt;，默认为true</span><br><span class="line">        &quot;offer_data&quot;：&lt;true | false; 是否应该协商数据通道；如果发布者的datachannels&gt;为默认值，则为true</span><br><span class="line">        &quot;substream&quot;：&lt;启用了simulcast情况下，要接收的子流（0-2）；可选&gt;</span><br><span class="line">        &quot;temporal&quot;：&lt;启用simulcast情况下，要接收的时间层（0-2）；可选&gt;</span><br><span class="line">        &quot;fallback&quot;：&lt;多少时间（在我们这里，默认为250000）没有接收到数据包将使我们下降到下面的子流&gt;，</span><br><span class="line">        &quot;spatial_layer&quot;：&lt;启用VP9-SVC时要接收的空间层（0-2）；可选&gt;</span><br><span class="line">        &quot;temporal_layer&quot;：&lt;启用VP9-SVC时要接收的时间层（0-2）；可选&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如您所见，只要指定好要订阅的发布者ID，并在需要时指定好<code>private_id</code>(订阅者ID)，其它的都可以不设置。不过请求中的<code>offer_audio</code>，<code>offer_video</code>和<code>offer_data</code>特别有意思，你可以通过它们订阅媒体的一个子集(音频\视频\数据）。</p><p>默认情况下，发送<code>join</code>请求时会导致插件层创建<code>SDP Offer</code>，用以协商发布者提供那些媒体。此外，如果发布者发布的是<code>simulcast</code>或<code>VP9 SVC</code>，那么你还可以订阅你感兴趣的子流，例如，获得最佳质量的中间质量。更有意思的是，你可以使用<code>configure</code>请求随时动态更改这些设置。</p><p>上面的请求如果成功，将生成一个新的<code>JSEP SDP Offer</code>，并伴随一个attached事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;attached&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;feed&quot;：&lt;发布者ID&gt;，</span><br><span class="line">        &quot;display&quot;：&quot;&lt;发布者的名称，如果有的话&gt;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此阶段，为了完成<code>PeerConnection</code>的设置，订阅者应将<code>JSEP SDP Answer</code>发送回插件。此操作是通过<code>start</code>请求来完成的，在这种情况下，请求必须与<code>JSEP SDP Answer</code>相关联，但是不需要任何参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：“start&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果成功，此请求将返回一个started事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;started&quot;：&quot;ok&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成此操作后，所需要做的就是等待WebRTC <code>PeerConnection</code>建立成功。一旦<code>PeerConnection</code>建立成功，Streaming插件就可以开始向订阅的观众转发媒体了。</p><blockquote><p>注意，在需要重新协商（例如出于ICE重启目的）的情况下，您也可以使用我们刚经历的相同步骤（watch请求，然后插件创建<code>JSEP Offer</code>，最后客户端发送<code>start</code>请求和<code>JSEP Answer</code>）。</p></blockquote><p>作为<code>订阅者</code>，您可以发送<code>pause</code>临时暂停或发送<code>start</code>恢复整个媒体的传送（在这种情况下，不附带任何JSEP SDP Answer）。因为上下文中已经有了相关信息，所以不需要重新进行协商。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;pause&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;start&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，它们会分别导致paused和started事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;paused&quot;：&quot;ok&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;started&quot;：&quot;ok&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>configure</code>请求可以对<code>订阅</code>做更多深入操作。该请求允许<code>订阅者</code>动态更改与媒体订阅有关的某些属性，<code>configure</code>请求的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;configure&quot;，</span><br><span class="line">        &quot;audio&quot;：&lt;true | false，是否应该转发音频；可选&gt;</span><br><span class="line">        &quot;video&quot;：&lt;true | false，是否应该转发视频；可选&gt;</span><br><span class="line">        &quot;data&quot;：&lt;true | false，是否转发数据；可选&gt;</span><br><span class="line">        &quot;substream&quot;：&lt;启用simulcast情况下，要接收的子流（0-2）；可选&gt;</span><br><span class="line">        &quot;temporal&quot;：&lt;启用simulcast，要接收的时间层（0-2）；可选&gt;</span><br><span class="line">        &quot;fallback&quot;：&lt;多少时间（在我们这里，默认为250000）没有接收到数据包将使我们下降到下面的子流&gt;，</span><br><span class="line">        &quot;spatial_layer&quot;：&lt;启用VP9-SVC时要接收的空间层（0-2）；可选&gt;</span><br><span class="line">        &quot;temporal_layer&quot;：&lt;启用VP9-SVC时要接收的时间层（0-2）；可选&gt;</span><br><span class="line">        &quot;audio_level_average&quot;：&quot;&lt;如果提供，将覆盖此用户的房间audio_level_average；可选&gt;&quot;，</span><br><span class="line">        &quot;audio_active_packets&quot;：&quot;&lt;如果提供，将覆盖此用户的房间audio_active_packets；可选&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你所看到的audio，video和data属性可以用作媒体级的暂停/恢复功能，而pause与start只是简单地暂停/恢复所有数据流。</p><p>下面来说说<code>switch</code>，switch 请求格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;switch&quot;，</span><br><span class="line">        &quot;feed&quot;：&lt;要切换到的新发布者的唯一ID；强制性&gt;，</span><br><span class="line">        &quot;audio&quot;：&lt;true | false，取决于是否应该中继音频；可选&gt;</span><br><span class="line">        &quot;video&quot;：&lt;true | false，取决于是否应该中继视频；可选&gt;</span><br><span class="line">        &quot;data&quot;：&lt;true | false，取决于是否应该中继数据通道消息；可选&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果成功，您将退订之前的发布者，然后订阅新的发布者。确认切换成功的事件如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;switched&quot;：&quot;ok&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;id&quot;：&lt;新发布者的唯一ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，要停止订阅并删除相关的PeerConnection，可以使用该leave请求。由于上下文是隐式的，因此不需要其他参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;leave&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果成功，该插件将尝试拆除PeerConnection，并发送回一个left事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;left&quot;：&quot;ok&quot;，</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>VideoRoom</code>插件是Janus的一个特别重要的插件，对于该插件的理解对于我们理解整个Janus有至关重要的意义。本文说细分析了<code>VideoRoom</code>插件中所有的信令，大体上我们可以将它们人成两在类，一类是房间管理信令，另一类是用户信令。</p><p>这些信令设计的非常巧妙，对我们研发自己的SFU会议系统是一个很好的借鉴。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://avdancedu.com/947c722a/" target="_blank" rel="noopener">多人实时互动之各WebRTC流媒体服务器比较</a><br><a href="https://avdancedu.com/d7281c13/" target="_blank" rel="noopener">janus前端核心库源码分析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/videoroom/videoroom.jpg&quot; alt=&quot;videoroom&quot;&gt;&lt;/p&gt;
&lt;p&gt;在Janus的众多插件中，大家最感兴趣的恐怕就是&lt;code&gt;VideoRoom&lt;/code&gt;插件了。因为它实现的是一个音视频会议的场景，这正是大多数同学所需要的。而且在Janus众多的插件中&lt;code&gt;VideoRoom&lt;/code&gt;应该也是最复杂的一个，如果你们撑握了它，再去看其它插件的实现就容易多了。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;VideoRoom&lt;/code&gt;中，包括了很多API，这些API是我们打开&lt;code&gt;VideoRoom&lt;/code&gt;的一把钥匙，所以本文的重点就是讲解这些API。我相信当你把这些API都撑握之后，再去看&lt;code&gt;VideoRoom&lt;/code&gt;插件的代码时就会更加游刃有余了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/categories/WebRTC/"/>
    
    
      <category term="videoroom" scheme="https://blog.avdancedu.com/tags/videoroom/"/>
    
  </entry>
  
  <entry>
    <title>WebRTC常见问题</title>
    <link href="https://blog.avdancedu.com/af19ebea/"/>
    <id>https://blog.avdancedu.com/af19ebea/</id>
    <published>2020-06-16T09:29:19.000Z</published>
    <updated>2020-06-16T16:41:09.992Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DTLS-SRTP-与-DTLS-的区别"><a href="#DTLS-SRTP-与-DTLS-的区别" class="headerlink" title="DTLS-SRTP 与 DTLS 的区别"></a>DTLS-SRTP 与 DTLS 的区别</h2><p>DTLS用于数据加密，它是从 TLS 发展而来。 TLS用于TCP，而DTLS用于UDP。<br>DTLS-SRTP 只用户握手，交换<code>fingerprint</code>和密钥，真正的加密由SRTP来完成。</p><h2 id="是否开启-DTLS-SRTP"><a href="#是否开启-DTLS-SRTP" class="headerlink" title="是否开启 DTLS-SRTP"></a>是否开启 DTLS-SRTP</h2><p>在创建PeerConnection时设置<code>DtlsSrtpKeyAgreement</code>参数可以关闭/打开 DTLS-SRTP<br><a href="https://groups.google.com/forum/#!topic/discuss-webrtc/t8XT0IxoHgw" target="_blank" rel="noopener">discuss-webrtc</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;DTLS-SRTP-与-DTLS-的区别&quot;&gt;&lt;a href=&quot;#DTLS-SRTP-与-DTLS-的区别&quot; class=&quot;headerlink&quot; title=&quot;DTLS-SRTP 与 DTLS 的区别&quot;&gt;&lt;/a&gt;DTLS-SRTP 与 DTLS 的区别&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/categories/WebRTC/"/>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/tags/WebRTC/"/>
    
  </entry>
  
  <entry>
    <title>janus前端核心库源码分析</title>
    <link href="https://blog.avdancedu.com/d7281c13/"/>
    <id>https://blog.avdancedu.com/d7281c13/</id>
    <published>2020-06-15T03:13:31.000Z</published>
    <updated>2020-06-29T05:29:06.821Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/janus_js/janus_logo.jpg" alt=""></p><p>Hello,大家好！今天我们继续来分析janus。相信现在大家应该对<a href="https://janus.conf.meetecho.com/" target="_blank" rel="noopener">janus</a> 都比较熟悉了，它是一套完整的音视频会议系统，包括了WebRTC流媒体服务器和客户端API两大部分。</p><p>其中，客户端又包括Android、iOS以及浏览器端。今天我们要分析的内容就是浏览器端中的<code>janus.js</code>文件。之所以要分析它，是因为它是浏览器端最关键的一个文件，了解了它我们基本上就将浏览器端的逻辑全部撑握了。</p><p>从大的方面说，<code>janus.js</code>主要完成两方面的事儿。一是封装了浏览器与janus流媒体服务器之间的业务接口，使得在浏览器端开发音视频会议系统变得特别简单；二是对WebRTC的API做了封装，这样用户不用再理会WebRTC底层API该何使用了。</p><p>总之一句话，就是大大的减了少JS用户使用janus的难度。</p><a id="more"></a><p>在阅读本文之前你应该已经熟悉了JavaScript语法，且对浏览器下调用WebRTC的API十分精通，否则你应该先去补齐相关知识再来阅读本文。 这里有一些参考资料仅供参考：<a href="https://avdancedu.com/18fc7df1/" target="_blank" rel="noopener">《js类的探究》</a>，在这篇文章中有介绍ES5与ES6之间的区别。<a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门与实战课程》</a>，该课程详细讲解了在浏览器下该如何使用WebRTC。</p><p>下面我们开始<code>janus.js</code>源码分析。</p><h2 id="核心类Janus"><a href="#核心类Janus" class="headerlink" title="核心类Janus"></a>核心类Janus</h2><p>对于<code>janus</code>源码的目录结构我已经在之前的文章中向你介绍过了，如果你还没看过，可以到<a href="https://avdancedu.com/fdfe2594/" target="_blank" rel="noopener">这里</a>看一下。通过目录结构我们可以知道，<code>janus.js</code>就在<code>janus</code>源码的<code>html</code>目录下。</p><p>大体浏览一下<code>janus.js</code>你会发现，整个文件有3000多行代码，但只有一个<code>类</code>，即<code>Janus</code>类。该类中实现了很多方法，然而核心代码量并不大，经抽丝拨茧，你会发现下面几个方法是比较关键的。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">function Janus(gatewayCallbacks) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建一个Session，私有方法</span><br><span class="line">    function createSession(callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;消毁Session，私有方法</span><br><span class="line">    function destroySession(callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;用于处理Janus信令</span><br><span class="line">    function eventHandler()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;信令事件处理函数，私有方法</span><br><span class="line">    function handleEvent(json, skipTimeout);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;发送消息，私有方法</span><br><span class="line">    function sendMessage(handleId, callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建插件处理函数，私有方法</span><br><span class="line">    function createHandle(callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;消毁插件处理方法</span><br><span class="line">    function destroyHandle(handleId, callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;发送candidate，私有方法</span><br><span class="line">    function sendTrickleCandidate(handleId, candidate);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建PC</span><br><span class="line">    function streamsDone(handleId, jsep, media, callbacks, stream);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;准备WebRTC</span><br><span class="line">    function prepareWebrtc(handleId, offer, callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;接收远端的SDP，并设备远端描述符</span><br><span class="line">    function prepareWebrtcPeer(handleId, callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建Offer</span><br><span class="line">    function createOffer(handleId, media, callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建answer</span><br><span class="line">    function createAnswer(handleId, media, callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;发送SDP</span><br><span class="line">    function sendSDP(handleId, callbacks);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对上面的这些方法，我们可以按类别将其划分成以下几类：</p><ul><li><p>Session相关</p><ul><li>createSession</li><li>destorySession</li></ul></li><li><p>信令处理</p><ul><li>handleEvent</li><li>eventHandler</li><li>sendMessage</li></ul></li><li><p>Plugin相关</p><ul><li>createHandle</li><li>destoryHandle</li></ul></li><li><p>WebRTC相关</p><ul><li>prepareWebrtc</li><li>prepareWebrtcPeer</li><li>createOffer</li><li>createAnswer</li><li>sendSDP</li><li>streamDone</li></ul></li></ul><p>接下来，我们就对这几个函数做下详细介绍，整体的介绍思路是：首先介绍一下它的主要功能是什么，然后再讨论一下它是怎么实现的。</p><h2 id="Session-相关"><a href="#Session-相关" class="headerlink" title="Session 相关"></a>Session 相关</h2><p>首先我们来看看 <code>Session</code> 的作用是什么。<code>Session</code>表示的是一个客户端与<code>janus</code>服务器之间建立的一个<code>信令通道</code>。janus客户端与服务器之间就是通过这个<code>信令通道</code>传输信令的。</p><p>Session是如何创建的呢？下面我们就来看一下<code>createSession</code>函数的处理逻辑。在<code>createSession</code>中，首先创建了一个JSON对象<code>request</code>，该对象中包括了以下几个信息：</p><ul><li>janus，代表一个信令，<code>create</code>表示要创建一个<code>session</code>。</li><li>token，唯一标识，用于鉴权。</li><li>apisecret，API调用码密，用于安全访问。</li></ul><p><code>request</code>对象构建好后，<code>createSession</code>函数会根据server地址的类型(如ws://、http://）判断是使用 websocket 接口还是使用 HTTP RESTFUL接口。判断逻辑如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">if(!server &amp;&amp; Janus.isArray(servers)) &#123;</span><br><span class="line">    &#x2F;&#x2F; We still need to find a working server from the list we were given</span><br><span class="line">    server &#x3D; servers[serversIndex];</span><br><span class="line">    if(server.indexOf(&quot;ws&quot;) &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">        websockets &#x3D; true;</span><br><span class="line">        Janus.log(&quot;Server #&quot; + (serversIndex+1) + &quot;: trying WebSockets to contact Janus (&quot; + server + &quot;)&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        websockets &#x3D; false;</span><br><span class="line">        Janus.log(&quot;Server #&quot; + (serversIndex+1) + &quot;: trying REST API to contact Janus (&quot; + server + &quot;)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果<code>createSession</code>判断server使用的是<code>websocket</code>接口，它就会走到<code>websocket</code>的处理逻辑分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(websockets)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个分支中，首先通过<code>Janus.newWebSocket</code>方法与server（janus服务器）建立连接。然后向websocket注册侦听事件，当websocket接收到不同的事件后就跳到对应事件的处理函数中执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">ws &#x3D; Janus.newWebSocket(server, &#39;janus-protocol&#39;);</span><br><span class="line">wsHandlers &#x3D; &#123;</span><br><span class="line">    &#39;error&#39;: ...,</span><br><span class="line">    &#39;open&#39;: ...,</span><br><span class="line">    &#39;message&#39;: ...,</span><br><span class="line">    &#39;close&#39;: ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(var eventName in wsHandlers) &#123;</span><br><span class="line">    ws.addEventListener(eventName, wsHandlers[eventName]);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在上代码中，注册到 websocket 中的 open 和 message 事件特别重要。websocket收到<code>open</code>事件说明与janus服务器之间已经成功建立了连接，此时我们就可以将之前准备好的 <code>request</code> 发送出去了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">transactions[transaction] &#x3D; function()...;</span><br><span class="line">ws.send(JSON.stringify(request));</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>当websocket连接创建好后，<code>janus.js</code>首先在transctons中创建一个新的<code>transaction</code>，然后将之前准备好的request发送给服务器。</p><blockquote><p>这里需要注意的是transaction，它表示一个事务或称之为上下文，当一件事儿由多个步骤多阶段组合完成时，我们一般都使用这种设计方案。</p></blockquote><p>服务端收到消息后进行逻辑处理，之后通过上面建立的连接将处理结果返回给<code>janus.js</code>，此时就会触发我们上面注册的<code>message</code>事件。在message事件中，对所有接收到的服务端的消息都由<code>handleEvent</code>函数进行处理。对于该函数我们后面还会做详细介绍，这里就不过多讲解了。</p><p>至此，<code>createSession</code> 函数的主要作用我们就分析完了，而<code>destorySession</code>是<code>createSession</code>的反函数，用于销毁<code>createSession</code>创建的资源，大家自己去看代码就好了，我这里不再做过多描述了。</p><p>接下来我们来看一下<code>janus.js</code>是如何处理从服务端接收到的信令的。</p><h2 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h2><p>上面讲解<code>Session</code>的创建时，我已经向你介绍了janus默认提供了两种传输信令的接口，即<code>websocket</code>处<code>http</code>。janus会根所用户访问地址的协议头来自动判断使用那种协议进行信令的传输。</p><p>对于服务端来讲，这两种接口的实现是在<code>janus</code>源码目录下的 <code>transports</code> 目录下，对应的实现文件为janus_websockets.c和janus_http.c文件，通过文件名我们也可以知道他们分别是websocket和http接口的实现了。</p><blockquote><p>当然janus不光支持这两种接口，它还支持好几种接口，但需要你手工配置。如果你不进行任何配置的话，它默认只支持这两种接口。</p></blockquote><p>下面是<code>janus</code>信令处理的简化架构图，我们通过这张图先从整体上了解一下janus是如何处理信令的。</p><p><img data-src="https://cdn.avdancedu.com/image/article/janus_js/janus_command.jpg" alt=""></p><p>上图将janus分成了两大部分，服务端和客户端。我们分别来介绍一下，首先来看看服务端的处理过程。</p><h3 id="服务端接收消息"><a href="#服务端接收消息" class="headerlink" title="服务端接收消息"></a>服务端接收消息</h3><p>通过上图我们可以看到，janus服务端的信令处理是由<code>transports</code>完成的，<code>transports</code>中包括很多插件，图中展示的<code>websocket</code>和<code>http</code>就是其中的两个。</p><p>这两个<code>transport</code>插件是在janus服务启动时加载起来的。以websocket插件为例，当该插件被加载后，websocket服务随即开启。此时，<code>janus.js</code>(JS客户端）就可以向该websocket服务发送消息了，同时<code>janus.js</code>也可以通过websocket连接接收来自服务端的信息。</p><p>当在服务端通过<code>websocket</code>收到消息后，最终会调用janus_websockets.c中的<code>janus_websockets_common_callback</code>方法将收到的消息传给janus core。janus core 收到消息后再根据消息类型做相应的处理。关于这块的逻辑我们先暂时放一放，待以有时间了我再说细介绍。</p><p>接下来我们再看客户端<code>janus.js</code>是如何处理的。</p><h3 id="客户端接收消息"><a href="#客户端接收消息" class="headerlink" title="客户端接收消息"></a>客户端接收消息</h3><p>客户端是如何处理消息的呢？我们还是从<code>Session</code>创建之后讲起。在<code>创建Session</code>一节中我已经介绍了，janus在websocket上侦听了<code>message</code>事件，每当websocket收到服务端发来的消息时，就会触发该事件。</p><p><code>janus.js</code>对该事件的处理方法是也比较简单，不管三七二十一直接将event中带来的数据交收<code>handleEvent</code>处理。<code>handleEvent</code>又是如何做的呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function handleEvent(json, skipTimeout) &#123;</span><br><span class="line">  ...</span><br><span class="line">  if(json[&quot;janus&quot;] &#x3D;&#x3D;&#x3D; &quot;keepalive&quot;) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; else if(json[&quot;janus&quot;] &#x3D;&#x3D;&#x3D; &quot;ack&quot;) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; else if(json[&quot;janus&quot;] &#x3D;&#x3D;&#x3D; &quot;success&quot;) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; else if(...</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>handleEvent</code>处理逻辑就如上面所示，对消息类型做判断，根据不同的类型做不同的处理。它能处理的消息包括以下几种:</p><ul><li>keepalive，心跳消息。</li><li>ack，确认消息。也就是说之前客户端发送了一个信令给服务端，服务端收到之后给客户端回了一个<code>ack</code>，确认服务端已经收到该消息了。</li><li>success，消息处理成功。该消息与 ack 消息是类似的，当服务器完成了客户端的命令后会返回该消息。</li><li>trickle，收集<code>候选者</code>用的消息。里边存放着 candidate，janus.js收到该消息后，需要将Candidate解析出来。</li><li>webrtcup，表示一个peer上线了，此时要找到以应的业务插件（plugin）做业务处理。</li><li>hangup，用户挂断，找到对应的plugin，进行挂断操作。</li><li>detached，某个插件要求与Janus Core之间断开连接。</li><li>media，开始或停信媒体流。</li><li>slowlink，限流？</li><li>error，错误消息</li><li>event，插件发磅的事件消息。</li><li>timeout，超时。</li></ul><p>对于janus.js来讲，上面这些消息有些是不需要再做处理的，有些是需要修改状态的，还有一些是与业务插件有关的，需要交由<code>pluginHandle</code>做进一步处理。 关于<code>pluginHandle</code>后面我们再做介绍。</p><p>以上就是janus客户端对从服务端接收到的消息的处理过程。当然在你阅读代码时还会看到<code>eventHandler</code>函数，这个函数是对handleEvent函数简单的封装，用在http接口上。由于websocket接口是长连接，所以直接使用的handleEvent函数，我们清楚这两个函数的联系与区别就OK了。</p><h3 id="客户端发送消息"><a href="#客户端发送消息" class="headerlink" title="客户端发送消息"></a>客户端发送消息</h3><p>上面我们主要介绍了从服务端来的消息janus是如何处理的，那客户端是如何发送消息的呢？</p><p>在<code>janus.js</code>中为上层应用封装了一个发送消息的方法，即<code>config.send()</code>。这个函数实际调用的是janus的<code>sendMessage</code>方法。我们来看一下它的大体实现吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function sendMessage(handleId, callbacks) &#123;</span><br><span class="line">    ...</span><br><span class="line">    var pluginHandle &#x3D; pluginHandles[handleId];</span><br><span class="line">    ...</span><br><span class="line">    var message &#x3D; callbacks.message;</span><br><span class="line">    ...</span><br><span class="line">    if(pluginHandle.token)</span><br><span class="line">        request[&quot;token&quot;] &#x3D; pluginHandle.token;</span><br><span class="line">    ...</span><br><span class="line">    var request &#x3D; &#123; &quot;janus&quot;: &quot;message&quot;, &quot;body&quot;: message, &quot;transaction&quot;: transaction &#125;;</span><br><span class="line">    ...</span><br><span class="line">    if(websockets)&#123;</span><br><span class="line">        ws.send(JSON.stringify(request));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码我们可以发现，在<code>sendMessage</code>中主要是构造<code>request</code>对象，然后将构造好的<code>request</code>消息通过<code>websocket</code>发送出去。</p><p>消息发送给janus服务器，服务器处理好后又会给客户端返回消息。消息返回到客户端后，后会触发websocket的<code>message</code>事件，这样就又回到了我们上面介绍的<code>handleEvent</code>处理函数。</p><h2 id="Plugin相关"><a href="#Plugin相关" class="headerlink" title="Plugin相关"></a>Plugin相关</h2><p>在<code>janus.js</code>中，<code>Plugin</code>相关函数的主要作用是，在客户端创建一个<code>pluginHandle</code>对象，并让该对象与janus服务端的某个插件关联。</p><p>所谓的关联就是在<code>pluginHandle</code>对象中保存着可以访问janus服务端插件的信息。该对象中存放着很多的信息，如session、plugin、webrtc等信息。下面我抽取了一些比较关键的信息，我们来详细分析一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">session : that,</span><br><span class="line">plugin : plugin,</span><br><span class="line">...</span><br><span class="line">token : handleToken,</span><br><span class="line">detached : false,</span><br><span class="line">webrtcStuff : &#123;</span><br><span class="line">    ...</span><br><span class="line">    mySdp : null,</span><br><span class="line">    mediaConstraints : null,</span><br><span class="line">    pc : null,</span><br><span class="line">    trickle : true,</span><br><span class="line">    iceDone : false,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面的字段就是<code>pluginHandle</code>对象的一些重要信息，在这些信息中包括了两在部分，基础信息部分和WebRTC信息部分。</p><p>首先我们看一下基础信息。session中保存的是<code>janus</code>核心类对象；plugin指明我们要与服务端那个个插件建立联接，例如<code>vidoeroom</code>插件；token用于安全访问；detached表明是否已经与服务端对应的<code>plugin</code>建立了联系。</p><p>接下来<code>webrtcStuff</code>域是与webrtc相关的参数。mySdp中保存的是本地SDP信息；mediaConstrains存放用于采集音视频数据的限制参数；pc表示PeerConnection；trickle指明在使用WebRTC时是否使用<code>trickle</code>机制；iceDone表明是否ICE建立成功了。</p><p>该对象中的内容是由<code>createHandle</code>函数创建和填充的，下面我们就来看一下<code>createHandle</code>函数做了哪些事儿？</p><p>在该函数中，它首先构造<code>request</code>对象，该对象包括以下几个信息：</p><ul><li>janus，表示信令类型， 在<code>createHandle</code>函数中，该域填的内容为<code>attach</code>，表示与某个<code>plugin</code> 进行绑定。</li><li>plugin，指明要绑定的具体<code>plugin</code>。<code>janus.plugin.videoroom</code></li><li>opaque_id，一个唯一的ID。</li><li>transaction，表示一个事务ID。</li><li>token，用于与服务器连接的合法标识</li><li>apisecret，API密码。</li><li>sessionID，session的唯一标识。</li></ul><p><code>request</code>对象创建好后，通过websocket发送给服务端，这样就在客户端与服务端的plugin插件建立了联接。</p><p>除了创建<code>request</code>对象外，该函数还创建了一个transaction对象，并将它存放在 <code>transactions</code> 数组中(<code>transactions[transaction]</code>)。</p><p>实际上 <code>transaction</code> 是一个函数，该函数中会创建一个<code>pluginHandle</code>对象，<code>pluginHandle</code>创建好后，也会被保存起来放到<code>pluginHandles</code>里以备后面使用。</p><p>除了<code>createHandle</code>函数之外，在janus.js中还有<code>destoryHandle</code>函数，它是<code>createHandle</code>的反函数，用于做释放操作。</p><p>以上就是janus.js中处理Plugin相关的函数。</p><h2 id="Webrtc相关"><a href="#Webrtc相关" class="headerlink" title="Webrtc相关"></a>Webrtc相关</h2><p>在<code>janus.js</code>中WebRTC相关的方法是最多的，也是最为重要的。其中尤以<code>prepareWebRTC</code>最为重要。下面我们就来详细介绍一下这个函数。</p><p>这个函数的作用是什么呢？说来起它还是蛮复杂的，我们来一项一项来介绍。一、它要过浏览器采集音视频数据，以便可以将数据上传给远端；二要与按照WebRTC的规规范进行媒体协商；三协商成功后要与远端建立连接；最后把采集的数据压缩编码后传到远端；</p><p>这个函数代码量非常大，我抽取了函数中重要的逻辑，这样更有利于我们撑握整个函数的流程脉络。代码整理如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">if(isAudioSendEnabled(media) || isVideoSendEnabled(media)) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;media为空，或者media.video不为屏幕，说明现在想采集视频数据</span><br><span class="line">    if(!media || media.video !&#x3D;&#x3D; &#39;screen&#39;) &#123;</span><br><span class="line">        &#x2F;&#x2F;遍历每个设备</span><br><span class="line">        navigator.mediaDevices.enumerateDevices().then( function(devices) &#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;如果是音频输入设备</span><br><span class="line">            var audioExist &#x3D; devices.some(function(device) &#123;</span><br><span class="line">                                return device.kind &#x3D;&#x3D;&#x3D; &#39;audioinput&#39;;</span><br><span class="line">                            &#125;),</span><br><span class="line">            &#x2F;&#x2F;如果是视频输入设置</span><br><span class="line">            videoExist &#x3D; isScreenSendEnabled(media) || devices.some(function(device) &#123;</span><br><span class="line">                                return device.kind &#x3D;&#x3D;&#x3D; &#39;videoinput&#39;;</span><br><span class="line">                            &#125;);</span><br><span class="line">           ...</span><br><span class="line">           &#x2F;&#x2F;设置采集数据的限制条件</span><br><span class="line">           var gumConstraints &#x3D; &#123;</span><br><span class="line">              audio: (audioExist &amp;&amp; !media.keepAudio) ? audioSupport : false,</span><br><span class="line">              video: (videoExist &amp;&amp; !media.keepVideo) ? videoSupport : false</span><br><span class="line">           &#125;;</span><br><span class="line"></span><br><span class="line">           ...</span><br><span class="line">           &#x2F;&#x2F;采集数据</span><br><span class="line">           navigator.mediaDevices.getUserMedia(gumConstraints)</span><br><span class="line">             .then(function(stream) &#123;</span><br><span class="line">               ...</span><br><span class="line">               &#x2F;&#x2F;</span><br><span class="line">               streamsDone(handleId, jsep, media, callbacks, stream);</span><br><span class="line">             &#125;).catch(function(error) &#123;...&#125;);</span><br><span class="line"></span><br><span class="line">        &#125;).catch(...);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过代码的梳理我们可以看到<code>prepareWebrtc</code>函数首先遍历所有设备，找出可用的设备，之外调用`getUserMedia函数去采集音视频数据。之后像媒体协商、Candidate的收集都在 streamDone 函数中完成。</p><p>接下来我们继续分析<code>streamsDone</code> 函数。下面是<code>streamsDone</code>函数的主要脉络代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function streamsDone(handleId, jsep, media, callbacks, stream) &#123;</span><br><span class="line">    ...</span><br><span class="line">    var config &#x3D; pluginHandle.webrtcStuff;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;创建PeerConnection</span><br><span class="line">    f(!config.pc) &#123;</span><br><span class="line">        var pc_config &#x3D; &#123;&quot;iceServers&quot;: iceServers, &quot;iceTransportPolicy&quot;: iceTransportPolicy, &quot;bundlePolicy&quot;: bundlePolicy&#125;;</span><br><span class="line">        ...</span><br><span class="line">        var pc_constraints &#x3D; &#123;</span><br><span class="line">            &quot;optional&quot;: [&#123;&quot;DtlsSrtpKeyAgreement&quot;: true&#125;]</span><br><span class="line">        &#125;;</span><br><span class="line">        ...</span><br><span class="line">        config.pc &#x3D; new RTCPeerConnection(pc_config, pc_constraints);</span><br><span class="line">        config.pc.oniceconnectionstatechange &#x3D; ...;</span><br><span class="line">        config.pc.onicecandidate &#x3D; ...;</span><br><span class="line">        config.pc.ontrack &#x3D; ...;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将本地track添加到流中</span><br><span class="line">    if(addTracks &amp;&amp; stream) &#123;</span><br><span class="line">        ...</span><br><span class="line">        config.pc.addTrack(track, stream);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建offer进行媒体协商</span><br><span class="line">    if(!jsep) &#123;</span><br><span class="line">        createOffer(handleId, media, callbacks);</span><br><span class="line">    &#125;else&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该函数中首先会根据限制条件创建一个<code>PeerConnection</code>。PeerConnection简称PC，它是浏览器下使用WebRTC的核心，想了解这块知识的同学可以看一下我的课程<a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门与实战》</a>，这里我就不过多讲解这部分内容了。</p><p>PC创建好后，需要将之前从<code>prepareWebrtc</code>中获取的本地音视频轨添加到PC中，为媒体协商做好准备。最后调用createOffer函数生成媒体协商中的<code>Offer</code>SDP与远端交换从成完成媒体协商。</p><p>现在你应该了解<code>streamsDone</code>函数的作用了吧？同时也应该清楚<code>prepareWebrtc</code>函数是干什么的了。</p><p>当我们将<code>prepareWebrtc</code>函数的功能搞清楚之后，对于其它的WebRTC相关API就比较容易理解了，由于篇幅的原因我就不在这里一一做介绍了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>上面我对janus.js文件做了全面的剖析，通过本文你应该知道<code>janus.js</code>的API可以分成四大类，分别是Session相关，信令相关，Plugin相关以及WebRTC相关的API。同时你也应该清楚，janus中的Session表示的是客户端与服务端之间的网络连接；客户端与服务器之间的信令是如何交互的，以及包括了哪些信令；<code>pluginHandle</code>的作用是用来保存访问远端插件的信息用的，同时它也保存了操作WebRTC相关的信息；而WebRTC相关的API是janus.js中最关键，最为复杂的。尤其是<code>prepareWebrtc</code>函数是最核心的API。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://avdancedu.com/18fc7df1/" target="_blank" rel="noopener">《js类的探究》</a>文中介绍了ES5与ES6之间的区别</li><li><a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门与实战课程》</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/janus_js/janus_logo.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Hello,大家好！今天我们继续来分析janus。相信现在大家应该对&lt;a href=&quot;https://janus.conf.meetecho.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;janus&lt;/a&gt; 都比较熟悉了，它是一套完整的音视频会议系统，包括了WebRTC流媒体服务器和客户端API两大部分。&lt;/p&gt;
&lt;p&gt;其中，客户端又包括Android、iOS以及浏览器端。今天我们要分析的内容就是浏览器端中的&lt;code&gt;janus.js&lt;/code&gt;文件。之所以要分析它，是因为它是浏览器端最关键的一个文件，了解了它我们基本上就将浏览器端的逻辑全部撑握了。&lt;/p&gt;
&lt;p&gt;从大的方面说，&lt;code&gt;janus.js&lt;/code&gt;主要完成两方面的事儿。一是封装了浏览器与janus流媒体服务器之间的业务接口，使得在浏览器端开发音视频会议系统变得特别简单；二是对WebRTC的API做了封装，这样用户不用再理会WebRTC底层API该何使用了。&lt;/p&gt;
&lt;p&gt;总之一句话，就是大大的减了少JS用户使用janus的难度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/categories/WebRTC/"/>
    
    
      <category term="janus" scheme="https://blog.avdancedu.com/tags/janus/"/>
    
  </entry>
  
  <entry>
    <title>音视频已强势崛起，我们该如何快速入门音视频技术？</title>
    <link href="https://blog.avdancedu.com/811929dc/"/>
    <id>https://blog.avdancedu.com/811929dc/</id>
    <published>2020-06-14T16:51:59.000Z</published>
    <updated>2020-06-29T05:28:25.028Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者： 李超 音视频直播技术专家<br>曾在 跟谁学 负责直播平台技术团队的管理工作；在 新东方集团 任职音视频技术专家；<br>在音视频会议行业工作6年，在线教育行业工作4年，一直聚焦在多人音视频实时互动领域。</p></blockquote><p>最近经常遇到一些同学问我如何学习音视频，怎样才能快速上手？还有一些对音视频不了解的同学问我该不该学习音视频？作为一名音视频行业的10年老兵，我有一些思考分享给大家，希望能对你有所帮助。</p><a id="more"></a><h2 id="大背景"><a href="#大背景" class="headerlink" title="大背景"></a>大背景</h2><p><img data-src="https://img1.sycdn.imooc.com/5e84c07f0001c21806890390.jpg" alt=""></p><p>2020年真的是一个多灾、多难的年份，冠状病毒的爆发使得本该举国欢庆的春节变得尤为沉闷。不能走亲，不能访友，除了呆在家里，那儿也不能去。正如张文宏大夫向我们劝解的，我们要将病毒给<code>闷死</code>。</p><p>大家都盼着疫情可以赶紧过去，早点恢复正常的生活。但从目前的情况看，短时间内这个疫情是很难结束的。这不刚从中国消停了一阵，又跑到海外大爆发了，谁知道它会不会又转回来呢？</p><p>可我们还得生活！还得工作！还要学习！</p><h2 id="好时代"><a href="#好时代" class="headerlink" title="好时代"></a>好时代</h2><p><img data-src="https://img1.sycdn.imooc.com/5e84c080000173fe12000437.jpg" alt=""></p><p>幸运的是我们生活在一个好时代，科技在这几十年得到了迅猛的发展。在疫情肆虐的当下，我们可以通过音视频会议进行远程办公；我们还有在线教育系统，对于大多数学生来说，完全可以在家进行在线学习。</p><p>从某个角度看，这次疫情虽然导致很多行业处于崩溃边缘，但也催生了新的行业发展，其中音视频会议和在线教育就是因<code>疫</code>而起的行业。在疫情短时间内难以结束的情况下，音视频会议和在线教育的重要性马上体现了出来，新的沟通方式和教育方式被越来越多的人所认知，所接纳。</p><p>甚至我们可以判定，在线教育行业和音视频会议行业会在今年崛起，并在未来十年得到迅猛发展。</p><p>目前，各大巨头公司（如阿里、腾讯、今日头条，新东方等），纷纷在这两个方向上谋篇布局，进行了大量的投资，笼络技术人才，也可以间接佐证这个判断了。</p><h2 id="大趋势"><a href="#大趋势" class="headerlink" title="大趋势"></a>大趋势</h2><p><img data-src="https://img1.sycdn.imooc.com/5e84c0820001ade512400564.jpg" alt=""></p><p>从未来的大趋势来看，随着5G时代的到来，音视频慢慢变成人们日常生活中的必须品。除了在线教育、音视频会议、即时通讯这些必须使用音视频技术的产品外，其它的产品也需要加入音频、视频元素。比如说将现在的网站注册与登陆的图文方式全部改为语音方式是否更加安全？相信随着音视频技术的普及，更加有创意的产品会如雨后春笋般孕育而生。</p><p>目前，音视频技术从之前的<strong>象牙塔</strong>逐渐走向<strong>百姓家</strong>已是不争的事实。正是因为这样一个大的趋势，现在除了各大厂之外，其它一些小厂也开始寻找音视频人才。一名稍好点的音视频人才现在可能会有3-4家公司抢着要、挣着要。</p><p>对音视频人才的需求从小众变成了大众，这更多的是大家对未来市场预期的结果。做个不恰当的比喻，3G/4G的出现，促成了移动互联网10年繁荣。而5G的出现，也会促成至少10年音视频行业的繁荣。</p><p><strong>除了5G的到来可以让音视频得到更广范的应用外，音视频技术在未来还有更重要的作用</strong>。事实上，在人类可以识别人信息中，音视频包含的信息是最丰富的，但人类并没有很好的将它们利用起来。</p><p>究其原因，是因为这些信息都是非结构化的数据，而人类善长的是处理结构化数据（比如数据库）。而对于这些非结构化的数据却无从下手的，所以这些音视频数据都被白白浪费掉了。</p><p>但随着计算机视觉、人工智能的发展，人们开始撑握了如何将音视频这类非结构化数据转化为结构化数据的方法。一旦我们将音视频数据转为结构化数据后，我们就可以利用现有的技术（如搜索引擎、大数据，数据挖掘等）对这些数据进行各种分析了，这个价值是不是更加惊人呢？而这一切的基础都是音视频技术。</p><p>所以，音视频研发的未来是极为广阔的。目前可以说是学习音视频的最佳时机，<strong>及早的加入音视频研发的队伍，才能使自己在未来的职场上更有作为</strong>。</p><h2 id="有钱景"><a href="#有钱景" class="headerlink" title="有钱景"></a>有钱景</h2><p><img data-src="https://img2.sycdn.imooc.com/5e84c0830001d45512000437.jpg" alt=""></p><p>正如我上面所说的，各大厂为了争夺未来，抢占先机，不惜重金笼络人才。通过招聘市场我们可以了解到，一名合格的音视频开发人员，少则年薪 30 万起，多则可以达 100万以上。</p><p>出现这种情况的原因主要有两个，一是音视频方面的人才不好培养，二是现有的优秀人才太少了。</p><p>从技术上来说，音视频从业者分成两个方向，一是搞算法的，另一个是搞工程的。搞音视频算法的这类人非常少，需要有深的数学能力和算法背景。相对来说，学习成本高，一般企业不需要，也养不起。这类人一般都会选择去大公司，薪水百万都是Low的。这些人一般只专注在一个领域上，因此就业面也窄。</p><p>搞工程的人相对多一些，他们有扎实的理论基础，很强的技术功底，对音频/视频都非常熟悉。这类人才工资要比同级别的其它开发人员薪资高20%以上。</p><p>因此，搞音视频技术的开发人员钱景还是非常乐观的。而且随着时间的推移，在未来几年音视频人才会更加炙手可热。</p><h2 id="音视频好学吗？"><a href="#音视频好学吗？" class="headerlink" title="音视频好学吗？"></a>音视频好学吗？</h2><p><img data-src="https://img1.sycdn.imooc.com/5e84c0850001c42712400565.jpg" alt=""></p><p>说句实话，音视频自学起来困难重重，学习成本非常高，且效率低。主要有两方面的原因，一是音视频知识庞杂，通俗易懂的资料非常少；另一方面，网上充斥着大量的错误信息，使得很多初学者掉到坑里就爬不出来了。</p><p>我来举个例子，按照传统的音视频学习方法，学习音视频你首先要阅读大量的音视频规范/协议文档（如H264、MP4/FLV、RTP/RTCP等）。这些文档中的内容基本都以<strong>位</strong>为单位的，即每个二进制位的变化都代表不同的含义，这种文档极其枯燥，很难阅读。</p><p>在对文档熟悉的前提下，再进行代码的开发难度就“更上一层楼”了。这时你会发现，如果你对 C/C++ 使用不熟练，没有专门进行过训练的话，你就进入了炼狱般的状况，那是一种折磨。</p><p>好在现在有FFMPG、WebRTC 等开源库，大大降低了研发成本。但即使这样，对于小白同学来说学习音视频依然是十分困难的。</p><h2 id="小白如何学习音视频？"><a href="#小白如何学习音视频？" class="headerlink" title="小白如何学习音视频？"></a>小白如何学习音视频？</h2><p><img data-src="https://img1.sycdn.imooc.com/5e84c0850001599610240576.jpg" alt=""></p><p>如上面所讲，音视频的入门难度还是蛮大的，我们该如何更快的入门呢？</p><p>我觉得最好的方式有非常好的课程，可以循序渐近，有条理、系统的学习。当然能有老师指导，遇到问题时老师能及时给予解答就更加锦上添花了。这样既可以快速入门，又可以系统的学习音视频知识，可以说这是最佳途径了。</p><p>对于能力强的同学也可以自学，但相对来说，这个时间成本就太高了。遇到一个坑卡几天是很正常的。网上音视频资料那么多坑，你想想要经历多长时间你才能真正学会它呢？即使你历尽千辛入门之后，你会发现离用人单位的要求还差着十万八千里呢。</p><p>对于各大厂来说，他们要招聘的人才既要有非常扎实的基础知识，又需要有一定的工程经验；如果你在学习的过程中没有实际做一些项目就很难达到它们的要求。</p><p>正是基于这样的考虑，我推出了一系列音视频的课程。这些课程中既有适合小白同学入门的课程（如<a href="https://coding.imooc.com/class/415.html?mc_marking=458ad0334bdc050a302667f903757fa0&mc_channel=shouji" target="_blank" rel="noopener">音视频小白系统入门</a>）, 又有进阶的课程（如<a href="https://coding.imooc.com/class/279.html?mc_marking=59c321c0417e144904c49c366f94dd57&mc_channel=shouji" target="_blank" rel="noopener">FFmpeg音视频核心技术精讲与实战</a>）。</p><p>其中与ffmpeg相关的课程是<a href="https://coding.imooc.com/class/415.html?mc_marking=458ad0334bdc050a302667f903757fa0&mc_channel=shouji" target="_blank" rel="noopener">音视频小白系统入门</a>和<a href="https://coding.imooc.com/class/279.html?mc_marking=59c321c0417e144904c49c366f94dd57&mc_channel=shouji" target="_blank" rel="noopener">FFmpeg音视频核心技术精讲与实战</a>。与 WebRTC 相关的课程是<a href="https://coding.imooc.com/class/329.html?mc_marking=59909dfb407cd07d4f3998dbc2d45c49&mc_channel=shouji" target="_blank" rel="noopener">WebRTC实时互动直播技术入门与实战</a>和 <a href="https://coding.imooc.com/class/387.html?mc_marking=6ebf81516468954587f53973c3c1789a&mc_channel=shouji" target="_blank" rel="noopener">WebRTC流媒体服务器设计与开发</a>。</p><p>如果你想学习音视频基础知识，音视频处理、编辑、特效相关的内容就学习ffmpeg的系列课程。如果你想学习音视频实时通讯（如音视频会议、在线教育）就学习WebRTC相关的课程。</p><h2 id="入门音视频要学习哪些内容呢？"><a href="#入门音视频要学习哪些内容呢？" class="headerlink" title="入门音视频要学习哪些内容呢？"></a><a href="https://coding.imooc.com/class/415.html?mc_marking=458ad0334bdc050a302667f903757fa0&mc_channel=shouji" target="_blank" rel="noopener">入门音视频要学习哪些内容呢？</a></h2><p><img data-src="https://img1.sycdn.imooc.com/5e84c086000163a706360300.jpg" alt=""></p><p>这里我简单列举一下入门音视频都要学哪些知识。对于已经学习了一些音视频知识而不知道自己目前水平的同学也可以作为一个参考，看看自己是否达到了入门水平。</p><ul><li>ffmpeg在不同系统中的安装与简单裁剪</li><li>音频基础知识，如频率、采样大小和通道数等</li><li>音频的压缩原理</li><li>如何从不同的设备上采集音频数据</li><li>如何对音频进行不同的编解码</li><li>视频的基础知识</li><li>H264编码原理</li><li>如何从不同设备上采集视频数据</li><li>熟悉YUV的一些常见格式（YUV420、NV21，YV12的不同）</li><li>如何将YUV数据编码为H264/H265、VP8/VP9等</li><li>FLV/RTMP/HLS/MP4协议要十分清楚<br>……</li></ul><p>从上面的列表中你可能看到，要入门音视频要学的知识还是不少的。尤其是音视频的基础原理是最为重要的，否则你去面试人家问你为什么会产生花屏，为什么会产生卡顿，如何才能秒开这些简单的问题你都无法回答上来。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总之，音视频已经强势崛起，相信未来的十年一定是音视频的十年。并且将音视频技术与计算机视觉和人工智能结合将引领未来二十年。</p><p>现在正是学习音视技术的最佳时机，大家一定要把握住机会，跟上时代的步伐，让自己可以在未来大有作为。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://coding.imooc.com/class/415.html?mc_marking=458ad0334bdc050a302667f903757fa0&mc_channel=shouji" target="_blank" rel="noopener">音视频小白系统入门</a></li><li><a href="https://coding.imooc.com/class/279.html?mc_marking=59c321c0417e144904c49c366f94dd57&mc_channel=shouji" target="_blank" rel="noopener">FFmpeg音视频核心技术精讲与实战</a></li><li><a href="https://coding.imooc.com/class/329.html?mc_marking=59909dfb407cd07d4f3998dbc2d45c49&mc_channel=shouji" target="_blank" rel="noopener">WebRTC实时互动直播技术入门与实战</a></li><li><a href="https://coding.imooc.com/class/387.html?mc_marking=6ebf81516468954587f53973c3c1789a&mc_channel=shouji" target="_blank" rel="noopener">WebRTC流媒体服务器设计与开发</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者： 李超 音视频直播技术专家&lt;br&gt;曾在 跟谁学 负责直播平台技术团队的管理工作；在 新东方集团 任职音视频技术专家；&lt;br&gt;在音视频会议行业工作6年，在线教育行业工作4年，一直聚焦在多人音视频实时互动领域。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近经常遇到一些同学问我如何学习音视频，怎样才能快速上手？还有一些对音视频不了解的同学问我该不该学习音视频？作为一名音视频行业的10年老兵，我有一些思考分享给大家，希望能对你有所帮助。&lt;/p&gt;
    
    </summary>
    
    
      <category term="音视频" scheme="https://blog.avdancedu.com/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="https://blog.avdancedu.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript入门</title>
    <link href="https://blog.avdancedu.com/48922786/"/>
    <id>https://blog.avdancedu.com/48922786/</id>
    <published>2020-06-12T16:12:07.000Z</published>
    <updated>2020-06-28T16:47:53.092Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/typescript/typescript.jpg" alt="TypeScript"><br>我们要学习一门新知识，首先要了解一些新知识的历史。<code>TypeScript</code> 是微软开发的，它的出现是为了解决 <code>JavaScript</code> 没有类型检查的弊端。因此，<code>TypeScript</code>并不是一门新语言，它的作用就是帮<code>JavaScript</code>检查数据类型是否正确，所以称它为<code>JavaScript</code>的一个<code>超集</code>是更贴切的。</p><p>有很多同学对 <code>TypeScript</code> 产生疑惑，他们会问 <code>TypeScript</code> 可以在浏览器上运行吗？</p><a id="more"></a><p>虽然<code>TypeScript</code>是<code>JavaScript</code>的一个<code>超集</code>，但由于它要进行类型检查，所以就与 JavaScript 的语法有一些不同了，因此 TypeScript 编写的程序是无法直接运行在浏览器上的。</p><h2 id="TypeScript-工作原理"><a href="#TypeScript-工作原理" class="headerlink" title="TypeScript 工作原理"></a>TypeScript 工作原理</h2><p>在讲解 <code>TypeScript</code> 工作原理之前，有一句话是你必须清楚且要印在脑子里的: <strong>在浏览器上，只能运行 JavaScript 脚本</strong>。</p><p>既然浏览器里只能运行<code>JavaScript</code>，那<code>TypeScript</code>具体又做了什么事儿呢？下面我就向你解释一下<code>TypeScript</code>都做了哪些事儿。</p><p>学习过编译原理的同学都清楚，<strong>类型检查</strong>就是<strong>语法分析</strong>，它属于编译器的范筹。TypeScript官网说: <strong>“TypeScrpt是JavaScript的超集，可以进行JavaScript类型检查。”</strong> 表明<code>TypeScript</code>为<code>JavaScript</code>增加了<strong>类型语法</strong>，并且它还有一个<strong>编译器</strong>，可以将用<code>TypeScript</code>语法编写的程序（.ts文件)，<strong>翻译成</strong> <code>JavaScript</code> 脚本语言。</p><p>因此，<code>TypeScript</code>的使用步骤一定是这样的: 首先用 <code>TypeScript</code> 语法编写程序；然后<strong>编译</strong>，输出<code>JavaScript</code>脚本；最终在浏览器中引用生成的 JavaScript 脚本这样一个过程。</p><p>实际情况也确实如此，在TypeScript的官网上你可以找到，TypeScript 有一个编译工具称为 <code>tsc</code>，即 <code>t</code>(ype) <code>s</code>(cript) <code>c</code>(ompiler)的缩写 。</p><h2 id="JavaScript的最大问题"><a href="#JavaScript的最大问题" class="headerlink" title="JavaScript的最大问题"></a>JavaScript的最大问题</h2><p>使用过其它面向对象语言的同学们再使用JavaScript开发时，都会觉得特别<code>难受</code>，因为JavaScript无法进行类型检查。对于Javascript语法来说，你传给它什么类型的数据都可以，这样虽然看似很<code>很好</code>，但一旦你将数据传错了，你得到的结果就是错误的。当错误出现时，没有任何的提示，光凭我们肉眼去查找错误实在是太费力了，这就是JavaScript的最大问题。</p><p>我们来看一个最简单的JavaScript例子你应该就清楚了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function func(msg)&#123;</span><br><span class="line">    console.log(&quot;the message is :&quot; + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码是一段最简单的JS代码，它需要一个字符串参数。但由于JavaScript并没有对参数的类型做限制，所以你在调用这个函数时，可以给他传任意的值。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func(123);</span><br><span class="line">func(&#39;this is my book!&#39;);</span><br><span class="line">func(func);</span><br></pre></td></tr></table></figure><p>我的本意是只有第二种调用<code>func</code>的方式才是正确的，但在JavaScript中上面这几种调用<code>func</code>函数的方法都是正确的。在我们实际工作中，我们写了很长的代码后，传入了一个错误的值时JavaScript就无法为我们检测出那里出错了，这是最可怕的。</p><p>这也是为什么<code>TypeScript</code>逐渐受到大家喜欢的原因。</p><h2 id="一个最简单的-TypeScript-程序"><a href="#一个最简单的-TypeScript-程序" class="headerlink" title="一个最简单的 TypeScript 程序"></a>一个最简单的 TypeScript 程序</h2><p>下面我们就来写一个最简单的 TypeScript程序，了解一下整个使用过程。咱们还是以 Helloworld 为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function hello(person: string) &#123;</span><br><span class="line">  return &#39;Hello , &#39; + person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let user&#x3D;&#39;xxx&#39;</span><br><span class="line">console.log(hello(user));</span><br></pre></td></tr></table></figure><p>上面就是一个简单的 TypeScript脚本，有了这个脚本后我们需要先对其进行编译，编译执行下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc hello.ts</span><br></pre></td></tr></table></figure><p>编译出 JavaScript 脚本后，通过 HTML5 引用一下就好了，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;user typescript&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;.&#x2F;hellots.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br></pre></td></tr></table></figure><p>至此，一个 TypeScript的简单使用过程就完成了，还是蛮简单的对吧！</p><h2 id="TS-调用JS"><a href="#TS-调用JS" class="headerlink" title="TS 调用JS"></a>TS 调用JS</h2><p>我们在使用TS开发时最常见的一个问题是如何通过 TS 调用 JS。产生该问题的根本原因是一些著名的 JS 库(如VUE）的TS版本还没有开发出来，但我们的项目中又必须使用他们，因此就产生了我前面所说的TS 库要调用 JS 库的情况。</p><p>我们前面也讲了 TS 本来就是 JS 的一个<code>超集</code>，因此它是有办法调用JS库的。从原理上我们可以证明这一点，因为TS程序最终要经过编译生成JS脚本程序后才能被浏览器执行，因此只要在浏览器上引入它需要的 JS 库，经编译后的 TS 程序就可以与其它的JS库相互调用。</p><p>按照上面的描述好像TS 调JS是很简单的事儿，那问题在哪儿呢？其实问题在于如果我们自己写的 TS 程序调用了其它第三方 JS 库，那么正常情况下 <code>tsc</code> 编译我们的 <code>ts</code> 程序时就会报错。所以实际的问题应该是，我们编写的TS程序在调用第三方JS库时，如何可以顺利编译通过呢？</p><p>我们在网上可以找到以下几种方案，第一种是将引用到的 JS 库直接翻译成 TS 库。很多同学看到这句话会<code>嗤之以鼻</code>，这明显就是行不通的方案。不过这种方案虽然难度很大，但总归还是一种方案不是；第二种是让<code>tsc</code>编译器不进行类型检查，那也就失去了 <code>TS</code> 的意义，所以这种方法也不是好办法；第三种是为 JS 库增加声名函数，这种方式既可以让<code>tsc</code>在编译时顺利通过，又同时可以检查我们写的代码是否有问题。</p><p>所以综上所述，第三种方案是最优的方案。</p><p>接下来我就来重点讲解一下如何通过第三种方案实现<code>TS</code>调用第三方<code>JS库</code>。首先我们先来创建一个JS库<code>test.js</code>，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function showmsg(msg)&#123;</span><br><span class="line">    console.log(&quot;the msg is :&quot; + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码非常简单，只实现了一个函数。该函数有一个参数<code>msg</code>，当该函数被调用时，输出传入的参数值。</p><p>接下来我们来看一下在<code>TS</code>中如何调用JS中的方法。为了使 TS 可以调用JS的方法，我们需要写一个与<code>JS</code>文件名对应的<code>.d.ts</code>文件。对于我们上面的<code>test.js</code>则需要有一个<code>test.d.ts</code>与之对应。</p><p>编写<code>.d.ts</code>文件也很简单，对于test.js来说，它的<code>.d.ts</code>文件内容如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare function showmsg( msg: string) : void;</span><br></pre></td></tr></table></figure><p>只需要这样一句就可以了。实际上，它就是为test.js文件中的showmsg函数定个声名。然后我们在使用它的TS文件中引用这个<code>.d.ts</code>文件就好了。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;reference path &#x3D; &quot;.&#x2F;test.d.ts&quot; &#x2F;&gt;</span><br><span class="line">function doSomeThing()&#123;</span><br><span class="line">    showmsg(&#39;ts&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doSomeThing();</span><br></pre></td></tr></table></figure><p>在TS文件中引用<code>.d.ts</code>文件的方法是，在文件的开头写上 <code>/// &lt;reference path=&quot;./test.d.ts&quot; /&gt;</code> 即可。这样当我们使用<code>tsc</code>去编译<code>.ts</code>文件时就不会报错了。</p><p>当<code>tsc</code>编译好TS文件后，我们可以在HTML中引入生成的JS文件以及它所使用的JS库了。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt; test ts call js&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;script src&#x3D;&quot;.&#x2F;test.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">        &lt;script src&#x3D;&quot;.&#x2F;my.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>此时，在浏览器的<code>debugger</code>里就可以看到<code>the msg is :ts</code>这句话了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我向你介绍了<code>TypeScript</code>的基本工作原理，从中我们可能知道TypeScript解决了JavaScript最大的问题，即类型检测。但TypeScript并不是一门新语言，它也不会代替JavaScript，它只是JavaScript的一个超集而以。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/typescript/typescript.jpg&quot; alt=&quot;TypeScript&quot;&gt;&lt;br&gt;我们要学习一门新知识，首先要了解一些新知识的历史。&lt;code&gt;TypeScript&lt;/code&gt; 是微软开发的，它的出现是为了解决 &lt;code&gt;JavaScript&lt;/code&gt; 没有类型检查的弊端。因此，&lt;code&gt;TypeScript&lt;/code&gt;并不是一门新语言，它的作用就是帮&lt;code&gt;JavaScript&lt;/code&gt;检查数据类型是否正确，所以称它为&lt;code&gt;JavaScript&lt;/code&gt;的一个&lt;code&gt;超集&lt;/code&gt;是更贴切的。&lt;/p&gt;
&lt;p&gt;有很多同学对 &lt;code&gt;TypeScript&lt;/code&gt; 产生疑惑，他们会问 &lt;code&gt;TypeScript&lt;/code&gt; 可以在浏览器上运行吗？&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://blog.avdancedu.com/categories/JavaScript/"/>
    
    
      <category term="js" scheme="https://blog.avdancedu.com/tags/js/"/>
    
  </entry>
  
</feed>
