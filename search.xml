<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ffmpeg精讲常见问题</title>
    <url>/f3f66133/</url>
    <content><![CDATA[<h2 id="问：编译-ffmpeg-方法"><a href="#问：编译-ffmpeg-方法" class="headerlink" title="问：编译 ffmpeg 方法"></a>问：编译 ffmpeg 方法</h2><p>答：在各个平台编译方法基本都是一样的。</p>
<ul>
<li>首先下载 ffmpeg 源码，地址为: <a href="https://www.ffmpeg.org/download.html" target="_blank" rel="noopener">https://www.ffmpeg.org/download.html</a></li>
<li>进入到下载后的<a href="https://coding.imooc.com/class/279.html?mc_marking=59c321c0417e144904c49c366f94dd57&mc_channel=shouji" target="_blank" rel="noopener">ffmpeg目</a>录下，执行下面的指令：<a id="more"></a>
<ul>
<li>Mac 平台：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;ffmpeg</span><br><span class="line">                  --enable-gpl</span><br><span class="line">                  --enable-nonfree</span><br><span class="line">                  --enable-libfdk-aac</span><br><span class="line">                  --enable-libx264</span><br><span class="line">                  --enable-libx265</span><br><span class="line">                  --enable-filter&#x3D;delogo</span><br><span class="line">                  --enable-debug</span><br><span class="line">                  --disable-optimizations</span><br><span class="line">                  --enable-libspeex</span><br><span class="line">                  --enable-videotoolbox</span><br><span class="line">                  --enable-shared</span><br><span class="line">                  --enable-pthreads</span><br><span class="line">                  --enable-version3</span><br><span class="line">                  --enable-hardcoded-tables</span><br><span class="line">                  --cc&#x3D;clang</span><br><span class="line">                  --host-cflags&#x3D;</span><br><span class="line">                  --host-ldflags&#x3D;</span><br></pre></td></tr></table></figure></li>
<li>Linux平台<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;ffmpeg</span><br><span class="line">                  --enable-gpl</span><br><span class="line">                  --enable-nonfree</span><br><span class="line">                  --enable-libfdk-aac</span><br><span class="line">                  --enable-libx264</span><br><span class="line">                  --enable-libx265</span><br><span class="line">                  --enable-filter&#x3D;delogo</span><br><span class="line">                  --enable-debug</span><br><span class="line">                  --disable-optimizations</span><br><span class="line">                  --enable-libspeex</span><br><span class="line">                  --enable-shared</span><br><span class="line">                  --enable-pthreads</span><br></pre></td></tr></table></figure></li>
<li>Windows平台<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;ffmpeg</span><br><span class="line">                  --enable-gpl</span><br><span class="line">                  --enable-nonfree</span><br><span class="line">                  --enable-libfdk-aac</span><br><span class="line">                  --enable-libx264</span><br><span class="line">                  --enable-libx265</span><br><span class="line">                  --enable-filter&#x3D;delogo</span><br><span class="line">                  --enable-debug</span><br><span class="line">                  --disable-optimizations</span><br><span class="line">                  --enable-libspeex</span><br><span class="line">                  --enable-static</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<h2 id="问：make-amp-amp-make-install失败"><a href="#问：make-amp-amp-make-install失败" class="headerlink" title="问：make &amp;&amp; make install失败"></a>问：make &amp;&amp; make install失败</h2><p>答：make &amp;&amp; make install 之所以会失败，则由于该用户没有操作目录的权限引起的。所以只需要在make install 之前加 sudo即可。</p>
<p>另一种方法是将用户切换成 root用户，因 root用户的权力最大，所以这样做也是没问题的。但建议还是用 非 root用户操作，这样更安全。</p>
<h2 id="问：库已经安装好了，但仍报找不到它的错误？"><a href="#问：库已经安装好了，但仍报找不到它的错误？" class="headerlink" title="问：库已经安装好了，但仍报找不到它的错误？"></a>问：库已经安装好了，但仍报找不到它的错误？</h2><p>答：首先确认是否已经将 <code>pkg-config</code>工具安装好了。可以执行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pkg-config</span><br></pre></td></tr></table></figure>
<p>如果提示没有安装，则先将该工具安装好，安装命令如下：</p>
<ul>
<li>ubuntu  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt intall pkg-config</span><br></pre></td></tr></table></figure></li>
<li>mac  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install pkg-config</span><br></pre></td></tr></table></figure></li>
<li>cygwin  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-cyg install pkg-config</span><br></pre></td></tr></table></figure></li>
<li>centos  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install pkg-config</span><br></pre></td></tr></table></figure>
安装完该工具后仍然报错？那再按照具体的错误看下面的解决方案吧。</li>
</ul>
<h2 id="问：libx264库找不到（-ERROR-libx264-not-found-）"><a href="#问：libx264库找不到（-ERROR-libx264-not-found-）" class="headerlink" title="问：libx264库找不到（[ERROR: libx264 not found]）"></a>问：libx264库找不到（[ERROR: libx264 not found]）</h2><p>该问题可能由下面三个方面的问题引起。</p>
<ul>
<li>libx264库没有安装。对于这种情况有两种解决办法:<ul>
<li>其一，是通过平台的安装工作进行安装，如 apt/brew/yum install x264。（注：在Linux下应该安装 libx264-dev）。</li>
<li>其二，是通过源码安装，步骤如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. wget https:&#x2F;&#x2F;code.videolan.org&#x2F;videolan&#x2F;x264&#x2F;-&#x2F;archive&#x2F;master&#x2F;x264-master.tar.bz2</span><br><span class="line">2. bunzip2 x264-master.tar.bz2</span><br><span class="line">3. tar -vxf x264-master.tar.tar</span><br><span class="line">4. .&#x2F;configure --enable-static --enable-shared --disable-asm --disable-avs</span><br><span class="line">5. make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>通过 pkg-config 命令无法找到。对于这类问题，我们可以使用下面的命 <code>pkg-config --cflags --lib libx264</code>看是否可以找到 libx264，如果找不到，就说明确实是这个问题。解决的办法是设置环境变量。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PKG_CONFIG_PATH&#x3D;$PKG_CONFIG_PATH:&#x2F;xxx&#x2F;xxx&#x2F;lib&#x2F;pkgconfig</span><br></pre></td></tr></table></figure>
其中 <code>xxx</code> 由你的实际路径代替。</li>
</ul>
<blockquote>
<p>注，有可能你的系统中并没有装 pkg-config工具，可以使用 brew/apt/yum install pkg-config进行安装。</p>
</blockquote>
<ul>
<li>无法链接上libx264, 这是由于通过环境变量 LD_LIBRARY_PATH 无法定位到 libx264库。解决的办法也很简单，与上面类似，可以通过设置环境变量来解决该问题。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export LD_LIBRARY_PATH&#x3D;$LIB_LIBRARY_PATH:&#x2F;xxx&#x2F;xxx&#x2F;lib</span><br></pre></td></tr></table></figure>
其中，<code>xxx</code>由你的实际路径代替。</li>
</ul>
<p>当然，你也可以将环境变量设置在脚本里，这样就不用每次都写export命令了。只需要将上面的两条语句加入到 <del>/.bashrc / 或</del>/.bash_profil 文件里，然后在控制台执行 <code>source ~/.bashrc</code> 或 <code>source ~/.bash_profile</code>即可。</p>
<h2 id="问：fdk-aac库找不到（-ERROR-libfdk-aac-not-found-）"><a href="#问：fdk-aac库找不到（-ERROR-libfdk-aac-not-found-）" class="headerlink" title="问：fdk-aac库找不到（[ERROR: libfdk_aac not found]）"></a>问：fdk-aac库找不到（[ERROR: libfdk_aac not found]）</h2><p>答：该问题与上面的 libx264 问题类似，所以只需要将上面的 libx264替换为libfdk-aac即可。这里不在赘述。</p>
<h2 id="问：speex库找不到（-ERROR-speex-not-found-）"><a href="#问：speex库找不到（-ERROR-speex-not-found-）" class="headerlink" title="问：speex库找不到（[ERROR: speex not found]）"></a>问：speex库找不到（[ERROR: speex not found]）</h2><p>答：该问题与上面的 libx264 问题类似，所以只需要将上面的 libx264替换为speex即可。这里不在赘述。</p>
<h2 id="问：编译不出ffplay"><a href="#问：编译不出ffplay" class="headerlink" title="问：编译不出ffplay"></a>问：编译不出ffplay</h2><p>答：引起该问题有以下几方面的原因：</p>
<ul>
<li>所使用的操作系统没有安装图形库。如有的同学在阿里的云服务器上想安装ffplay是肯定不行的。</li>
<li>没有安装 SDL2 库。解决办法是通过 brew/apt/yum install sdl2 即可 或 通过 SDL2 源码安装。<strong>安装完成后，要重新进行到 ffmpeg目录下，执行 ./configure…这指命令。</strong></li>
<li>有的同学编译ffmpeg时，在ffmpeg目录执行./configure … 之后，没有修改config.h文件，这样也编译不出ffplay来。解决办法是进入到 ffmpeg 目录下，打开 config.h文件找 FFPLAY 关键字，将其后面的 0 修改为 1，保存并退出该文件。在当前目录下执行 make &amp;&amp; sudo  make install。<strong>注意，修改 config.h文件后，不要再执行./configure …了，否则config.h中的值又都恢复为原来的值了。</strong></li>
<li>SDL2与最新的Mac系统 mojave不兼容。解决办法：<ul>
<li>方法一<ul>
<li>从 <a href="https://www.libsdl.org/tmp/release/SDL2-2.0.9.tar.gz" target="_blank" rel="noopener">SDL</a>下载 2.0.9版本或以后的SDL2代码。</li>
<li>执行 ./configure</li>
<li>执行 make &amp;&amp; sudo make install</li>
<li>执行 export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig</li>
<li>[重新]编译ffmpeg</li>
</ul>
</li>
<li>方法二<ul>
<li>从<a href="https://www.libsdl.org/tmp/release/SDL2-2.0.9.dmg" target="_blank" rel="noopener">SDL</a>下载dmg包。</li>
<li>执行 open SDL2-2.0.9.dmg</li>
<li>[重新]编译ffmpeg</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="SDL在windows的-cygwin下无法打印日志"><a href="#SDL在windows的-cygwin下无法打印日志" class="headerlink" title="SDL在windows的 cygwin下无法打印日志"></a>SDL在windows的 cygwin下无法打印日志</h2><p>在编译 SDL 时，将configure 中的 <code>-mwindows</code> 参数去掉。</p>
<h2 id="问：如何在Windows下编译ffmpeg问题"><a href="#问：如何在Windows下编译ffmpeg问题" class="headerlink" title="问：如何在Windows下编译ffmpeg问题"></a>问：如何在Windows下编译ffmpeg问题</h2><p>答：参见 <a href="https://www.imooc.com/article/247113" target="_blank" rel="noopener">Windows下编译ffmpeg问题</a></p>
<h2 id="问：在Windows下编译安装ffmpeg是不是特别麻烦？"><a href="#问：在Windows下编译安装ffmpeg是不是特别麻烦？" class="headerlink" title="问：在Windows下编译安装ffmpeg是不是特别麻烦？"></a>问：在Windows下编译安装ffmpeg是不是特别麻烦？</h2><p>答：确实是这样。所以建议在Window开发者最好装一个 Ubuntu的虚拟机，这样就方便很多了。如果条件允许的话，最好能用Mac开发。可以说Mac Pro是关专为开发者制造的，一旦你用上它会让你爱不释手。</p>
<h2 id="问：编译时，各种库找不到问题"><a href="#问：编译时，各种库找不到问题" class="headerlink" title="问：编译时，各种库找不到问题"></a>问：编译时，各种库找不到问题</h2><p>答：该问题与上面的 libx264类似，我们可以通过 <code>brew/apt/yum install xxx</code> 命令进行安装，一般情况下这种方式都可以满足我们的需求。如果始终不行的话，就需要源码安装了。源码安装的方法可以参见 <a href="https://www.imooc.com/article/247113" target="_blank" rel="noopener">Windows下编译ffmpeg问题</a> 里的说明。</p>
<h2 id="问：ffmpeg如何使用-libx265"><a href="#问：ffmpeg如何使用-libx265" class="headerlink" title="问：ffmpeg如何使用 libx265"></a>问：ffmpeg如何使用 libx265</h2><p>答：准确的讲ffmpeg应该是一个音视频框架，所有的音视频编解码器都是以插件的方式与ffmpeg联系起来的。换句话说，ffmpeg在上层提供了统一的 API，无法你使用的编解决是 x264, open264, x265, vp8/vp9/av1 上层用户都不管心，它仍然使用同样的 API， 只是在find_decoder 或 find_encoder时，指定具体的编解码器就可以了。也就是说在find_xxx时，你要设置了 x264 它最终就会调用 x264进行编解码，设置了 x265它就使用 x265进行编解码。如些而已。</p>
<h2 id="问：这门课有群吗？"><a href="#问：这门课有群吗？" class="headerlink" title="问：这门课有群吗？"></a>问：这门课有群吗？</h2><p>答：有的，群号：883069602，不过<a href="https://coding.imooc.com/class/279.html?mc_marking=59c321c0417e144904c49c366f94dd57&mc_channel=shouji" target="_blank" rel="noopener">需要购买课程</a>后输入验证码才可以进群。大家可以在群里讨论问题，也可以在课程的评论区里搜索答案。目前评论区里已经积累了大量问题的解决方案。</p>
<h2 id="问：为什么我使用课程中的程序无法成功抽取AAC音频？"><a href="#问：为什么我使用课程中的程序无法成功抽取AAC音频？" class="headerlink" title="问：为什么我使用课程中的程序无法成功抽取AAC音频？"></a>问：为什么我使用课程中的程序无法成功抽取AAC音频？</h2><p>答：<a href="https://www.imooc.com/article/254733" target="_blank" rel="noopener">详细回答在这里</a></p>
<h2 id="问：Android播放器例子为什么调API失败"><a href="#问：Android播放器例子为什么调API失败" class="headerlink" title="问：Android播放器例子为什么调API失败"></a>问：Android播放器例子为什么调API失败</h2><p>答：你目前使用的 NDK 版本与我编译时使用的 NDK 版本不一致造成的，换成 NDK10e试试。</p>
<h2 id="问：NDK10e-从哪里下载"><a href="#问：NDK10e-从哪里下载" class="headerlink" title="问：NDK10e 从哪里下载"></a>问：NDK10e 从哪里下载</h2><p>答：可以到<a href="https://developer.android.com/ndk/downloads/older_releases" target="_blank" rel="noopener">这里</a>下载。</p>
<ul>
<li><a href="https://dl.google.com/android/repository/android-ndk-r10e-darwin-x86_64.zip" target="_blank" rel="noopener">mac NDK10e</a></li>
<li><a href="https://dl.google.com/android/repository/android-ndk-r10e-windows-x86.zip" target="_blank" rel="noopener">windows 32 位 NDK10e</a></li>
<li><a href="https://dl.google.com/android/repository/android-ndk-r10e-windows-x86_64.zip" target="_blank" rel="noopener">windows 64位 NDK10e</a></li>
<li><a href="https://dl.google.com/android/repository/android-ndk-r10e-linux-x86_64.zip" target="_blank" rel="noopener">linux NDK10e</a></li>
</ul>
<h2 id="问：NDKr21-从哪里下载"><a href="#问：NDKr21-从哪里下载" class="headerlink" title="问：NDKr21 从哪里下载"></a>问：NDKr21 从哪里下载</h2><p>答：可以到这里下载。</p>
<ul>
<li><a href="https://dl.google.com/android/repository/android-ndk-r21-darwin-x86_64.zip" target="_blank" rel="noopener">mac NDKr21</a></li>
<li><a href="https://dl.google.com/android/repository/android-ndk-r21-windows-x86_64.zip" target="_blank" rel="noopener">windows NDKr21</a></li>
<li><a href="https://dl.google.com/android/repository/android-ndk-r21-linux-x86_64.zip" target="_blank" rel="noopener">linux NDKr21</a></li>
</ul>
<h2 id="问：ffmpeg安装好后，编译视频中的ffmpeg-log不成功"><a href="#问：ffmpeg安装好后，编译视频中的ffmpeg-log不成功" class="headerlink" title="问：ffmpeg安装好后，编译视频中的ffmpeg_log不成功"></a>问：ffmpeg安装好后，编译视频中的ffmpeg_log不成功</h2><p>答：执行下面的命令进行编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -g -o ffmpeg_log ffmpeg_log.c &#96;pkg-config --libs --cflags libavutil&#96;</span><br></pre></td></tr></table></figure>
<p><strong>注意：pkg-confg 前面的符号不是<code>&#39;</code>哟！它是键盘左上角 ESC键下面的键。</strong></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>该文章会不定期更新，我们将一些大家使用<a href="https://coding.imooc.com/class/279.html?mc_marking=59c321c0417e144904c49c366f94dd57&mc_channel=shouji" target="_blank" rel="noopener">ffmpeg</a>常见的问题更新到这里来。</p>
<h2 id="视频课地址"><a href="#视频课地址" class="headerlink" title="视频课地址"></a>视频课地址</h2><p><a href="https://www.imooc.com/u/4873493/courses?sort=publish" target="_blank" rel="noopener">课程主页地址</a></p>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
        <tag>音视频</tag>
        <tag>直播</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo中如何画图</title>
    <url>/f3ccc53/</url>
    <content><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/markdown_flow/markdown.jpg" alt="Markdown时序图"></p>
<p>有很多同学觉得用Markdown画图是一个很鸡肋的事儿，一是Markdown画不了太复杂的图，如果图太复杂了估计能把自己绕晕；二是Markdown画不了特别漂亮的图，比如你想通过颜色来区分一些元素的作用Markdown就无能为力了。</p>
<p>我以前也是持有这种态度，所以一直很反对使用Markdown画图。但最近我的思想有所改变，我认为Markdown画图还是有它的优势的。</p>
<a id="more"></a>

<p>Markdown绘图有两方面优势，一是通过Markdown画的图不占带宽，这个优势对我来说特别有吸引力。因为我的主机本来带宽就不足，要是在一篇文章中图片太多的话页面加载的速度就太慢了。</p>
<p>二是Markdown的绘图功能还在不断发展中，没准那天就可以做到手工在页面里直接编辑的程度了，我相信这一天不会太迟到来。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>下面这两幅图就是用Markdown语法绘制的，第一个是流程图，第二个是时序图。看着是不是觉得也还蛮不错的呢？</p>
<ul>
<li><p>流程图</p>
<center>
<div id="flowchart-0" class="flow-chart"></div>
</center>
</li>
<li><p>时序图</p>
</li>
</ul>
<center>
<div id="sequence-0"></div>
</center>

<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>当然，目前要想实现Markdown绘图还需要安装插件，对于每种不同类型图要安装不同的插件。绘制流程图要安装<code>hexo-filter-flowchart</code>; 绘制时序图要安装<code>hexo-filter-sequence</code>。</p>
<p>安装的方法以及Markdown的语法我以后再来补充</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在Markdown上绘制图型还是有它的优势的，尤其对于自建博客的同学会更愿意偿试这种方式绘制图型。</p>
<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: Start|past:>http://www.google.com[blank]
e=>end: End:>http://www.google.com
op1=>operation: My Operation|past
op2=>operation: Stuff|current
sub1=>subroutine: My Subroutine|invalid
cond=>condition: Yes
or No?|approved:>http://www.google.com
c2=>condition: Good idea|rejected
io=>inputoutput: catch something...|request

st->op1(right)->cond
cond(yes, right)->c2
cond(no)->sub1(left)->op1
c2(yes)->io->e
c2(no)->op2->e</textarea><textarea id="flowchart-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.27/webfontloader.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">Alice->Bob: Hello Bob, how are you?
Note right of Bob: Bob thinks
Bob-->Alice: I am good thanks!</textarea><textarea id="sequence-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script>]]></content>
      <tags>
        <tag>hexo 流程图 时序图</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用命令及一些特殊用法</title>
    <url>/423abe9e/</url>
    <content><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/git/git-banner.jpg" alt=""><br>本文主要记录一些工作中常用的 git 命令，以及一些比较特殊的git用法，希望这些命令对您也能有所帮助。</p>
<a id="more"></a>

<h2 id="git-的基本工作原理"><a href="#git-的基本工作原理" class="headerlink" title="git 的基本工作原理"></a>git 的基本工作原理</h2><p>其实要想使用好git，你必须要知道一点git的工作原理，否则你在使用git时就只能死记硬背一些命令。如果你还处理死记硬背一些git命令的阶段，那么一旦你遇到一个非常复杂的或非手棘手的git case时，可以100%肯定你是无法解决的。</p>
<p>因此，了解一点git的基本工作原理是我们每个开发人员都必须的基础知识，下面我就对git的的基本工作原理做一下简要介绍。</p>
<h3 id="git的结构"><a href="#git的结构" class="headerlink" title="git的结构"></a>git的结构</h3><p>首先我们必须要清楚是，git是由三大部分组成的，即本地工作区，本地仓库以及远程仓库。</p>
<ul>
<li>本地工作区，就是你平常写代码或修改代码的地方。</li>
<li>本地仓库，就是我们工作区中.git目录。它里边有一堆子目录，这些子目录都有各自的用途，我们暂且不管。</li>
<li>远程仓库，这个比较好理解了，就是远端的git仓库，比如我们在github上创建的仓库。</li>
</ul>
<p>通过下面这张图我们可以更直观的了解这三大部分：<br><img data-src="https://cdn.avdancedu.com/image/article/git/git_base.jpg" alt="git结构图"></p>
<p>从图中我们可以清楚的知道，平时我们使用git的三个主要命令(git add、git commit、git push)具体都做了些什么:</p>
<ul>
<li>git add: 将本地工作区中代码的修改保存到本地仓库的staged区，即暂存区。</li>
<li>git commit: 将staged区中的内容保存到本地仓库。</li>
<li>git push: 将本地仓库中的内容推送给远程仓库保存。</li>
</ul>
<p>通过上面这张图我们可以得出以下几点重要结论。</p>
<p>第一，git在处理我们的提交时是按顺序、分阶段的。比如我们的一个提交，必须先到 staged 后才能进入本地仓库，这个处理顺序是不能乱的。</p>
<p>第二，git管理中有一个 HEAD 指针，它始终指向正在处理的git commit。而它的前一次git commit 可以用<code>HEAD^</code>表式，它的上上次commit可以用<code>HEAD ^^</code>表式。</p>
<p>第三，当我们想用地本仓库的内容更新本地工作区的内容时，如果 staged 中没有内容，则可以直接用本地仓库的内容更新本地工作区内容。但如果 staged 中有内容，则需要先更新staged ，然后再更新本地工作区。</p>
<p>第四，git的核心是本地仓库，所有的操作都是围绕着它来的。它既是用户<code>commit</code>的终点，又是远程仓库的接收<code>commit</code>起点。我们在使用git时，可以向本地仓库提交多次修改，而只向远程仓库推送一次，git推送时会将之前的多个<code>commit</code>合并到一起。</p>
<h3 id="git的分支管理"><a href="#git的分支管理" class="headerlink" title="git的分支管理"></a>git的分支管理</h3><p>在git中还有一个特别重要的概念就是branch，即分支。它是我们多人合作开发的基础。如下图所示：<br><img data-src="https://cdn.avdancedu.com/image/article/git/git_branch.jpg" alt="git 分支"></p>
<p>通过上图我们可以清楚的知道，git是以<strong>指针</strong>的方式对分支进行管理的。下面我们来详述一下git是如何管理分支的。</p>
<p>当我们执行<code>git init</code>时，git默认为我们创建一个分支，即<code>Master</code>分支。而HEAD指针也被初始化指向Master分支，因此每当你提交新的修改时，这些修改都会被压入到Master分支<strong>栈</strong>上。</p>
<p>当然一般情况下我们都不会轻易对Master分支做操作，而是创建一个<code>Dev</code>分支作为我们的开发分支。在git中你可以执行<code>git branch branchname</code>命令来创建一个新分支，比如将branchname设置为<code>Dev</code>，这样我们就创建出了<code>Dev</code>分支。</p>
<p>然后你可以执行<code>git checkout Dev</code> 命令，它的作用是让<code>HEAD</code>指向Dev分支。后面你所有的commit就都被<strong>push</strong>到Dev分支上了。</p>
<p>如果你觉得执行两条命令比较麻烦，你也可以将上面的两步合并为一步，执行<code>git checkout -b branchname</code>这一条命令就可以了，这也是我们平常真正使用的命令。</p>
<p>通过上面的描述，我想你应该对git的工作原理有了最基本的了解了，下面我们再来看这些命令时就很容易理解它们的作用以及为什么要这么做了。</p>
<h2 id="已有代码该如何提效到仓库中"><a href="#已有代码该如何提效到仓库中" class="headerlink" title="已有代码该如何提效到仓库中"></a>已有代码该如何提效到仓库中</h2><p>第一步，在github 上创建一个仓库。<br>第二步，执行下面的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:avdance&#x2F;test.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<h2 id="本地与远程有突冲，想放弃本地修改"><a href="#本地与远程有突冲，想放弃本地修改" class="headerlink" title="本地与远程有突冲，想放弃本地修改"></a>本地与远程有突冲，想放弃本地修改</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard FETCH_HEAD</span><br></pre></td></tr></table></figure>

<h2 id="重新从远端拉取某个文件"><a href="#重新从远端拉取某个文件" class="headerlink" title="重新从远端拉取某个文件"></a>重新从远端拉取某个文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -- a.c</span><br></pre></td></tr></table></figure>

<h2 id="撤消某次-add"><a href="#撤消某次-add" class="headerlink" title="撤消某次 add"></a>撤消某次 add</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rm --cached &lt;added_file_to_undo&gt;</span><br></pre></td></tr></table></figure>

<h2 id="撤消某次-commit"><a href="#撤消某次-commit" class="headerlink" title="撤消某次 commit"></a>撤消某次 commit</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --soft commitID  只是删除了commitId之后的commit记录,但是代码改动仍然存在</span><br><span class="line">git reset --hard commitID  彻底的回到CommitID时候的版本,之后的改动不存在了</span><br></pre></td></tr></table></figure>

<h2 id="将本地修改先暂存起来"><a href="#将本地修改先暂存起来" class="headerlink" title="将本地修改先暂存起来"></a>将本地修改先暂存起来</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash 将本地修改暂存起来</span><br><span class="line">git stash pop 弹出暂存的修改</span><br></pre></td></tr></table></figure>

<h2 id="查看有冲突的文件"><a href="#查看有冲突的文件" class="headerlink" title="查看有冲突的文件"></a>查看有冲突的文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status -uno</span><br></pre></td></tr></table></figure>

<h2 id="不显示临时文件"><a href="#不显示临时文件" class="headerlink" title="不显示临时文件"></a>不显示临时文件</h2><p>在 .gitignore 中添加不想被 git staus 看到的文件或目录</p>
<h2 id="暂时回滚到某版本"><a href="#暂时回滚到某版本" class="headerlink" title="暂时回滚到某版本"></a>暂时回滚到某版本</h2><p>首先通过 git log查看你之前的提交码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log | more</span><br></pre></td></tr></table></figure>
<blockquote>
<p>commit 4adb3f0ecd9dbc79bd09666d88f8c2520305c001<br>Author: xxxxxx<br>Date:   Thu Jan 25 11:51:45 2018 +0800</p>
</blockquote>
<p>摘取 commit 码的前 7位，执行下面的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout 4adb3f0</span><br><span class="line">git reset --hard 4adb3f0</span><br></pre></td></tr></table></figure>

<h2 id="切换-回滚到主分支"><a href="#切换-回滚到主分支" class="headerlink" title="切换/回滚到主分支"></a>切换/回滚到主分支</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>

<h2 id="服务端有更新，但你却-commit了你的代码"><a href="#服务端有更新，但你却-commit了你的代码" class="headerlink" title="服务端有更新，但你却 commit了你的代码"></a>服务端有更新，但你却 commit了你的代码</h2><ul>
<li><p>先拉取服务端代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure></li>
<li><p>提交代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure></li>
<li><p>如果你在 dev分支，此时还要拉取master的代码<br><strong>1. 先 切换到 master 分支</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>

<p><strong>2. 拉取代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<p><strong>3. 重新切换到 dev 分支</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout dev</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="查看每次提交的文件列表"><a href="#查看每次提交的文件列表" class="headerlink" title="查看每次提交的文件列表"></a>查看每次提交的文件列表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --stat | more</span><br></pre></td></tr></table></figure>

<h2 id="查看某些提交代码的变化"><a href="#查看某些提交代码的变化" class="headerlink" title="查看某些提交代码的变化"></a>查看某些提交代码的变化</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git show &lt;commit id&gt; [&lt;filename&gt;]</span><br></pre></td></tr></table></figure>
<h2 id="显示所有本地与远端分支"><a href="#显示所有本地与远端分支" class="headerlink" title="显示所有本地与远端分支"></a>显示所有本地与远端分支</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure>
<h2 id="显示所有远程分支"><a href="#显示所有远程分支" class="headerlink" title="显示所有远程分支"></a>显示所有远程分支</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure>
<h2 id="显示远端地址"><a href="#显示远端地址" class="headerlink" title="显示远端地址"></a>显示远端地址</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>
<h2 id="创建一个新分支"><a href="#创建一个新分支" class="headerlink" title="创建一个新分支"></a>创建一个新分支</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b new_branch</span><br><span class="line">git --set-upstream origin new_branch</span><br><span class="line">git push origin new_branch</span><br></pre></td></tr></table></figure>
<h2 id="远程仓库已经删除，而本地仓库还在，如果清除？"><a href="#远程仓库已经删除，而本地仓库还在，如果清除？" class="headerlink" title="远程仓库已经删除，而本地仓库还在，如果清除？"></a>远程仓库已经删除，而本地仓库还在，如果清除？</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull -p</span><br></pre></td></tr></table></figure>
<h2 id="git-diff-不显示修改的内容"><a href="#git-diff-不显示修改的内容" class="headerlink" title="git diff 不显示修改的内容"></a>git diff 不显示修改的内容</h2><p>有些情况下，通过 <code>git status</code> 能查到某些文件有变化，但使用 <code>git diff</code> 却看不到修改的内容。可以使用下面的面试查看变化。</p>
<ul>
<li>第一种方法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff --cached 文件名</span><br></pre></td></tr></table></figure></li>
<li>或者<br>先将修改的文件重命名，然后执行下面的语句<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset HEAD</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="配置更好的-git-diff-工具"><a href="#配置更好的-git-diff-工具" class="headerlink" title="配置更好的 git diff 工具"></a>配置更好的 git diff 工具</h2><p>在使用 git diff 时，常常发现有很多不方便的地方。因为git diff 默认使用 patch 方式展示代码的不同。如果想看修改后代码的上下文就比较麻烦了（比如代码 review）。</p>
<p>其实 git 已经提供了扩展功能。可经将它的默认 diff 工具修改为vimdiff。配置如下：</p>
<ul>
<li>首先打开 git config 文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~&#x2F;.gitconfig</span><br></pre></td></tr></table></figure></li>
<li>增加配置项<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[difftool]</span><br><span class="line">    prompt &#x3D; false</span><br><span class="line">[diff]</span><br><span class="line">    vimdiff</span><br><span class="line">    tool &#x3D; vimdiff</span><br><span class="line">[difftool &quot;vimdiff&quot;]</span><br><span class="line">    path &#x3D; &#x2F;usr&#x2F;bin&#x2F;vimdiff</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="打tag"><a href="#打tag" class="headerlink" title="打tag"></a>打tag</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;为git打tag, 第一次需要在前面加一个v</span><br><span class="line">git tag &quot;v1.0.0&quot;</span><br><span class="line">&#x2F;&#x2F;将tag推送到远程仓库</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure>

<h2 id="git-merge-每次都生成一次commit"><a href="#git-merge-每次都生成一次commit" class="headerlink" title="git merge 每次都生成一次commit"></a>git merge 每次都生成一次commit</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge --no-ff</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：ff表示 fast forward</p>
</blockquote>
<h2 id="切到某个tag"><a href="#切到某个tag" class="headerlink" title="切到某个tag"></a>切到某个tag</h2><p>与切到某个分支是类似的，只不过将branch 名换为 tag 名而以。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout tag_name</span><br></pre></td></tr></table></figure>

<h2 id="查看某个人的所有提交"><a href="#查看某个人的所有提交" class="headerlink" title="查看某个人的所有提交"></a>查看某个人的所有提交</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --author&#x3D;“author”</span><br></pre></td></tr></table></figure>

<h2 id="为git设置默认用户名和密码"><a href="#为git设置默认用户名和密码" class="headerlink" title="为git设置默认用户名和密码"></a>为git设置默认用户名和密码</h2><p>在使用Git 的时候，经常会遇到需要频繁输入密码的情况，每次git push 和 git pull 都要求输入用户名和密码，如果提交频繁的话就十分不方便。</p>
<p>可以使用下面的方法，只需要第一次输入用户名和密码，以后都不用再输入了。</p>
<h3 id="进入Git-配置文件"><a href="#进入Git-配置文件" class="headerlink" title="进入Git 配置文件"></a>进入Git 配置文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~&#x2F;.gitconfig</span><br></pre></td></tr></table></figure>

<h3 id="修改配置文件，添加下面这一行。"><a href="#修改配置文件，添加下面这一行。" class="headerlink" title="修改配置文件，添加下面这一行。"></a>修改配置文件，添加下面这一行。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[credential]  </span><br><span class="line">    helper &#x3D; store</span><br></pre></td></tr></table></figure>

<p>##修改已提交的commit的用户名邮箱</p>
<ol>
<li><p>第一步</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;newName&quot;</span><br><span class="line">git config --global user.email &quot;newEmail&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改已提交commit的用户名邮箱</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit --amend --author&#x3D;&quot;userName &lt;userEmail&gt;&quot;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>注意不能缺少<code>&lt; &gt;</code></strong><br><strong>此指令仅能更新最近的一次commit的用户名邮箱</strong></p>
<h2 id="git-应用-patch"><a href="#git-应用-patch" class="headerlink" title="git 应用 patch"></a>git 应用 patch</h2><ol>
<li>预览patch的结是</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git apply --stat file.patch</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>检测patch后是否有错误</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git apply --check file.patch</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>打patch</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git am --signoff &lt; a_file.patch</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>执行commit</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git  commit -m &quot;&quot;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>提交代码</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>

<h2 id="循环克隆"><a href="#循环克隆" class="headerlink" title="循环克隆"></a>循环克隆</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone --recursive https:&#x2F;&#x2F;xxx.git</span><br></pre></td></tr></table></figure>
<h2 id="给代码设置两个不同的源"><a href="#给代码设置两个不同的源" class="headerlink" title="给代码设置两个不同的源"></a>给代码设置两个不同的源</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote set-url origin https:&#x2F;&#x2F;xxx.git</span><br></pre></td></tr></table></figure>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>命令在不断更新中…</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">廖雪峰git教程</a></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客系统的实现原理与搭建</title>
    <url>/2ef51851/</url>
    <content><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/hexo/hexo-logo.png" alt=""></p>
<p>作为技术人员，定期写Blog是一个非常好的习惯。你可以通过它将自己的一些学习心得记录下来，也可以对平常的工作做一些经验总结等等。对于我来说Blog就更为重要了，因为Blog是我推广<strong>音视频技术</strong>的一块<strong>“阵地”</strong>，我需要将我写的一些<strong>音视频技术</strong>知识、视频课程中的问题解答等内容放在它上面，以便同学们交流学习。</p>
<a id="more"></a>

<p>以前，我的文章一直都在<strong>简书</strong>上发布，可最近不知为何，简书将我的账户封掉了。我经多次申诉却依然无果，既不告之那里违规，也不给我解封，真让人无语！考虑到在其它平台也可能遇到类似情况，因此决心搭建自己的博客，这样才能放心。</p>
<p>如何才能快速搭建一套比较专业的博客系统呢？通过调研，我发现开源项目<strong>hexo</strong>完全可以满足我的要求。它既可以发布文章，还支持一些常见的功能，如阅览数、文章字数统计、本地搜索等等。下面我就来详细讲述一下我是如何通过<strong>hexo</strong>搭建自已的博客系统的。</p>
<h2 id="Blog系统"><a href="#Blog系统" class="headerlink" title="Blog系统"></a>Blog系统</h2><p>在搭建Blog系统之前，我们有必要先了解一下Blog系统是干什么的，它都应该有哪些功能。</p>
<p>Blog是在2000年左右出现的，原本的称法为weblog，即网络日志。后来逐渐被人们改为 we blog，进而简称为Blog。Blog中的每一篇文章/日志就是一个页面，Blog将这些页面聚集在一起就形成了现在的形式。</p>
<p>现在大家在写Blog时已经很少直接写在页面里了，而是改用Markdown语法，这种语法非常简洁，特别适合我们平常的写作。所以现今的Blog系统最重要的一个环节就是，将Markdown语法写成的文档转化成HTML页面，然后放到Web服务器上发布出来。除此之外，Blog还要有一个管理系统可以将这些页面管理起来，如生成目录、标签，分类、搜索等等。</p>
<p>如果要我们自己实现这样一套系统还是非常麻烦的，好在已经有开源项目实现了，这就是<strong>hexo</strong>。hexo 不但实现了这些功能，还实现了很多其它的功能，如文章浏览次数、打赏、接入评论系统等等。这些功能对于我们来说都是非常有用的，然而在讲解如何搭建这些功能之前，我们先来了解一下hexo的实现原理，这样可以让我们更容易理解后面的知识。</p>
<h2 id="hexo基本原理"><a href="#hexo基本原理" class="headerlink" title="hexo基本原理"></a>hexo基本原理</h2><p>要了解hexo的实现原理，我们首先要知清楚 hexo 的目录结构，这样可以更有助于了解hexo。</p>
<p>hexo由以下几个重要文件/目录组成：</p>
<ul>
<li>_config.yml，该文件是hexo 的<code>站</code>级配置文件。所谓<strong>站</strong>级配置文件是指，对整个站点起效果的配置文件。</li>
<li>source目录，该目录存放源文件。即用户编写的博文都放在该目录下。在该目录下又有几个子目录我们来分别看一下。<ul>
<li>_post，用于存放博文，基本上每篇文章都是由Markdown语法编写的。</li>
<li>tags，存放tag 的文件。hexo中的tags是自动生成的，所以我们不用手动修改tags目录下的index.md文件，在发布时它会自动生成。</li>
<li>categories，存放<strong>分类</strong>。它与tags是类似的，也是自动生成的，所以不需要我们手工修改。</li>
<li>…</li>
</ul>
</li>
<li>themes目录，该目录用于存放主题，目前hexo中最热门的主题就是<strong>next</strong>了。最近的 next release 版本是 7.8 。</li>
<li>public目录，该目录存放hexo转出的文件，如html、css、js等。</li>
<li>scaffolds目录，它里面存放了一些<strong>“脚手架”</strong>程序，用于生成模板页面，如执行<code>hexo new &quot;title&quot;</code>时，就会生成一个Markdown文件模板。</li>
</ul>
<p>上面就是hexo中最重要的几个文件和目录了。</p>
<p>清楚之hexo目录结构之后，我们再来看看hexo的基本原理。</p>
<p>hexo最基本的功能是将Markdown程序转成HTML页面，而这个转换并不是一次完成的，要经历两步:</p>
<ul>
<li><p>第一步，将Markdown翻译成下面格式的JSON对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">article: &#123;</span><br><span class="line">  title:</span><br><span class="line">  date:</span><br><span class="line">  tags:</span><br><span class="line">  categories:</span><br><span class="line">  content:</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步，根据上面生成的JSON对象生成 HTML 页面。</p>
</li>
</ul>
<p>对于我们来说，清楚了上面hexo将Markdown转HTML页面的过程后，我们就很容易理解hexo 在执行不同命令时它都在做什么事儿了。</p>
<p>下面我们再来看看<strong>hexo</strong>的组成，它由三部分组成: <strong>hexo-cli</strong>、<strong>hexo-core</strong>以及<strong>hexo plugs</strong>。在这三部分中最核心的是hexo-core模块，它的作用就是执行上面讲的两步转换，从而生成目标文件；hexo-cli为我们供了一些非常方便的命令。当我们敲入命令时，它会根据命令调用不同的模块；hexo plugin是hexo的扩展，当hexo本身不能完成某项任务时，它允许你自己开发一个插件来完成。当然你也可以使用其它人写好的插件。</p>
<p>上以就是hexo的基本原理。</p>
<h2 id="hexo的常用命令"><a href="#hexo的常用命令" class="headerlink" title="hexo的常用命令"></a>hexo的常用命令</h2><p><strong>hexo</strong> 提供了几个常用命令，如<code>hexo clean</code>、<code>hexo g</code>、<code>hexo s</code>等等。下面我们分别看一下这几个命令的具体作用是什么：</p>
<ul>
<li>hexo clean: 删除 hexo 生成的所有文档。当我们执行这个命令后，你会发现public目录被删除了。</li>
<li>hexo g: 根据 source 目录中的文件生成html等可以发布的文件。</li>
<li>hexo s: 在本地起动 <strong>http</strong> 服务，将生成的 html  等输出文件布署到本地服务器上。 </li>
<li>hexo d: 将生成的html代码推送到 github 上</li>
</ul>
<p>这几个命令的含义都非常清晰，我就不再做其它赘述了。</p>
<h2 id="hexo发布页面"><a href="#hexo发布页面" class="headerlink" title="hexo发布页面"></a>hexo发布页面</h2><p>如上面所介绍的，我们可以使用<code>hexo d</code>命令将生成的目标文件发布出来，但在使用它之前，你需要在站节点的_config.yml文件中配置发布的方法。我们举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">- type: git #leancloud_counter_security_sync #git</span><br><span class="line">  repo: git@github.com:avdance&#x2F;avdance.github.io.git</span><br></pre></td></tr></table></figure>

<p>当我们执行<code>hexo d</code>命令时，它会调用 hexo 中的 <code>hexo-deployer-git</code> 插件。在该插件内部会启动一个进程调用<code>git</code>命令，从而将生成的html等代码上传到 github上。</p>
<p>这里可能有些同学会有疑问，为什么上传到github上就算是发布了呢？这是因为github为我们提供了免费的个人博客空间。只要你在github上创建一个<code>用户名.github.io</code>的项目，github就会自动将这个项目中的文件发布出来。</p>
<p>当然你也可以采用传输的方式，自己购买台云主机，然后在云主机上用ngnix、nodejs等搭建一个Web服务，最终将页面发布出来。</p>
<h2 id="next主题的安装与配置"><a href="#next主题的安装与配置" class="headerlink" title="next主题的安装与配置"></a>next主题的安装与配置</h2><p>hexo中有很多的主题，但其中用的最多的、最著名的就是<strong>next</strong>主题了。下面我们就来介绍一下，如何安装next主题并对其做一些简单的配置。</p>
<p>next的安装比简单了，你只需要将next源码从github上下载下来，然后放到hexo的themes目录下即可。如下面这行语句:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone --branch v7.8.0 https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next.git themes&#x2F;next</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，我们在github中搜索关键字<code>hexo-theme-next</code>时，你会发现有两个github star数特别多，这两个地址分别是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;iissnan</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;theme-next</span><br></pre></td></tr></table></figure>
<p>上面的地址是next老版本的官方地址，下面这个是新版本的官方地址。你清楚他们之间的关系就不会给你造成混乱了。</p>
<p>next下载好后，下一步就是进行配置了。在themes/next目录下也有一个_config.yml文件，它是next主题的配置文件，千万不要将它与站点的_config.yml弄混了。</p>
<p>如果你要配置next主题时，需要修改的是themes/next目录下的_config.yml文件。</p>
<p>打开该文件，找到<code>Scheme</code>关键字，你会发现next支持多种Scheme。你可以根据喜好选择你自己喜欢的Scheme，我这里选择的是<code>Gemini</code>。选择好Scheme后，我们博客的基本结构就定下来了。接下来你可以对它进行配置了。具体的配置我会在下面再做详细论述。</p>
<p>当所有的配置都修改好后，你可以执行下面的命令将博客发布出来了。</p>
<blockquote>
<ul>
<li>hexo clean</li>
<li>hexo g</li>
<li>hexo s</li>
</ul>
</blockquote>
<h2 id="高级知识"><a href="#高级知识" class="headerlink" title="高级知识"></a>高级知识</h2><p>通过上面的操作，我们就将自己的Blog搭建好了。但此时这个Blog还只是一个最基本、最简单的Blog。如果你想让你的Blog更专业的话，还要对它进行细细的打磨。</p>
<p>接下来，我们就来看看还需要对我们的Blog做哪些处理?</p>
<ul>
<li>为文章设置摘要</li>
<li>增加图片床</li>
<li>统计阅读次数</li>
<li>显示文章字个数</li>
<li>添加评论区</li>
<li>文章置顶</li>
<li>设置标签</li>
<li>设置标签云</li>
<li>增加本地搜索</li>
<li>设置关于</li>
<li>设置404</li>
<li>SEO优化</li>
</ul>
<p>下面我们就按着这个清单细细打磨我们的Blog吧。</p>
<h3 id="为文章设置摘要"><a href="#为文章设置摘要" class="headerlink" title="为文章设置摘要"></a>为文章设置摘要</h3><p>在hexo中实现摘要有两种方法，一种主是在正文中加入如下代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure>

<p>它的作用是将<code>more</code>之前的文字作为摘要。</p>
<p>需要注意的是，一般情况下摘要都在 200 字以内，所以你自己要控制好放置<code>more</code>的位置。这种方式是我最常使用的方式，感觉非常方便。</p>
<p>第二种方法是，在文章头的 <code>description</code> 域写摘要，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: xxxx</span><br><span class="line">date: xxxx-xx-xx</span><br><span class="line">...</span><br><span class="line">description: xxxxxxx...</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>这处方式的好处是，可以将文中某一段设置为摘要，或者自己单独写一段摘要。所以这种方式更灵活，也更便于做 SEO 优化。</p>
<p>以上两种方法都可以，你可以根据自己的习惯选择最合适自已的方法。</p>
<h3 id="增加图片床"><a href="#增加图片床" class="headerlink" title="增加图片床"></a>增加图片床</h3><p>我们文章发布时，一般都是通过github发布出来，但必竟github给我们每个人的资源是有限的。如果你在github上放一些特别大的文件的话，那么你博客的访问速度一定很慢，甚至会严重影响用户的体验。</p>
<p>另外不论你在哪儿发布文章，一条必须遵守的原则是，尽量避免在主站上放置特别大的文件，尤其是图片。但现实是残酷的，有写作经验的同学都知道，在文章中放一些图片不但可以让读者更容易理解的要表达的思想，而且还有美化文章的作用。</p>
<p>如何解决上述的矛盾呢？ 答案就是使用<strong>图床</strong>。所谓图床，其实就是使用云存储(像阿里云、腾讯云、七牛云)来存储图片，然后用CDN进行加速。这样可以大大优化网站的访问速度。</p>
<p>我搭建的Blog使用的就是阿里云的云加速。对于使用阿里云加速的方法我这里就不赘述了，有兴趣的小伙伴可以到阿里的官网上自行查阅使用说明。</p>
<h3 id="统计阅读次数"><a href="#统计阅读次数" class="headerlink" title="统计阅读次数"></a>统计阅读次数</h3><p>由于hexo自己没有提供数据库的功能，因此对文章访问次数的统计需要通过第三方云服务来提供支持。</p>
<p>大多数情况下，我们使用leancloud做服务统计，而且hexo中也实现了与之相关的接入代码。当然，你也可以通过云数据库来实现这个功能，至于你选择那种方案就看你自己的喜好了。</p>
<p>下面我就来介绍一下通过leancloud如何实现统计阅读次数这一功能。</p>
<p>首先，你要注册一个leancloud账户。leancloud上提供了两种用户类型，一种是developer，一种是商业用户。developer用户是免费的，但有限制。不过这种限制对于我们这种访问量很少的Blog来说是无所谓的。</p>
<p>注册好用户后，我们需要在leancloud上创建一个<strong>class</strong>，这里的<code>class</code>类似于关系型数据库中的表。class的名子是固定的，必须是<code>Counter</code>，只有这样 hexo 才能将数据保存到leancloud上，也才能真正的实现阅读量的统计，</p>
<p>leancloud class创建好后，我们就要对hexo进行配置了。实际上，真正进行统计的模块是next。如果你使用的是其它主题的话，那就要找对应的统计方法。</p>
<p>对于next来说，它的V5版本与V7版本在使用leancloud的方法是不一样的。据说V5版本存在统计漏洞，很容易被黑客攻击，因此改为现然V7的方式了。</p>
<p>不过经我测试，V5的方式配置起来比较简单，V7的方式我没有验证通过。也就是说，通过V7的方法无法进行阅读量统计。我想一定是我那里没有配置对，希望有这方面经验的同学可以分享一下。</p>
<p>下面我们来看看如何修改next的配置使其与leancloud相联(这里讲的是V5的方法)。打开themes/next目录下的_config.yml文件，找到<code>leadcloud_visitors</code>关键字，修改其配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">leancloud\_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  app\_id: &lt;your app id&gt;</span><br><span class="line">  app\_key: &lt;your app key&gt;</span><br></pre></td></tr></table></figure>

<p>这三个字段的含义如下，<code>enable</code>表示是否开启leadcloud_visitors功能，所以这个选项我们要修改为true；<code>app_id</code>是你注册leancloud时分配给你的ID; <code>app_key</code>也是你注册leancloud时分配的。只要我们将上面的参数配置好后，当你再浏览你的文章时，就会发现访问次数发生变化了。</p>
<h3 id="统计文章字数"><a href="#统计文章字数" class="headerlink" title="统计文章字数"></a>统计文章字数</h3><p>hexo本身并不支持文章字数的统计，因此要想实现这一功能我们需要安装一个插件，即<code>hexo-symbols-count-time</code>。在以前，大家都使用wordcount插件，但到了next V6之后<code>hexo-symbols-count-time</code>逐渐替代了<code>wordcount</code>。</p>
<p>下面我们来看一下如何使用<code>hexo-symbols-count-time</code>插件。使用它之前我们需要先将其安装好，执行下面的命令即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>

<p>hexo-symbols-count-time插件安装完成后，我们要修改两个配置文件: hexo 中的_config.yml文件和next主题中的_config.yml文件。</p>
<p>第一步，修改hexo中的_config.xml的<code>symbols\_count\_time</code>项，修改配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置博客单词统计</span><br><span class="line">symbols_count_time:</span><br><span class="line">  # 文章字数统计</span><br><span class="line">  symbols: true</span><br><span class="line">  # 文章阅读时间统计</span><br><span class="line">  time: true</span><br><span class="line">  # 站点总字数统计</span><br><span class="line">  total_symbols: false</span><br><span class="line">  # 站点总阅读时间统计</span><br><span class="line">  total_time: false</span><br><span class="line">  exclude_codeblock: false</span><br></pre></td></tr></table></figure>
<p>第二步，修改 themes/next 目录下的 _config.yml 文件，仍然找 <code>symbols_count_time</code> 项，配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置博客单词统计</span><br><span class="line">symbols_count_time:</span><br><span class="line">  # 是否另起一行（true的话不和发表时间等同一行）</span><br><span class="line">  separated_meta: true</span><br><span class="line">  # 首页文章统计数量前是否显示文字描述（本文字数、阅读时长）</span><br><span class="line">  item_text_post: true</span><br><span class="line">  # 页面底部统计数量前是否显示文字描述（站点总字数、站点阅读时长）</span><br><span class="line">  item_text_total: false</span><br><span class="line">  # 平均字长</span><br><span class="line">  awl: 4</span><br><span class="line">  # 每分钟阅读字数</span><br><span class="line">  wpm: 275</span><br></pre></td></tr></table></figure>

<p>上面的配置修改后，文章字数统计功能就算配置好了，现在只要你重新生成静态页面，然后发布出来就可以看到效果了。</p>
<h3 id="如何添加评论系统"><a href="#如何添加评论系统" class="headerlink" title="如何添加评论系统"></a>如何添加评论系统</h3><p>hexo还可以接入评论系统，而且可以接入多种评论系统。在从多的评论系统中，Valine是其中一款比较出众的评论系统。</p>
<p>hexo接入valine非常容易，就像之前介绍的接入阅读统计系统一样，它也需要在leancloud系统上创建一个类，即 <code>Comment</code>类，用于保存用户的评论。</p>
<p>因此我们在接入用户评论系统时，需要经过以下几步:</p>
<ul>
<li>第一步，在leancloud上创建comment类；</li>
<li>第二步，修改 themes/next 目录下的_config.yml 文件，做如下配置：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">valine:</span><br><span class="line">  enable: true #是否接入valine 系统</span><br><span class="line">  appid:  #LeanClound获得的appid</span><br><span class="line">  appkey: #LeanClound获得的appkey</span><br><span class="line">  notify: false # 邮件提醒</span><br><span class="line">  verify: false # Verification code</span><br><span class="line">  placeholder: 欢迎畅所欲言 # 占位字符串 </span><br><span class="line">  avatar: mm #默认头像设置</span><br><span class="line">  guest_info: nick #评论区的title </span><br><span class="line">  pageSize: 10 # Pagination size</span><br><span class="line">  language: zh-cn # Language, available values: en, zh-cn # 语言，设为zh-cn</span><br><span class="line">  # 是否开启当前文章阅读量统计</span><br><span class="line">  visitor: false #这个要设置为false，以免与 leancloud_visitors 突冲 </span><br><span class="line">  comment_count: true #是否在主页里也显示评论个数，为false是不显示</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>通过上面的设置后，你就可以在文章中看到评论区了。</p>
<p>实际上，我们还可以真对每一篇文章单独设置是否显示评论区，如何做呢？</p>
<p>只要你在想要关闭评论区的文章头加上<code>comments: false</code>这句即可。具体例子如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">date: 2019-07-18 15:16:50</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure>

<p>到此为止，我们就将评论系统接入到我们的博客中了。</p>
<h3 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h3><p>文章写好后，有一些我们认为特别好的文章希望置顶，这该如何做呢？</p>
<p>hexo默认的方式是按时间顺序排放文章的，也就是最后写完的文章会放在最一个。如果要打破这个规则，我们就需要给它建立一个新规则。</p>
<p>应该定义个什么样的规则呢？实际上已经有人帮我们想好了，就是给文章做个编号，有编号的优先排序，并且按照编号进行排序；而没有编号的再按时间排序，这样就解决了我们想将文章顶置的需求。</p>
<p>更好的消息时，现在hexo已经有了这样一个新的排序插件叫<code>hexo-generator-index-pin-top</code>，我们只需要用它替换原来老的排序插件即可。具体操作步骤如下：</p>
<ul>
<li>先将老的排序插件删除掉<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn remove hexo-generator-index</span><br></pre></td></tr></table></figure></li>
<li>按装新插件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add hexo-generator-index-pin-top</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>光安装好插件还不行，我们要想让文章置顶还要修改文章的title域，在title域中增加一个<strong>top</strong> 域，这样这篇文章就会被置顶了。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----</span><br><span class="line">title: xxxx</span><br><span class="line">date: xxxx-xx-xx</span><br><span class="line">...</span><br><span class="line">top: 1</span><br><span class="line">...</span><br><span class="line">----</span><br></pre></td></tr></table></figure>
<p>经上面这样设置后，我们想置顶的文章就会跑到主页的顶部，马上去试试看吧。</p>
<p>不过这里还有一个小问题，文章是置顶了，但对于用户来说却感受不到。从用户的角度看，如果不仔细观察的话还真不会发现前面几篇文章是置顶文章。有没有办法可以将置顶文章做个标识呢？</p>
<p>当然有办法，不过我们需要修改一点next主题的代码了。我们进行到<code>next/layout/_macro</code>目录下，打开post.swig文件，找到 <code>&lt;div class=&quot;post-meta&quot;&gt;</code> 标记，然后在它下面添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">  &lt;i class&#x3D;&quot;fa fa-thumb-tack&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  &lt;font color&#x3D;7D26CD&gt;置顶&lt;&#x2F;font&gt;</span><br><span class="line">  &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>经过这样的设置后，我就可以在博客主页中看到前面被置顶的文章被打上标记了。打开<a href="https://blog.avdancedu.com">我的博客</a>你应该就可以看到真实的效果了。</p>
<h3 id="如何开启打赏功能"><a href="#如何开启打赏功能" class="headerlink" title="如何开启打赏功能"></a>如何开启打赏功能</h3><p>hexo 中 next 主题开启打赏功能非常简单，只要稍微配置一下就可以了。在里需要普及一些支付的基本知识，对于正常的支付来说，当用户点击打赏时，可以选择要打赏的金额，之后应该调用腾讯或阿里的支付接口，最终完成支付。但对于hexo来说，显然它做不了这么复杂的交互逻辑，那它是如何做的呢？</p>
<p>实际上，它只是将微信/支付完的收款二维码放到网页上面来实现打赏功能的。具体的步骤如下：</p>
<ul>
<li>生成收款二维码，打开微信/支付宝，将收款二维码保存成图片。</li>
<li>编辑next主题下面的_config.xmy文件，将该文件中的<code>reward\_settings</code>打开即可。具体配置如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Reward (Donate)</span><br><span class="line">reward\_settings:</span><br><span class="line">  enable: true</span><br><span class="line">  animation: true</span><br><span class="line">  comment: 只想买包辣条</span><br><span class="line"></span><br><span class="line">reward:</span><br><span class="line">  wechatpay: &#x2F;images&#x2F;wechatpay.png   #微信收款码</span><br><span class="line">  alipay: &#x2F;images&#x2F;alipay.png   #支付宝收款码</span><br><span class="line">  #bitcoin: &#x2F;images&#x2F;bitcoin.png</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>通过上面的设置，我们就将hexo的打赏功能设置好了。</p>
<h3 id="添加标签和分类"><a href="#添加标签和分类" class="headerlink" title="添加标签和分类"></a>添加标签和分类</h3><p>在hexo中给文章添加标签并给文章分类很容易，只要在文章头里加 <code>tags</code> 和<code>categories</code>域即可。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: xxx    &#x2F;&#x2F;在此处添加你的标题。</span><br><span class="line">date: 2016-10-07 13:38:49   &#x2F;&#x2F;在此处输入编辑这篇文章的时间。</span><br><span class="line">tags: [aaa, bbb, ccc]    &#x2F;&#x2F;在此处输入这篇文章的标签。</span><br><span class="line">categories: xxx, yyy    &#x2F;&#x2F;在此处输入这篇文章的分类。</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>通过上面的例子我们可以看到，可以给一篇文章增加多个tag，也可以将文章划分到多个不同的类别中去。</p>
<p>除了在文章中我们可以给文章打多个标签和分类外，我们还应该将hexo next中的标签/分类入口打开，这样可以方便用户查看博客中所有的标签和分类，从而可以快速找到它们感兴趣的文章。</p>
<p>具体做法如下，进入到 themes/next 目录，打开_config.yml 文件，找到<code>menu</code>项，配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">home: &#x2F;|| home</span><br><span class="line">tags: &#x2F;tags&#x2F;|| tags</span><br><span class="line">categories: &#x2F;categories&#x2F;|| th</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>通过上面的配置，我们就将<strong>标签</strong>和<strong>分类</strong>入口打开了。不过光打开入口还不行，我们还要创建 tag 和 categories 目录和文章，执行下面的命令即可完成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page tags&#x2F;categories</span><br></pre></td></tr></table></figure>

<p>执行完上述命令后，我们就可以在source目录下看到tags和categories目录了。</p>
<p>此时，我们重新执行<code>hexo g</code>生成页面，你就可以看到我们在文章中打的标签和分类被写到各目录的index文件中了。</p>
<h3 id="如何设置标签云"><a href="#如何设置标签云" class="headerlink" title="如何设置标签云"></a>如何设置标签云</h3><p>当我在浏览其它人使用hexo搭建的博客时，发现它的标签特别炫，有一些标签用的少就会是很小的字体，而一些经常用的标签则是很大的字体。经了解才知道这就是标签云。可以通过<code>hexo-tag-cloud</code>插件来实现。该插件除了可以实现我上面所说的功能外，还能在你的博客的左边或右边出现标签滚动的效果。</p>
<p>下面我们就来看看该如何设置标签云吧。第一步自然不必多说，一定是安装插件，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add hexo-tag-cloud --save</span><br></pre></td></tr></table></figure>
<p>插件安装好后，在站点的_config.yml文件中添加如下配置信息:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># hexo-tag-cloud 标签云 | see https:&#x2F;&#x2F;github.com&#x2F;MikeCoder&#x2F;hexo-tag-cloud</span><br><span class="line">tag_cloud:</span><br><span class="line">  textFont: Trebuchet MS, Helvetica # 字体</span><br><span class="line">  textColor: &#39;#555&#39; # 字体颜色</span><br><span class="line">  textHeight: 25 # 字体高度</span><br><span class="line">  outlineColor: &#39;#E2E1D1&#39; # 字体背景色</span><br><span class="line">  maxSpeed: 0.1 # 标签云最大移动速度</span><br></pre></td></tr></table></figure>
<p>上面的配置信息是用于控制标签云显示的效果的。其中，<code>maxSpeed</code>我们要介绍一下，该值为 1 时运转的速度最快，该值为0是基本处理不动的状态。当然如果你不喜欢标签滚动的效果，则可以不设置这些信息。</p>
<p>对于要达到滚动效果的标签云来说，光有这些信息还不够，还要修改一点代码。打开source/layout/_macro/sidevar.swig文件，在文中搜索找到<code>sidebar-inner</code> 的 div 元素，在其下面加入下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if site.tags.length &gt; 1 %&#125;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; charset&#x3D;&quot;utf-8&quot; src&#x3D;&quot;&#123;&#123; url_for(&#39;&#x2F;js&#x2F;tagcloud.js&#39;) &#125;&#125;&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; charset&#x3D;&quot;utf-8&quot; src&#x3D;&quot;&#123;&#123; url_for(&#39;&#x2F;js&#x2F;tagcanvas.js&#39;) &#125;&#125;&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;widget-wrap&quot;&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;myCanvasContainer&quot; class&#x3D;&quot;widget tagcloud&quot;&gt;</span><br><span class="line">    &lt;canvas width&#x3D;&quot;220&quot; height&#x3D;&quot;250&quot; id&#x3D;&quot;resCanvas&quot; style&#x3D;&quot;width&#x3D;100%&quot;&gt;</span><br><span class="line">        &#123;&#123; list_tags() &#125;&#125;</span><br><span class="line">    &lt;&#x2F;canvas&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的配置我们就将标签云设置好了。</p>
<h3 id="如何添加本地搜索"><a href="#如何添加本地搜索" class="headerlink" title="如何添加本地搜索"></a>如何添加本地搜索</h3><p>在hexo中支持很多种搜索，这里我就不一一介绍了，我只用到了其中的本地搜索，并感觉hexo本地搜索的表现还是不错的，所以我也推荐大家用本地搜索。hexo本地搜索的原理很简单，就是通过hexo-generator-search插件在本地生成一个search.xml/json文件，通过这个文件实现搜索功能。</p>
<p>为hexo添中本地搜索功能的步骤很简单，第一步是按装插件，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-search</span><br><span class="line">npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure>

<p>然后修改 hexo 下面的配置文件_config.yml，在其中增加下面配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>

<p>接下来我们把本地搜索入口打开，打开next/_config.yml文件，找到<code>local\_search</code>选项，将该选项设置为true就好了。具体设置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local\_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # if auto, trigger search by changing input</span><br><span class="line">  # if manual, trigger search by pressing enter key or search button</span><br><span class="line">  trigger: auto</span><br><span class="line">  # show top n results per article, show all results by setting to -1</span><br><span class="line">  top\_n\_per\_article: 1</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>上面都配置好后，使用hexo命令重新生成代码并重新进行布署，这样我们就可以看到搜索功能的效果了。</p>
<h3 id="设置关于"><a href="#设置关于" class="headerlink" title="设置关于"></a>设置关于</h3><p>hexo上设置关于与设置标签是类似的，首先执行下面的命令生成关于目录和源码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;about&quot;</span><br></pre></td></tr></table></figure>
<p>该命令执行后，你就可以在source/ 目录下面看到about目录了。然后向 about 目录中的index.md 写入关于的信息就好了。</p>
<p>除此之外，我们还应该像创建标签一样在 themes/next 目录下_config.yml文件中将 about 的入口打开。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">home: &#x2F;|| home</span><br><span class="line">tags: &#x2F;tags&#x2F;|| tags</span><br><span class="line">...</span><br><span class="line">about: &#x2F;about&#x2F;|| about</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这样我们就将关于页面加载好了。</p>
<h3 id="设置404"><a href="#设置404" class="headerlink" title="设置404"></a>设置404</h3><p>设置 404 与设置关于是类似的，也是首先执行 <code>hexo new page &#39;404&#39;</code>命令生成对应的目录和文件，之后是编写404页面。在编写 404 页面时有一点需要注意，就是在404页面的头部要加<code>permalink</code>关键字，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">...</span><br><span class="line">permalink: &#x2F;404</span><br><span class="line">...</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>这样当用户访问非发布的页面时，hexo会始终定位到 404 页面上。</p>
<h3 id="将文章名修改为数字码"><a href="#将文章名修改为数字码" class="headerlink" title="将文章名修改为数字码"></a>将文章名修改为数字码</h3><p>当我在hexo发布文件时发现一个问题，就是hexo生成的文章名如果有中文的话会被转码，这样就变成了一个特别长的字符串，让人看起来非常别拗。能不能将它修改为像简书一样的字符串呢？hexo同样提供了这样一个插件，叫<code>hexo-abbrlink</code>。我们只要装上这个插件再修改一下配置文件就OK了。下面我们就来偿试下吧。</p>
<p>首先还是安装插件，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add hexo-abbrlink --save</span><br></pre></td></tr></table></figure>
<p>插件安装好后，我们再来修改一下配置文件，打开站目录下的_config.yml文件，找到<code>permalink</code>并将它的值修改为 <code>post/:abbrlink/</code>，之后添加abbrlink属性。具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">permalink: posts&#x2F;:abbrlink&#x2F;</span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32</span><br><span class="line">  rep: hex</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>全部配置好后我们就可以重新生成静态文件了。当我们将静态文件发布出来后，你再访问文章时你就会发现以前一长号字符的地址现在已经变的非常短了。</p>
<h3 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h3><p>涉及的知识比较多，待进一步完成！</p>

 <!-- 引入 flv.js 库 -->
 <!--
 <video id="flv_file" controls autoplay>
          You Browser doesn't support video tag
 </video>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/flv.js/1.5.0/flv.min.js"></script>
 <script>
            //通过 JavaScript 脚本创建 FLV Player
            if (flvjs.isSupported()) {
                var videoElement = document.getElementById('flv_file');
                var flvPlayer = flvjs.createPlayer({
                    type: 'flv',
                    url: 'https://avdancevod.oss-cn-beijing.aliyuncs.com/vodio/killer.flv'
                });
                flvPlayer.attachMediaElement(videoElement);
                flvPlayer.load();
                flvPlayer.play();
            }
 </script>
 -->


<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文是我自己搭建博客的总结文章。该文记录的是从我对hexo有所了解，到逐步深入，再到一步一步搭建出我们自己比较满意的博客的过程。在整个过程中，我感触最多的是我在搭建过程中对博客技术的思考以及对技术的重新认知，这两个方面是我对hexo特别兴奋点。也正因于此，才使我写出这一万多字的文章。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>Blog</tag>
        <tag>博客</tag>
        <tag>标签</tag>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频系统入门常见问题</title>
    <url>/631d466a/</url>
    <content><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/av_base/question.jpg" alt=""></p>
<p>同学们在学习《音视频课小白系统入门》这门课的过程中，经常遇到一些问题，如Mac系统下为什么无法编译ffmpeg? Xcode编译课程中的程序为什么不成功? 为什么我从设备中读的数据很小?等等不足而一。</p>
<p>实际上，大部分同学提出的问题都是重复的。因此，我将一些最常见的问题整理出了答案放在这里，同学们可以根据自己的情况去查找相应的解决办法，以免我个人原因不能及时回答问题时，给大家的学习造成麻烦和不便。</p>
<a id="more"></a>

<h2 id="Q-在-Mac-10-15-3-系统下编译-ffmpeg-成功后，在运行-ffmpeg-命令时出现crash"><a href="#Q-在-Mac-10-15-3-系统下编译-ffmpeg-成功后，在运行-ffmpeg-命令时出现crash" class="headerlink" title="Q: 在 Mac 10.15.3 系统下编译 ffmpeg 成功后，在运行 ffmpeg 命令时出现crash."></a>Q: 在 Mac 10.15.3 系统下编译 ffmpeg 成功后，在运行 ffmpeg 命令时出现crash.</h2><p>A: 重新编译ffmpeg，在执行 ./configure 时增加 –extra-cflags=”fno-static-check” 选项，注意该选项一定要放在前面，否则编译有问题。</p>
<h2 id="Q-在Mac下添加-–extra-cflags-”fno-static-check”-选项仍然-crash"><a href="#Q-在Mac下添加-–extra-cflags-”fno-static-check”-选项仍然-crash" class="headerlink" title="Q: 在Mac下添加 –extra-cflags=”fno-static-check” 选项仍然 crash"></a>Q: 在Mac下添加 –extra-cflags=”fno-static-check” 选项仍然 crash</h2><p>A: 编译时保持尽量少的参数，应该是与其它一些参数有突冲。</p>
<h2 id="Q-无论通过何种方式编译出的ffmpeg都会引发crash，如何解决？"><a href="#Q-无论通过何种方式编译出的ffmpeg都会引发crash，如何解决？" class="headerlink" title="Q: 无论通过何种方式编译出的ffmpeg都会引发crash，如何解决？"></a>Q: 无论通过何种方式编译出的ffmpeg都会引发crash，如何解决？</h2><p>A: 那就只能用命令的方式安装ffmpeg了，执行 <code>brew install ffmpeg</code>即可。</p>
<h2 id="Q-在Mac下，通过命令方式安装的ffmpeg没有带fdk-aac库怎么办"><a href="#Q-在Mac下，通过命令方式安装的ffmpeg没有带fdk-aac库怎么办" class="headerlink" title="Q: 在Mac下，通过命令方式安装的ffmpeg没有带fdk-aac库怎么办?"></a>Q: 在Mac下，通过命令方式安装的ffmpeg没有带fdk-aac库怎么办?</h2><p>A: 以命令方式安装带 fdk-aac 的ffmpeg需要按下面的步骤执行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0. brew unstall ffmpeg</span><br><span class="line">1. brew tap homebrew-ffmpeg&#x2F;ffmpeg</span><br><span class="line">2. brew install homebrew-ffmpeg&#x2F;ffmpeg&#x2F;ffmpeg --with-fdk-aac</span><br></pre></td></tr></table></figure>

<p>注意，安装时如果报<code>ERROR: libsnappy not found</code> 错误，则你需要到<code>https://github.com/google/snappy</code>下载源码，并按照项目的说明编译并安装snappy库。</p>
<p>安装好snappy库后，重新执行<code>brew install homebrew-ffmpeg/ffmpeg/ffmpeg --with-fdk-aac</code>命令。</p>
<h2 id="Q-在Mac下通过命令方式安装ffmpeg库时，如何能带上其它第三方库呢？如x264"><a href="#Q-在Mac下通过命令方式安装ffmpeg库时，如何能带上其它第三方库呢？如x264" class="headerlink" title="Q: 在Mac下通过命令方式安装ffmpeg库时，如何能带上其它第三方库呢？如x264"></a>Q: 在Mac下通过命令方式安装ffmpeg库时，如何能带上其它第三方库呢？如x264</h2><p>A: 与上面安装ffmpeg带fdk-aac库的命令是类似的，命令格式为: <code>brew install ffmpeg --with-xxxx</code>，添加某个库的具体参数可以通过<code>homebrew-ffmpeg/ffmpeg/ffmpeg</code> 来查找。</p>
<h2 id="Q-Xcode-编译课程中的程序成功，但执行失败，报的错误是没有权限该如何解决？"><a href="#Q-Xcode-编译课程中的程序成功，但执行失败，报的错误是没有权限该如何解决？" class="headerlink" title="Q: Xcode 编译课程中的程序成功，但执行失败，报的错误是没有权限该如何解决？"></a>Q: Xcode 编译课程中的程序成功，但执行失败，报的错误是没有权限该如何解决？</h2><p>A:<br><img data-src="https://cdn.avdancedu.com/image/article/av_base/nopriv.jpg" alt=""></p>
<p>如果是上面这种错误信息，解决办法是: 在编译课程中的例子时，先将将沙盒关闭掉，在info.list中增加访问mic phone 访问权限。具体操作如下图所示:</p>
<p><img data-src="https://cdn.avdancedu.com/image/article/av_base/info.jpg" alt=""></p>
<h2 id="Q-info-plist加了权限仍然报没有权限怎么解决？"><a href="#Q-info-plist加了权限仍然报没有权限怎么解决？" class="headerlink" title="Q: info.plist加了权限仍然报没有权限怎么解决？"></a>Q: info.plist加了权限仍然报没有权限怎么解决？</h2><p>A: 按下图操作试试<br><img data-src="https://cdn.avdancedu.com/image/article/av_base/priv2.jpg" alt=""></p>
<h2 id="Q-引入ffmpeg库后，报libavformat-xxx-dylib-未签名，错误信息类似”code-signature…not-valid”"><a href="#Q-引入ffmpeg库后，报libavformat-xxx-dylib-未签名，错误信息类似”code-signature…not-valid”" class="headerlink" title="Q: 引入ffmpeg库后，报libavformat.xxx.dylib 未签名，错误信息类似”code signature…not valid”"></a>Q: 引入ffmpeg库后，报libavformat.xxx.dylib 未签名，错误信息类似”code signature…not valid”</h2><p>A:<br><img data-src="https://cdn.avdancedu.com/image/article/av_base/unsigned.jpg" alt=""><br>如果像上图所展示的一样，则按下面步骤操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 打开 Mac 中的 keychain Access.app, 选择“我的证书”</span><br><span class="line">2. 执行 codesign -f -s &quot;证书名&quot; xxx.dylib</span><br><span class="line">3. 为了避免逐个签名，可以进行批量操作 codesign -f -s &quot;证书名&quot; &#x2F;usr&#x2F;local&#x2F;ffmpeg&#x2F;lib&#x2F;*.dylib</span><br></pre></td></tr></table></figure>

<h2 id="Q-ffmpeg-执行时提示没有权限执行ffmpeg"><a href="#Q-ffmpeg-执行时提示没有权限执行ffmpeg" class="headerlink" title="Q: ffmpeg 执行时提示没有权限执行ffmpeg"></a>Q: ffmpeg 执行时提示没有权限执行ffmpeg</h2><p>A: 将目录切换到你自己的用户目录下再执行ffmpeg试试。</p>
<h2 id="Q-在Linux虚似机中每次获取的音频数据很小，只有64个字节，如果进行重采样？"><a href="#Q-在Linux虚似机中每次获取的音频数据很小，只有64个字节，如果进行重采样？" class="headerlink" title="Q: 在Linux虚似机中每次获取的音频数据很小，只有64个字节，如果进行重采样？"></a>Q: 在Linux虚似机中每次获取的音频数据很小，只有64个字节，如果进行重采样？</h2><p>A: ffmpeg中最低采样个数为32个，所以只有 64 字节数据时，是无进行重采样的。解决办法是将数据放到一个缓冲区中，积攒到一定大小后，再进行重采样。</p>
<h2 id="Q-在从设备采体音频数据时，返回错误-35"><a href="#Q-在从设备采体音频数据时，返回错误-35" class="headerlink" title="Q: 在从设备采体音频数据时，返回错误 -35"></a>Q: 在从设备采体音频数据时，返回错误 -35</h2><p>A: 说明你的设备现在暂时还没准备好，此时你应该等待它几秒，之后就可以正常读数据了。例如：<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while(re&#x3D;av_read_frame(...))&#123;</span><br><span class="line">   if(ret&#x3D;&#x3D;-35) &#123;</span><br><span class="line">       sleep(1);</span><br><span class="line">       continue;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Q-在编码时，编码器返回-35-错误"><a href="#Q-在编码时，编码器返回-35-错误" class="headerlink" title="Q: 在编码时，编码器返回 -35 错误"></a>Q: 在编码时，编码器返回 -35 错误</h2><p>A: 此时说明编码器没有准备好，像上面的一样需要等待一会儿。</p>
<h2 id="Q-采集到的音频数据编码-AAC-时，报无法找到libfdk-aac库"><a href="#Q-采集到的音频数据编码-AAC-时，报无法找到libfdk-aac库" class="headerlink" title="Q: 采集到的音频数据编码 AAC 时，报无法找到libfdk-aac库"></a>Q: 采集到的音频数据编码 AAC 时，报无法找到libfdk-aac库</h2><p>A: 如果是通过命令安装的ffmepg，则上面已经给了答案。下面的方案是通过源码编译出带fdk-aac的ffmeg。具体步骤如下： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 安装好 fdk-aac库</span><br><span class="line">2. 重新在ffmpeg源码目录下执行.&#x2F;configure 并增加--enable-libfdk-aac 参数</span><br><span class="line">3. make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<h2 id="Q-在Linux中何采集音频数据"><a href="#Q-在Linux中何采集音频数据" class="headerlink" title="Q: 在Linux中何采集音频数据"></a>Q: 在Linux中何采集音频数据</h2><p>A: ffmpeg -f alsa -i hw:0,0 xxx.wav</p>
<h2 id="Q-在-Linux-中找不到-alsa-设备"><a href="#Q-在-Linux-中找不到-alsa-设备" class="headerlink" title="Q: 在 Linux 中找不到 alsa 设备"></a>Q: 在 Linux 中找不到 alsa 设备</h2><p>A：可以通过 arecord -l 查看你linux系统下有哪些音频设备。如果没有alsa, 可以使用  oss.</p>
<h2 id="Q-编译ffmpeg-时-filter-编译不过"><a href="#Q-编译ffmpeg-时-filter-编译不过" class="headerlink" title="Q: 编译ffmpeg 时 filter 编译不过"></a>Q: 编译ffmpeg 时 filter 编译不过</h2><p>A：选择使用 libstdc++ 库试试</p>
<h2 id="Q-Windows下编译ffmpeg"><a href="#Q-Windows下编译ffmpeg" class="headerlink" title="Q: Windows下编译ffmpeg"></a>Q: Windows下编译ffmpeg</h2><p>A:  <a href="https://trac.ffmpeg.org/wiki/CompilationGuide/MinGW" target="_blank" rel="noopener">https://trac.ffmpeg.org/wiki/CompilationGuide/MinGW</a></p>
<h2 id="Q-AAC-编码为-AAC-HE-V2-时，声音与原始声音不一样"><a href="#Q-AAC-编码为-AAC-HE-V2-时，声音与原始声音不一样" class="headerlink" title="Q: AAC 编码为 AAC_HE_V2 时，声音与原始声音不一样"></a>Q: AAC 编码为 AAC_HE_V2 时，声音与原始声音不一样</h2><p>A：这是因为老师用的 AAC 版本比较老，老版本的 AAC 与新版本的 AAC 可能有一些差异，这个我会后面查找一下原因。大家测试时可以将profile修改为 AAC HE 或 AAC LC，这样就可以正常编码出 AAC 数据了。</p>
<h2 id="Q-库已经安装好了，但仍报找不到它的错误？"><a href="#Q-库已经安装好了，但仍报找不到它的错误？" class="headerlink" title="Q: 库已经安装好了，但仍报找不到它的错误？"></a>Q: 库已经安装好了，但仍报找不到它的错误？</h2><p>A：首先确认是否已经将 <code>pkg-config</code>工具安装好了。可以执行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pkg-config</span><br></pre></td></tr></table></figure>
<p>如果提示没有安装，则先将该工具安装好，安装命令如下：</p>
<ul>
<li>ubuntu  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt intall pkg-config</span><br></pre></td></tr></table></figure></li>
<li>mac  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install pkg-config</span><br></pre></td></tr></table></figure></li>
<li>cygwin  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-cyg install pkg-config</span><br></pre></td></tr></table></figure></li>
<li>centos  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install pkg-config</span><br></pre></td></tr></table></figure>
安装完该工具后仍然报错？那再按照具体的错误看下面的解决方案吧。</li>
</ul>
<h2 id="Q-libx264库找不到（-ERROR-libx264-not-found-）"><a href="#Q-libx264库找不到（-ERROR-libx264-not-found-）" class="headerlink" title="Q: libx264库找不到（[ERROR: libx264 not found]）"></a>Q: libx264库找不到（[ERROR: libx264 not found]）</h2><p>A:<br>该问题可能由下面三个方面的问题引起。</p>
<ul>
<li>libx264库没有安装。对于这种情况有两种解决办法:<ul>
<li>其一，是通过平台的安装工作进行安装，如 apt/brew/yum install x264。（注：在Linux下应该安装 libx264-dev）。</li>
<li>其二，是通过源码安装，步骤如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. wget https:&#x2F;&#x2F;code.videolan.org&#x2F;videolan&#x2F;x264&#x2F;-&#x2F;archive&#x2F;master&#x2F;x264-master.tar.bz2</span><br><span class="line">2. bunzip2 last_x264.tar.bz2</span><br><span class="line">3. tar -vxf last_x264.tar</span><br><span class="line">4. .&#x2F;configure --enable-static --enable-shared --disable-asm --disable-avs</span><br><span class="line">5. make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>通过 pkg-config 命令无法找到。对于这类问题，我们可以使用下面的命 <code>pkg-config --cflags --lib libx264</code>看是否可以找到 libx264，如果找不到，就说明确实是这个问题。解决的办法是设置环境变量。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PKG_CONFIG_PATH&#x3D;$PKG_CONFIG_PATH:&#x2F;xxx&#x2F;xxx&#x2F;lib&#x2F;pkgconfig</span><br></pre></td></tr></table></figure>
其中 <code>xxx</code> 由你的实际路径代替。</li>
</ul>
<blockquote>
<p>注，有可能你的系统中并没有装 pkg-config工具，可以使用 brew/apt/yum install pkg-config进行安装。</p>
</blockquote>
<ul>
<li>无法链接上libx264, 这是由于通过环境变量 LD_LIBRARY_PATH 无法定位到 libx264库。解决的办法也很简单，与上面类似，可以通过设置环境变量来解决该问题。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export LD_LIBRARY_PATH&#x3D;$LIB_LIBRARY_PATH:&#x2F;xxx&#x2F;xxx&#x2F;lib</span><br></pre></td></tr></table></figure>
其中，<code>xxx</code>由你的实际路径代替。</li>
</ul>
<p>当然，你也可以将环境变量设置在脚本里，这样就不用每次都写export命令了。只需要将上面的两条语句加入到 ~/.bashrc / 或~/.bash_profile 文件里，然后在控制台执行 <code>source ~/.bashrc</code> 或 <code>source ~/.bash_profile</code>即可。</p>
<h2 id="Q-通过-avcodec-find-encoder-by-name-无法找到编码器"><a href="#Q-通过-avcodec-find-encoder-by-name-无法找到编码器" class="headerlink" title="Q: 通过 avcodec_find_encoder_by_name() 无法找到编码器"></a>Q: 通过 avcodec_find_encoder_by_name() 无法找到编码器</h2><p>A：通过以下步骤进行解决</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0. 你使用的ffmpeg必须是经过源码编译的</span><br><span class="line">1. 你在编译 ffmpeg 时，执行.&#x2F;configure时是否将此编码器模块添加到 ffmpeg中了？以 fdk_aac 为例，在执行 .&#x2F;configure …时你应该加上 --enable-libfdk-aac 选项。</span><br><span class="line">2. 如果通过源码编译ffmpeg时有报错，请根据错误信息查看本文档的相应处理方法</span><br><span class="line">3. 确保 pkg-config 命令查询到的是你通过源码编译的ffmpeg库</span><br></pre></td></tr></table></figure>

<h2 id="Q-编译不出ffplay"><a href="#Q-编译不出ffplay" class="headerlink" title="Q: 编译不出ffplay"></a>Q: 编译不出ffplay</h2><p>A：引起该问题有以下几方面的原因：</p>
<ul>
<li>所使用的操作系统没有安装图形库。如有的同学在阿里的云服务器上想安装ffplay是肯定不行的。</li>
<li>没有安装 SDL2 库。解决办法是通过 brew/apt/yum install sdl2 即可 或 通过 SDL2 源码安装。<strong>安装完成后，要重新进行到 ffmpeg目录下，执行 ./configure…这指命令。</strong></li>
<li>有的同学编译ffmpeg时，在ffmpeg目录执行./configure …时没有添加 –enable-sdl2 选项也会导致无法编译出 ffplay</li>
<li>SDL2与最新的Mac系统 mojave不兼容。解决办法：<ul>
<li>方法一<ul>
<li>从 <a href="https://www.libsdl.org/tmp/release/SDL2-2.0.9.tar.gz" target="_blank" rel="noopener">SDL</a>下载 2.0.9版本或以后的SDL2代码。</li>
<li>执行 ./configure</li>
<li>执行 make &amp;&amp; sudo make install</li>
<li>执行 export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig</li>
<li>[重新]编译ffmpeg</li>
</ul>
</li>
<li>方法二<ul>
<li>从<a href="https://www.libsdl.org/tmp/release/SDL2-2.0.9.dmg" target="_blank" rel="noopener">SDL</a>下载dmg包。</li>
<li>执行 open SDL2-2.0.9.dmg</li>
<li>[重新]编译ffmpeg</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Q-非Mac同学如何学习本课程"><a href="#Q-非Mac同学如何学习本课程" class="headerlink" title="Q: 非Mac同学如何学习本课程"></a>Q: 非Mac同学如何学习本课程</h2><p>A：本课程中的例子的界面是由 Swift 编写的，如果你没有 Mac 系统的话，你可以用 Qt 甚至不用界面开发，代码中与ffmpeg相着的代码都是跨平台的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://coding.imooc.com/class/415.html?mc_marking=b587280c0c1c0e76c1092aa21406565a&mc_channel=syb6" target="_blank" rel="noopener">音视频小白系统入门课</a></p>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
        <tag>音视频</tag>
        <tag>直播</tag>
      </tags>
  </entry>
  <entry>
    <title>js类的探究</title>
    <url>/18fc7df1/</url>
    <content><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/js/javascript.png" alt="javascript"></p>
<p>随着浏览器的发展，JS（JavaScript) 越来越受到人们的欢迎。它不再像以前只能做单一的渲染页面这样的事情了，在Chrome等现代浏览器上，你甚至可以用JS来做音视频的处理，是不是觉得很神奇？</p>
<p>不过今天我要讨论的并不是如何使用JS来做一些<strong>神奇</strong>的事儿，而是来重新认识一下JS中<strong>类</strong>的使用。对于这部分知识的理解，将为我们后面阅读Janus(一款WebRTC流媒体服务器)代码有着至关重要的作用。</p>
<a id="more"></a>

<h2 id="JS中的function"><a href="#JS中的function" class="headerlink" title="JS中的function"></a>JS中的function</h2><p>在ES5以前，JS中并没有<strong>class</strong>关键字，那时候JS是如何表示一个类的呢？说来也奇怪，它使用<strong>function</strong>来表示。</p>
<p>我在了解这部分知识的时候也是觉得不可思意！实际上我早在2003年的时候就学习并使用JS了，那时候JS还很简单。虽然后来很久没有再碰过它，但印象中<strong>function</strong>一直是用来定义一个函数的，现在怎么又用来定义<strong>类</strong>了呢？</p>
<p>后来看了一些资料才逐渐理清，原来现在的JS中<code>function</code>既可以用来定义函数，也可以用来定义类。有点类似于语文中的<strong>一语双关</strong>。</p>
<p>之所以<code>function</code>有双层含义，是因为JS最开始并不支持面向对象开发模式。但随着技术的发展，面向对象的开发模式越来越受到人们的欢迎，JS为了能跟上时代，所以也必须支持面向对象开发。</p>
<p>不过JS在转向面向对象语方时面临一种选择，即从原生语言上支持<code>class</code>，那JS解析器就要做大的调整，这可不是一时半会儿可以完成的。而如果在原有的基础上修改则要容易的多。</p>
<p>权衡利弊之后，JS<code>大神</code>们还是决定在现有的基础上修改是最省时少力的。于是就借用了<code>function</code>的函数，把它看作是一个<strong>构造函数</strong>，这样就可以快速的将JS改造成面向对象的开发语言了。</p>
<p>以上就是JS中使用<code>function</code>定义类的大致由头！下面我们就来看看在ES5上该如何定义一个<strong>类</strong>。</p>
<h2 id="类及成员"><a href="#类及成员" class="headerlink" title="类及成员"></a>类及成员</h2><p>在JS中如何定义一个类呢？实际上它与其它面向对象语言(如Java)是很类似的，只不过在Java中定义类用的是<code>class</code>关键字，而在JS中用<code>function</code>代替而以。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function classname() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Java 中，类的成员按安全性可以分为<strong>公有</strong>和<strong>私有</strong>，JS中是否也有类似的概念呢？答案是肯定的，接下来我们就来看一下在JS类中如何定义公有成员和私有成员吧。</p>
<p>JS中公有成员和私有成员的定义都是隐式的，不像Java有显确的<code>public</code>和<code>private</code>关键字来指明它们的权限。在JS类中直接定义的函数或变量都是私有成员，在类成员或函数前面加<code>this</code>关键字的，则表式是公有成员。</p>
<p>我们来看个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myclass ()&#123;</span><br><span class="line"></span><br><span class="line">    function test()&#123;</span><br><span class="line">        console.log(&quot;testA function&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; new myclass();</span><br><span class="line">obj.test();</span><br></pre></td></tr></table></figure>
<p>如果我们在浏览器执行上面的代码，在控制台你一定可以看到这样一条错误信息<code>Uncaught TypeError: obj.testfunc is not a function</code>，这说明通过<code>obj</code>对像是无法访问到<code>test()</code>函数的。</p>
<p>我们稍微调整一下这代段代，修改如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myclass ()&#123;</span><br><span class="line"></span><br><span class="line">    this.test &#x3D; test() &#123; &#x2F;&#x2F;这里加了this 关键字</span><br><span class="line">        console.log(&quot;testA function&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; new myclass();</span><br><span class="line">obj.test();</span><br></pre></td></tr></table></figure>
<p>我们在<code>test</code>函数前加上<code>this.</code>，只做这一点点修改，这段代码就可以在浏览器上成功运行了。</p>
<p>由此我们可以知道，如果你想让外面访问对象中的成员（成员变量或成员方法），你就应该在这些成员前面加上<code>this</code>关键字。反过来讲，如果你不想让外面访问到对象中的成员，则不要在这些成员前面加<code>this</code>。</p>
<h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><p>在Java中除了有对象成员外，还可以有类成员，比如在使用单例模式时，我们都会定义一个静态的成员。在JS中如何做到这点呢？我们来看个具体例子吧。还是刚才那个代码，我们在其基础上稍做修改即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义类方法</span><br><span class="line">myclass.init &#x3D; function()&#123; </span><br><span class="line">    console.log(&quot;class method!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function myclass ()&#123;</span><br><span class="line"></span><br><span class="line">    this.test &#x3D; test() &#123; &#x2F;&#x2F;这里加了this 关键字</span><br><span class="line">        console.log(&quot;testA function&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调用类方法</span><br><span class="line">myclass.init();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建对象</span><br><span class="line">var obj &#x3D; new myclass();</span><br><span class="line">obj.test();</span><br></pre></td></tr></table></figure>

<p>在这段代码中，加入了类方法的定义及调用类方法的代码。从上述代码中我们可以知道，在JS中类方法是在类之外定义的，而不像Java在是类内加<code>static</code>关键字。</p>
<h2 id="类的原型prototype"><a href="#类的原型prototype" class="headerlink" title="类的原型prototype"></a>类的原型prototype</h2><p>在JS中，每个类都有一个类属生prototype，用来指向类原型。或者你可以把它理解为指向<strong>类原型的地址</strong>。当我们想为这个类添加方法或成员变量的时候，就可以通过prototype来实现，只需修改prototype指向的内存地址的内容就可以达到添加成员的目的。</p>
<p>举个例子，假设我们定义了一个类如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myjs()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目前在这个类中没有写任何方法或成员变量，只是定义了一个空类。下面我想修改这个类，给这个类增加一些内容，该怎么做呢？实现的方法很简单，修改prototype即可，看下面的例子你就明白了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myjs()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myjs.prototype.a  &#x3D; 5;</span><br><span class="line">myjs.prototype.test &#x3D; function() &#123;</span><br><span class="line">    console.log(&quot;this is a function of myjs object!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; new myjs();</span><br><span class="line">console.log(&quot;myjs.a &#x3D;&#x3D; &quot; + obj.a );</span><br><span class="line">obj.test();</span><br></pre></td></tr></table></figure>

<p>通过上面的代码，我们就给<code>myjs</code>类增加了两个成员，即一个变量<code>a</code>和一个方法<code>test</code>。当我们生成myjs对象时，生成的对象中就有我们之前添加的成员变量和成员方法了。</p>
<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>JS中没有专门用于类继承的语法，不过你可以通过上一节介绍的prototype来实现<code>类继承</code>。在我们正式讲解继承之前，我们先了解一下prototype在内存中是如何表示的。如下图所示：<br><img data-src="https://cdn.avdancedu.com/image/article/js/prototype.jpg" alt="prototype"></p>
<p>通过上图我们可以看到，使用<code>function</code>定义的类并非真实的<code>类</code>，更准确的说它应该是一个<code>构造函数</code>。而类属性<code>prototype</code>指向的才是类的真正地址。</p>
<p>可能很多同学会问JS是如何通过构造函数找到它所在的类的呢？其实这是C语言的一个小巧，其过程是JS调用浏览器，通过浏览器使用C语言中的<code>技巧</code>获取构造函数所在类的地址，这对于浏览器来当然是小菜一碟。</p>
<p>了解了<code>prototype</code>的物理意义后，接下来我们看看类生成的对象在内存中的情况，它与prototype之间的关系又是怎样的？如下图所示。<br><img data-src="https://cdn.avdancedu.com/image/article/js/js_obj.jpg" alt="对象在内存中"></p>
<p>通过上图我们可以看到，JS在创建对象时会为每个对象分配内存空间。更为重要的一点是，多个相同类型的<code>对象</code>会指向同一个prototype。</p>
<p>了解了上面的特性后，我们就可以利用<code>prototype</code>来实现类的继承了。如何来做呢？我们再来举个例子。</p>
<p>首先，我们定义一个基类，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function parent() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;给基类添加一个新的属性 a</span><br><span class="line">parent.prototype.a &#x3D; 1;</span><br></pre></td></tr></table></figure>

<p>然后，我们创建一个子类，并让子类的prototype指向父类，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function child() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">child.prototype &#x3D; new parent();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;再给子类添加一个属性 b</span><br><span class="line">child.prototype.b &#x3D; 2;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建子类</span><br><span class="line">var obj_child &#x3D; new child();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;访问子类的属性</span><br><span class="line">console.log(&quot;a &#x3D; &quot; + obj_child.a);</span><br><span class="line">console.log(&quot;b &#x3D; &quot; + obj_child.b);</span><br></pre></td></tr></table></figure>

<p>执行上面的例子，我们通过浏览器的<code>debugger</code>就可以看到如下结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; 1</span><br><span class="line">b &#x3D; 2</span><br></pre></td></tr></table></figure>

<p>说明child子类确实是继承了parent类。我们再深扒一下，对于上面这段代码表示的继承关系在内存中的物理意义是什么呢？如下图所示：</p>
<p><img data-src="https://cdn.avdancedu.com/image/article/js/js_extend.jpg" alt="js继承"></p>
<p>在JS中，正常情况下每生成一个对象，该对象的 <code>__proto__</code> 都指向该对象的<strong>原始类的地址</strong>。如上图所示parent对象的<code>__proto__</code>指向parent.prototype，child对象的<code>__proto__</code>指向child.prototype。</p>
<p>为什么会这样呢？要理解其中的奥秘，我们必须要知道JS中 <code>new xxx</code> 做了哪些事儿。实际上，<code>new xxx</code> 做了四件事儿，我们以上图中的<code>new parent()</code>为例，它做的四件事儿如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123;&#125;;</span><br><span class="line">obj.__proto__ &#x3D; parent.prototype; &#x2F;&#x2F;即parent</span><br><span class="line">parent.call(obj);                 &#x2F;&#x2F;调用parent的构造函数</span><br><span class="line">return obj;</span><br></pre></td></tr></table></figure>

<p>在这步中，第二步是最关键的，它表明了新对象的<code>__proto__</code>指向了哪里。这样我们就可以理解 <strong>“对象的 <code>__proto__</code> 都指向该对象的原始类的地址”</strong> 这句话了。</p>
<p>当我们理解了 <code>new xxx</code> 的真实含义之后，<code>child.prototype = new parent()</code> 这句代码的含义立马就清楚了，它的含义是改变 <code>child.prototype</code> 的指向， 让他重新指向<code>parent</code>对象。</p>
<p>由于生成parent对象时，它的<code>__proto__</code>指向了parent的<strong>原始类</strong>，因此child.prototype就与parent的prototype建立了连接。</p>
<p>在接下来创建<code>obj_child</code>对象时，由于child.prototype已经指向了parent对象，因此<code>obj_child.__proto__</code>也就指向了parent对象。此时通过 old_child 就可以访问到parent对象的内容了，从而也就达到了继承的目的。</p>
<h2 id="ES6-中的类"><a href="#ES6-中的类" class="headerlink" title="ES6 中的类"></a>ES6 中的类</h2><p>大家对于在JS中使用<code>function</code>方式定义类实在感到很厌烦，就不能与其它语言一样可以使用<code>class</code>来定义类吗？在ES6时代，JS终于可以做到这一点了。</p>
<p>现在我们来看看在JS中该如何定义类吧，例子如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="noopener">阮一峰</a></p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js class typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>mediasoup 课程常见问题</title>
    <url>/5a9f427c/</url>
    <content><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/mediasoup_ask/mediasoup_banner.jpg" alt="mediasoup"><br>《WebRTC流媒体服器》课程推出已经有一段时间了，受到很多同学们的好评，是慕课网为数不多的10分好课。这门课是专门讲解与WebRTC互通的流媒体服务器的高端课，课程从如何开发服务器程序讲起，逐步向你介绍如何构建出一个可商用的、高并发的、性能优越的流媒体服务器。</p>
<p>该服务器可以与Chrome等浏览器对接，实现多人音视频会议系统或实时互动在线教育系统。毫不夸张的说，只要你能撑握课程中的 85% 的内容，去应聘流媒体服务器的研发岗时，你就不用再担心技术问题了。</p>
<a id="more"></a>

<p>在课程的评论区有很多评论，有兴趣的同学也可以参考一下</p>
<p><img data-src="https://cdn.avdancedu.com/image/article/mediasoup_ask/ping.jpg" alt="课程评论"></p>
<p>同学们在学习课程内容的时候也经常问一些问题，这里我总结了一些大家常见的问题以及问题答案希望对你能有所帮助。</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="Q-有mediasoup、janus、licode等流媒体服务器的比较吗？"><a href="#Q-有mediasoup、janus、licode等流媒体服务器的比较吗？" class="headerlink" title="Q: 有mediasoup、janus、licode等流媒体服务器的比较吗？"></a>Q: 有mediasoup、janus、licode等流媒体服务器的比较吗？</h3><p>A: <a href="https://www.avdancedu.com/947c722a/" target="_blank" rel="noopener">可以看我这篇文章</a></p>
<h3 id="Q-有各流媒体服务器之间的性能比较吗？"><a href="#Q-有各流媒体服务器之间的性能比较吗？" class="headerlink" title="Q: 有各流媒体服务器之间的性能比较吗？"></a>Q: 有各流媒体服务器之间的性能比较吗？</h3><p>A: <a href="https://webrtchacks.com/sfu-load-testing/" target="_blank" rel="noopener">可以看这篇文章</a></p>
<h3 id="Q-单台mediasoup流媒体服务器能承载多少人？"><a href="#Q-单台mediasoup流媒体服务器能承载多少人？" class="headerlink" title="Q: 单台mediasoup流媒体服务器能承载多少人？"></a>Q: 单台mediasoup流媒体服务器能承载多少人？</h3><p>A: 官方答案为 500 人。</p>
<h3 id="Q-布署流媒体服务器是需要怎样的配置"><a href="#Q-布署流媒体服务器是需要怎样的配置" class="headerlink" title="Q: 布署流媒体服务器是需要怎样的配置?"></a>Q: 布署流媒体服务器是需要怎样的配置?</h3><p>A: <a href="https://github.com/havfo/multiparty-meeting/wiki/Scaling-and-recommended-Hardware" target="_blank" rel="noopener">这里有一份说明</a></p>
<h3 id="Q-mediasoup安装时报错是什么原因？"><a href="#Q-mediasoup安装时报错是什么原因？" class="headerlink" title="Q: mediasoup安装时报错是什么原因？"></a>Q: mediasoup安装时报错是什么原因？</h3><p>A: 建议使用Ubuntu18.04 安装mediasoup。</p>
<h3 id="Q-在Ubuntu18-04上安装也报错"><a href="#Q-在Ubuntu18-04上安装也报错" class="headerlink" title="Q: 在Ubuntu18.04上安装也报错"></a>Q: 在Ubuntu18.04上安装也报错</h3><p>A: node 版本在 10 以上，npm 版本在 6.4 版本以上。</p>
<h3 id="Q-mediasoup安装好后看不对远端视频"><a href="#Q-mediasoup安装好后看不对远端视频" class="headerlink" title="Q: mediasoup安装好后看不对远端视频"></a>Q: mediasoup安装好后看不对远端视频</h3><p>A: 配置文件是否配置对了？检查一下IP地址不要写成127.0.0.1</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">WebRTC高并发流媒体服务器mediasoup</a></p>
]]></content>
      <categories>
        <category>WebRTC</category>
      </categories>
      <tags>
        <tag>WebRTC mediasoup 流媒体服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>多人实时互动之各WebRTC流媒体服务器比较</title>
    <url>/947c722a/</url>
    <content><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/sfu/conference.jpg" alt="SUF"><br>随着网络基础设施的提高，音视频实时通信越来越成为人们日常生活和工作中必不可少的需求。2011年 WebRTC的出现，则更加速了这种需求变为现实的可能性。</p>
<p>熟悉 WebRTC 的同学应该都知道，WebRTC规范只定义了实时通信中客户端的行为，而没有规范服务端（包括哪些信令、数据如何流转）的行为。所以，你可以使用WebRTC库方便的实现 1:1 实时通信，但对于多人实时互动，光依靠 WebRTC库显然就无法完成要求了。</p>
<p>那我们该如何实现多人实时互动通信呢？</p>
<a id="more"></a>

<h2 id="WebRTC-流媒体服务器"><a href="#WebRTC-流媒体服务器" class="headerlink" title="WebRTC 流媒体服务器"></a>WebRTC 流媒体服务器</h2><p>要想实现多人的实时互动，如音视频会议、在线教育这类产品，我们必须使用 WebRTC + WebRTC流媒体服务器这种方案。</p>
<p>目前有很多比较有名的开源流媒体服务器，如 Janus、Medooze、Mediasoup、Licode(OWT)、Jitsi等等。这些流媒体服务器各有优缺点，下面我就对这几种流媒体服务器作下简要的介绍与比较。</p>
<p>通过本文，你将知道各 WebRTC 流媒体服务器的优缺点，并依俱它们的优缺点选择出更适合你的那款WebRTC流媒体服务器。</p>
<h3 id="Mediasoup"><a href="#Mediasoup" class="headerlink" title="Mediasoup"></a>Mediasoup</h3><p><img data-src="https://upload-images.jianshu.io/upload_images/5956443-9b6b83a933943c4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Mediasoup 整体结构"></p>
<p>上图是Mediasoup整体架构图，通过该图我们可以知道 Mediasoup 流媒体服务器是由 Nodejs 和 Mediasoup(C++) 两部分组成。</p>
<ul>
<li>Nodejs，负责 Mediasoup 的信令接收与业务管理。如创建/消毁房间，创建/关闭生产者，创建/关闭消费者等。</li>
<li>Mediasoup(C++)，这是一个单独的程序，但该程序无法直接启动。因为它在内部会判断是否是 Nodejs 将它启动起来了。只有在Nodejs 的 Mediasoup 管理模块加载之后，再将 Mediasoup(C++)启动起来，这样它才能正常工作。</li>
</ul>
<p>在众多的 WebRTC 流媒体服务器中，Mediasoup 可以说是性能最优秀的WebRTC流媒体服务器。它使用 C++ 作为开发语言，底层使用 libuv 处理 I/O 事件。</p>
<p>有很多人对 Nodejs 比较诟病，认为 Nodejs 提拱不了高性能的流媒体服务器。实际上，如果按照传输的 Nodejs 应用开发出的流媒体服务器肯定是不能胜任这项工作的。但对于 Mediasoup 来讲，它只不过使用 Nodejs 做 信令处理 及 业务的管理 工作，所以它的负担并不重。对性能要求高的是媒体数据流的转发工作，而这部分工作是由 Mediasoup(C++)部分实现的。Nodejs 与 Mediasoup之间通过管道进行通信。</p>
<p>严格意义上来说，Mediasoup是单进程的。但你不要以为这就影响了它的性能。实际上，它是使用单进程的方式将服务器上CPU某个 <code>核</code> 充分利用好，然后在业务层控制进程的个数。比如说你的服务器是个 8 核的CPU，那么在业务层你就该启动 8 个Mediasoup进程。通过这种方式来达到对 CPU 的充分利用。</p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/5956443-87db0faac9090ef2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="mediasoup结构图"></p>
<p>Mediasoup中的每个进程称为一个 Worker, 你也可以把它理解为一个<code>节点</code>，在每个 Worker 中可以有多个 Router。对于 Router，你站在不同的解度可以有不同的理解。如果你占在应用层的角度，你可以把它理解为一个房间；如果你站在数据流转的角度，可以把它理解为一个路由器，数据通过 <code>路由器</code> 转发给目标用户。</p>
<p>想了解更多Mediasoup的细节，可以观看我的视频课 <a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">《百万级高并发WebRTC流媒体服务器设计与开发》</a>，在这个视频中我对 Mediasoup 源码做了深入剖析。</p>
<h3 id="Janus"><a href="#Janus" class="headerlink" title="Janus"></a>Janus</h3><p><img data-src="https://upload-images.jianshu.io/upload_images/5956443-b41cf420aaf37138.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Janus架构"></p>
<p>上面这张图是 Janus 的整体架构图。在这张图中我们可以看到， 从大的方面说 Janus 由 Janus CORE、Janus Plugin 以及信令接口三部分组成。</p>
<ul>
<li>信令接口，Janus 支持的信令协议比较多，如 HTTP、WebSocket、RabbitMQ 等。这些信令协议使得 Janus 具有非常好的接入性。因为很多公司喜欢各种不同的协议，如有的喜欢 websocket，有的喜欢http，proto等。因此 Janus 在信令接入方面具有很大的优势。</li>
<li>Janus Plugin，Janus 的业务管理是按照 Plugin 的方式管理的，因此你可以在Janus中根据自己的需要实现自己的业务插件。实际上，对于一般性的需求 Janus 已经相关的插件。如：<ul>
<li>VideoRoom，用于多人音视频互动，像音视频会议，在线教育都可以通过该插件来实现。</li>
<li>VideoCall，用于 1:1 的音视频通信。</li>
<li>SIP，用于与传统电话设备对接。</li>
<li>Streaming，用于广播，也就是我们通常所说的一人共享，多人观看的直播模式。</li>
<li>TextRoom，它是一个聊天室，通过它可以进行文本聊天。</li>
<li>RecordPlay，用于录制和回放。</li>
</ul>
</li>
<li>Janus Core 是Janus的核心，其作用是处理流的转发，各种协议的接入。以浏览器为例，要想让浏览器接入到 WebRTC 流媒体服务器上，那流媒体服务器必须要支持 STUN、DTLS、SRTP、ICE 等协议。而 Janus Core 就是专门做这事儿的。</li>
</ul>
<p>Janus 是由 C语言开发的，因此它的性能非常优秀。要说不足的话，janus 底层没有使用 epoll 这类异步I/O事件处理机制，这应该说是它的一大缺陷；另外，Janus还使用 glib 库，由于 glib 库对于国内的很多开发同学来说用的比较少，所以会有一定的学习成本。</p>
<p>整体上看，Janus采用了插件的架构设计方案。这种方案非常适合于有多种业务模型或业务经常发生变化的公司或项目。另外 Janus 支持多种消息传输协议，这对于开发人员来说具有极大的吸引力。</p>
<h2 id="Medooze"><a href="#Medooze" class="headerlink" title="Medooze"></a>Medooze</h2><p><img data-src="https://upload-images.jianshu.io/upload_images/5956443-a13ae708ccc4a4b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Medooze 架构.png"></p>
<p>Medooze 的整体架构与 Mediasoup 类似，不过它的信令处理、业务管理以及媒体数据的转发功能都是放在 Nodejs下进行统一管理的。实际上，这样的管理方式也不会对性能造成什么影响，因为重的媒体流的转发工作仍然是使用的 C++ 在 Nodejs 底层实现的。</p>
<p>Medooze 的业务功能要比 Mediasoup 强大，像服务端录制、推流这些 Mediasoup 没有的功能它都支持。但它性能没有 Mediasoup 做的极致，在Medooze的底层使用的poll来处理I/O事件，poll与epoll性能相差距大。除此之外，Medooze的业务逻辑也没有Mediasoup简洁；另外与 Janus 相比，它的业务管理不如 Janus 灵活，Janus 的插件管理方式显然要优于 Medooze 和 mediasoup。</p>
<p>但总的来说，Medooze还是一款非常不错的 WebRTC 流媒体服务器。虽然有一些小的暇疵，但还是非常不错的一款流媒体服务器。</p>
<p>想了解更多 Medooze 细节的同学可以看我的专栏 <a href="https://time.geekbang.org/column/article/136000" target="_blank" rel="noopener">《从0打造音视频直播系统》</a>。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过上面的描述，我想你应该对目前主流的 WebRTC 流媒体服务器有了一个大体的了解。所以在选型上你可以按照自己团队的能力进行评估到底该用那个流媒体服务器。</p>
<p>如果你团队能力比较强，可以做底层开发，那么建议你使用 Mediasoup。因为 Mediasoup 不关心应用层，它关注的是底层数据如何高效的流转，代码简洁、高效，性能极佳。</p>
<p>如果你们要做的业务种类比较多，变化比较快，那建议你选择使用 Janus 作为流媒体服务器。将你的业务做成一个插件放到 Janus上很快就能实现你们的业务需求。</p>
<p>如果你们的业务变化不大，除了追求性能外，还需要录制、推流之类的功能，那么你可以选择使用Medooze，它可以很好的满足你们的需求。</p>
<p>当然，除了上面我介绍到的几款比较流行的 WebRTC 流媒体服务器外，还有一些其它的流媒体服务器，如 Licode、OWT、Jitsi等也可以选择。</p>
<p>Licode 之所以名气比较大，是因为它推出的时间比较早。而 OWT 是 Licode 的一个变种，它在 Licode上实现了 SFU 功能。看一下 Licode 代码你就会发现，Licode 实现了一套完整的音视频会议系统，对于这样一套系统它的实现非常复杂。如果你的团队没有音视频方面的开发人才的话，可以考虑Licode，将它搭建出来之后就可以直接使用了。但如果你有业务变化想修改它就太麻烦了。</p>
<p>Jitsi 上层是使用 Java 语言开发的，但底层也是使用的 C/C++ 语言。它通过 JNI 来实现Java与 C/C++之间的通信。在 2018 年有机构做过一次性能评测，当时 Jitsi 表现比较差强人意，不知现在是否已经有了改进。</p>
<p>以上就是对几款 WebRTC流媒体服务器的比较，希望本文可以帮助你解决WebRTC流媒体服务器的选择问题。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">《百万级高并发WebRTC流媒体服务器设计与开发》</a></li>
<li><a href="https://time.geekbang.org/column/article/136000" target="_blank" rel="noopener">《从0打造音视频直播系统》</a></li>
<li><a href="https://www.jianshu.com/p/159ab573c38d" target="_blank" rel="noopener">音视频会议系统 Janus 的布署与安装</a></li>
<li><a href="https://www.jianshu.com/p/98674c32aef8" target="_blank" rel="noopener">Janus的线程模型</a></li>
<li><a href="https://www.jianshu.com/p/7867916c52e3" target="_blank" rel="noopener">理解Janus中的Plugin</a></li>
</ul>
]]></content>
      <categories>
        <category>WebRTC 音视频 流媒体服务器</category>
      </categories>
      <tags>
        <tag>WebRTC mediasoup janus medooze licode owt 音视频 流媒体服务器</tag>
      </tags>
  </entry>
</search>
