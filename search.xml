<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>音视频已强势崛起，我们该如何快速入门音视频技术？</title>
    <url>/811929dc/</url>
    <content><![CDATA[<blockquote>
<p>作者： 李超 音视频直播技术专家<br>曾在 跟谁学 负责直播平台技术团队的管理工作；在 新东方集团 任职音视频技术专家；<br>在音视频会议行业工作6年，在线教育行业工作4年，一直聚焦在多人音视频实时互动领域。</p>
</blockquote>
<p>最近经常遇到一些同学问我如何学习音视频，怎样才能快速上手？还有一些对音视频不了解的同学问我该不该学习音视频？作为一名音视频行业的10年老兵，我有一些思考分享给大家，希望能对你有所帮助。</p>
<a id="more"></a>

<h2 id="大背景"><a href="#大背景" class="headerlink" title="大背景"></a>大背景</h2><p><img data-src="http://img1.sycdn.imooc.com/5e84c07f0001c21806890390.jpg" alt=""></p>
<p>2020年真的是一个多灾、多难的年份，冠状病毒的爆发使得本该举国欢庆的春节变得尤为沉闷。不能走亲，不能访友，除了呆在家里，那儿也不能去。正如张文宏大夫向我们劝解的，我们要将病毒给<code>闷死</code>。</p>
<p>大家都盼着疫情可以赶紧过去，早点恢复正常的生活。但从目前的情况看，短时间内这个疫情是很难结束的。这不刚从中国消停了一阵，又跑到海外大爆发了，谁知道它会不会又转回来呢？</p>
<p>可我们还得生活！还得工作！还要学习！</p>
<h2 id="好时代"><a href="#好时代" class="headerlink" title="好时代"></a>好时代</h2><p><img data-src="http://img1.sycdn.imooc.com/5e84c080000173fe12000437.jpg" alt=""></p>
<p>幸运的是我们生活在一个好时代，科技在这几十年得到了迅猛的发展。在疫情肆虐的当下，我们可以通过音视频会议进行远程办公；我们还有在线教育系统，对于大多数学生来说，完全可以在家进行在线学习。</p>
<p>从某个角度看，这次疫情虽然导致很多行业处于崩溃边缘，但也催生了新的行业发展，其中音视频会议和在线教育就是因<code>疫</code>而起的行业。在疫情短时间内难以结束的情况下，音视频会议和在线教育的重要性马上体现了出来，新的沟通方式和教育方式被越来越多的人所认知，所接纳。</p>
<p>甚至我们可以判定，在线教育行业和音视频会议行业会在今年崛起，并在未来十年得到迅猛发展。</p>
<p>目前，各大巨头公司（如阿里、腾讯、今日头条，新东方等），纷纷在这两个方向上谋篇布局，进行了大量的投资，笼络技术人才，也可以间接佐证这个判断了。</p>
<h2 id="大趋势"><a href="#大趋势" class="headerlink" title="大趋势"></a>大趋势</h2><p><img data-src="http://img1.sycdn.imooc.com/5e84c0820001ade512400564.jpg" alt=""></p>
<p>从未来的大趋势来看，随着5G时代的到来，音视频慢慢变成人们日常生活中的必须品。除了在线教育、音视频会议、即时通讯这些必须使用音视频技术的产品外，其它的产品也需要加入音频、视频元素。比如说将现在的网站注册与登陆的图文方式全部改为语音方式是否更加安全？相信随着音视频技术的普及，更加有创意的产品会如雨后春笋般孕育而生。</p>
<p>目前，音视频技术从之前的<strong>象牙塔</strong>逐渐走向<strong>百姓家</strong>已是不争的事实。正是因为这样一个大的趋势，现在除了各大厂之外，其它一些小厂也开始寻找音视频人才。一名稍好点的音视频人才现在可能会有3-4家公司抢着要、挣着要。</p>
<p>对音视频人才的需求从小众变成了大众，这更多的是大家对未来市场预期的结果。做个不恰当的比喻，3G/4G的出现，促成了移动互联网10年繁荣。而5G的出现，也会促成至少10年音视频行业的繁荣。</p>
<p><strong>除了5G的到来可以让音视频得到更广范的应用外，音视频技术在未来还有更重要的作用</strong>。事实上，在人类可以识别人信息中，音视频包含的信息是最丰富的，但人类并没有很好的将它们利用起来。</p>
<p>究其原因，是因为这些信息都是非结构化的数据，而人类善长的是处理结构化数据（比如数据库）。而对于这些非结构化的数据却无从下手的，所以这些音视频数据都被白白浪费掉了。</p>
<p>但随着计算机视觉、人工智能的发展，人们开始撑握了如何将音视频这类非结构化数据转化为结构化数据的方法。一旦我们将音视频数据转为结构化数据后，我们就可以利用现有的技术（如搜索引擎、大数据，数据挖掘等）对这些数据进行各种分析了，这个价值是不是更加惊人呢？而这一切的基础都是音视频技术。</p>
<p>所以，音视频研发的未来是极为广阔的。目前可以说是学习音视频的最佳时机，<strong>及早的加入音视频研发的队伍，才能使自己在未来的职场上更有作为</strong>。</p>
<h2 id="有钱景"><a href="#有钱景" class="headerlink" title="有钱景"></a>有钱景</h2><p><img data-src="http://img2.sycdn.imooc.com/5e84c0830001d45512000437.jpg" alt=""></p>
<p>正如我上面所说的，各大厂为了争夺未来，抢占先机，不惜重金笼络人才。通过招聘市场我们可以了解到，一名合格的音视频开发人员，少则年薪 30 万起，多则可以达 100万以上。</p>
<p>出现这种情况的原因主要有两个，一是音视频方面的人才不好培养，二是现有的优秀人才太少了。</p>
<p>从技术上来说，音视频从业者分成两个方向，一是搞算法的，另一个是搞工程的。搞音视频算法的这类人非常少，需要有深的数学能力和算法背景。相对来说，学习成本高，一般企业不需要，也养不起。这类人一般都会选择去大公司，薪水百万都是Low的。这些人一般只专注在一个领域上，因此就业面也窄。</p>
<p>搞工程的人相对多一些，他们有扎实的理论基础，很强的技术功底，对音频/视频都非常熟悉。这类人才工资要比同级别的其它开发人员薪资高20%以上。</p>
<p>因此，搞音视频技术的开发人员钱景还是非常乐观的。而且随着时间的推移，在未来几年音视频人才会更加炙手可热。</p>
<h2 id="音视频好学吗？"><a href="#音视频好学吗？" class="headerlink" title="音视频好学吗？"></a>音视频好学吗？</h2><p><img data-src="http://img1.sycdn.imooc.com/5e84c0850001c42712400565.jpg" alt=""></p>
<p>说句实话，音视频自学起来困难重重，学习成本非常高，且效率低。主要有两方面的原因，一是音视频知识庞杂，通俗易懂的资料非常少；另一方面，网上充斥着大量的错误信息，使得很多初学者掉到坑里就爬不出来了。</p>
<p>我来举个例子，按照传统的音视频学习方法，学习音视频你首先要阅读大量的音视频规范/协议文档（如H264、MP4/FLV、RTP/RTCP等）。这些文档中的内容基本都以<strong>位</strong>为单位的，即每个二进制位的变化都代表不同的含义，这种文档极其枯燥，很难阅读。</p>
<p>在对文档熟悉的前提下，再进行代码的开发难度就“更上一层楼”了。这时你会发现，如果你对 C/C++ 使用不熟练，没有专门进行过训练的话，你就进入了炼狱般的状况，那是一种折磨。</p>
<p>好在现在有FFMPG、WebRTC 等开源库，大大降低了研发成本。但即使这样，对于小白同学来说学习音视频依然是十分困难的。</p>
<h2 id="小白如何学习音视频？"><a href="#小白如何学习音视频？" class="headerlink" title="小白如何学习音视频？"></a>小白如何学习音视频？</h2><p><img data-src="http://img1.sycdn.imooc.com/5e84c0850001599610240576.jpg" alt=""></p>
<p>如上面所讲，音视频的入门难度还是蛮大的，我们该如何更快的入门呢？</p>
<p>我觉得最好的方式有非常好的课程，可以循序渐近，有条理、系统的学习。当然能有老师指导，遇到问题时老师能及时给予解答就更加锦上添花了。这样既可以快速入门，又可以系统的学习音视频知识，可以说这是最佳途径了。</p>
<p>对于能力强的同学也可以自学，但相对来说，这个时间成本就太高了。遇到一个坑卡几天是很正常的。网上音视频资料那么多坑，你想想要经历多长时间你才能真正学会它呢？即使你历尽千辛入门之后，你会发现离用人单位的要求还差着十万八千里呢。</p>
<p>对于各大厂来说，他们要招聘的人才既要有非常扎实的基础知识，又需要有一定的工程经验；如果你在学习的过程中没有实际做一些项目就很难达到它们的要求。</p>
<p>正是基于这样的考虑，我推出了一系列音视频的课程。这些课程中既有适合小白同学入门的课程（如<a href="https://coding.imooc.com/class/415.html?mc_marking=458ad0334bdc050a302667f903757fa0&mc_channel=shouji" target="_blank" rel="noopener">音视频小白系统入门</a>）, 又有进阶的课程（如<a href="https://coding.imooc.com/class/279.html?mc_marking=59c321c0417e144904c49c366f94dd57&mc_channel=shouji" target="_blank" rel="noopener">FFmpeg音视频核心技术精讲与实战</a>）。</p>
<p>其中与ffmpeg相关的课程是<a href="https://coding.imooc.com/class/415.html?mc_marking=458ad0334bdc050a302667f903757fa0&mc_channel=shouji" target="_blank" rel="noopener">音视频小白系统入门</a>和<a href="https://coding.imooc.com/class/279.html?mc_marking=59c321c0417e144904c49c366f94dd57&mc_channel=shouji" target="_blank" rel="noopener">FFmpeg音视频核心技术精讲与实战</a>。与 WebRTC 相关的课程是<a href="https://coding.imooc.com/class/329.html?mc_marking=59909dfb407cd07d4f3998dbc2d45c49&mc_channel=shouji" target="_blank" rel="noopener">WebRTC实时互动直播技术入门与实战</a>和 <a href="https://coding.imooc.com/class/387.html?mc_marking=6ebf81516468954587f53973c3c1789a&mc_channel=shouji" target="_blank" rel="noopener">WebRTC流媒体服务器设计与开发</a>。</p>
<p>如果你想学习音视频基础知识，音视频处理、编辑、特效相关的内容就学习ffmpeg的系列课程。如果你想学习音视频实时通讯（如音视频会议、在线教育）就学习WebRTC相关的课程。</p>
<h2 id="入门音视频要学习哪些内容呢？"><a href="#入门音视频要学习哪些内容呢？" class="headerlink" title="入门音视频要学习哪些内容呢？"></a><a href="https://coding.imooc.com/class/415.html?mc_marking=458ad0334bdc050a302667f903757fa0&mc_channel=shouji" target="_blank" rel="noopener">入门音视频要学习哪些内容呢？</a></h2><p><img data-src="http://img1.sycdn.imooc.com/5e84c086000163a706360300.jpg" alt=""></p>
<p>这里我简单列举一下入门音视频都要学哪些知识。对于已经学习了一些音视频知识而不知道自己目前水平的同学也可以作为一个参考，看看自己是否达到了入门水平。</p>
<ul>
<li>ffmpeg在不同系统中的安装与简单裁剪</li>
<li>音频基础知识，如频率、采样大小和通道数等</li>
<li>音频的压缩原理</li>
<li>如何从不同的设备上采集音频数据</li>
<li>如何对音频进行不同的编解码</li>
<li>视频的基础知识</li>
<li>H264编码原理</li>
<li>如何从不同设备上采集视频数据</li>
<li>熟悉YUV的一些常见格式（YUV420、NV21，YV12的不同）</li>
<li>如何将YUV数据编码为H264/H265、VP8/VP9等</li>
<li>FLV/RTMP/HLS/MP4协议要十分清楚<br>……</li>
</ul>
<p>从上面的列表中你可能看到，要入门音视频要学的知识还是不少的。尤其是音视频的基础原理是最为重要的，否则你去面试人家问你为什么会产生花屏，为什么会产生卡顿，如何才能秒开这些简单的问题你都无法回答上来。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总之，音视频已经强势崛起，相信未来的十年一定是音视频的十年。并且将音视频技术与计算机视觉和人工智能结合将引领未来二十年。</p>
<p>现在正是学习音视技术的最佳时机，大家一定要把握住机会，跟上时代的步伐，让自己可以在未来大有作为。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://coding.imooc.com/class/415.html?mc_marking=458ad0334bdc050a302667f903757fa0&mc_channel=shouji" target="_blank" rel="noopener">音视频小白系统入门</a></li>
<li><a href="https://coding.imooc.com/class/279.html?mc_marking=59c321c0417e144904c49c366f94dd57&mc_channel=shouji" target="_blank" rel="noopener">FFmpeg音视频核心技术精讲与实战</a></li>
<li><a href="https://coding.imooc.com/class/329.html?mc_marking=59909dfb407cd07d4f3998dbc2d45c49&mc_channel=shouji" target="_blank" rel="noopener">WebRTC实时互动直播技术入门与实战</a></li>
<li><a href="https://coding.imooc.com/class/387.html?mc_marking=6ebf81516468954587f53973c3c1789a&mc_channel=shouji" target="_blank" rel="noopener">WebRTC流媒体服务器设计与开发</a></li>
</ul>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>音视频</tag>
      </tags>
  </entry>
  <entry>
    <title>mediasoup 课程常见问题</title>
    <url>/5a9f427c/</url>
    <content><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/mediasoup_ask/mediasoup_banner.jpg" alt="mediasoup"><br>《WebRTC流媒体服器》课程推出已经有一段时间了，受到很多同学们的好评，是慕课网为数不多的10分好课。这门课是专门讲解与WebRTC互通的流媒体服务器的高端课，课程从如何开发服务器程序讲起，逐步向你介绍如何构建出一个可商用的、高并发的、性能优越的流媒体服务器。</p>
<p>该服务器可以与Chrome等浏览器对接，实现多人音视频会议系统或实时互动在线教育系统。毫不夸张的说，只要你能撑握课程中的 85% 的内容，去应聘流媒体服务器的研发岗时，你就不用再担心技术问题了。</p>
<a id="more"></a>

<p>在课程的评论区有很多评论，有兴趣的同学也可以参考一下</p>
<p><img data-src="https://cdn.avdancedu.com/image/article/mediasoup_ask/ping.jpg" alt="课程评论"></p>
<p>同学们在学习课程内容的时候也经常问一些问题，这里我总结了一些大家常见的问题以及问题答案希望对你能有所帮助。</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="Q-有mediasoup、janus、licode等流媒体服务器的比较吗？"><a href="#Q-有mediasoup、janus、licode等流媒体服务器的比较吗？" class="headerlink" title="Q: 有mediasoup、janus、licode等流媒体服务器的比较吗？"></a>Q: 有mediasoup、janus、licode等流媒体服务器的比较吗？</h3><p>A: <a href="https://www.avdancedu.com/947c722a/" target="_blank" rel="noopener">可以看我这篇文章</a></p>
<h3 id="Q-有各流媒体服务器之间的性能比较吗？"><a href="#Q-有各流媒体服务器之间的性能比较吗？" class="headerlink" title="Q: 有各流媒体服务器之间的性能比较吗？"></a>Q: 有各流媒体服务器之间的性能比较吗？</h3><p>A: <a href="https://webrtchacks.com/sfu-load-testing/" target="_blank" rel="noopener">可以看这篇文章</a></p>
<h3 id="Q-单台mediasoup流媒体服务器能承载多少人？"><a href="#Q-单台mediasoup流媒体服务器能承载多少人？" class="headerlink" title="Q: 单台mediasoup流媒体服务器能承载多少人？"></a>Q: 单台mediasoup流媒体服务器能承载多少人？</h3><p>A: 官方答案为 500 人。</p>
<h3 id="Q-布署流媒体服务器是需要怎样的配置"><a href="#Q-布署流媒体服务器是需要怎样的配置" class="headerlink" title="Q: 布署流媒体服务器是需要怎样的配置?"></a>Q: 布署流媒体服务器是需要怎样的配置?</h3><p>A: <a href="https://github.com/havfo/multiparty-meeting/wiki/Scaling-and-recommended-Hardware" target="_blank" rel="noopener">这里有一份说明</a></p>
<h3 id="Q-mediasoup安装时报错是什么原因？"><a href="#Q-mediasoup安装时报错是什么原因？" class="headerlink" title="Q: mediasoup安装时报错是什么原因？"></a>Q: mediasoup安装时报错是什么原因？</h3><p>A: 建议使用Ubuntu18.04 安装mediasoup。</p>
<h3 id="Q-在Ubuntu18-04上安装也报错"><a href="#Q-在Ubuntu18-04上安装也报错" class="headerlink" title="Q: 在Ubuntu18.04上安装也报错"></a>Q: 在Ubuntu18.04上安装也报错</h3><p>A: node 版本在 10 以上，npm 版本在 6.4 版本以上。</p>
<h3 id="Q-mediasoup安装好后看不对远端视频"><a href="#Q-mediasoup安装好后看不对远端视频" class="headerlink" title="Q: mediasoup安装好后看不对远端视频"></a>Q: mediasoup安装好后看不对远端视频</h3><p>A: 配置文件是否配置对了？检查一下IP地址不要写成127.0.0.1</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">WebRTC高并发流媒体服务器mediasoup</a></p>
]]></content>
      <categories>
        <category>WebRTC</category>
      </categories>
      <tags>
        <tag>WebRTC mediasoup 流媒体服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>ffmpeg精讲常见问题</title>
    <url>/f3f66133/</url>
    <content><![CDATA[<h2 id="问：编译-ffmpeg-方法"><a href="#问：编译-ffmpeg-方法" class="headerlink" title="问：编译 ffmpeg 方法"></a>问：编译 ffmpeg 方法</h2><p>答：在各个平台编译方法基本都是一样的。</p>
<ul>
<li>首先下载 ffmpeg 源码，地址为: <a href="https://www.ffmpeg.org/download.html" target="_blank" rel="noopener">https://www.ffmpeg.org/download.html</a></li>
<li>进入到下载后的<a href="https://coding.imooc.com/class/279.html?mc_marking=59c321c0417e144904c49c366f94dd57&mc_channel=shouji" target="_blank" rel="noopener">ffmpeg目</a>录下，执行下面的指令：<a id="more"></a>
<ul>
<li>Mac 平台：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;ffmpeg</span><br><span class="line">                  --enable-gpl</span><br><span class="line">                  --enable-nonfree</span><br><span class="line">                  --enable-libfdk-aac</span><br><span class="line">                  --enable-libx264</span><br><span class="line">                  --enable-libx265</span><br><span class="line">                  --enable-filter&#x3D;delogo</span><br><span class="line">                  --enable-debug</span><br><span class="line">                  --disable-optimizations</span><br><span class="line">                  --enable-libspeex</span><br><span class="line">                  --enable-videotoolbox</span><br><span class="line">                  --enable-shared</span><br><span class="line">                  --enable-pthreads</span><br><span class="line">                  --enable-version3</span><br><span class="line">                  --enable-hardcoded-tables</span><br><span class="line">                  --cc&#x3D;clang</span><br><span class="line">                  --host-cflags&#x3D;</span><br><span class="line">                  --host-ldflags&#x3D;</span><br></pre></td></tr></table></figure></li>
<li>Linux平台<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;ffmpeg</span><br><span class="line">                  --enable-gpl</span><br><span class="line">                  --enable-nonfree</span><br><span class="line">                  --enable-libfdk-aac</span><br><span class="line">                  --enable-libx264</span><br><span class="line">                  --enable-libx265</span><br><span class="line">                  --enable-filter&#x3D;delogo</span><br><span class="line">                  --enable-debug</span><br><span class="line">                  --disable-optimizations</span><br><span class="line">                  --enable-libspeex</span><br><span class="line">                  --enable-shared</span><br><span class="line">                  --enable-pthreads</span><br></pre></td></tr></table></figure></li>
<li>Windows平台<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;ffmpeg</span><br><span class="line">                  --enable-gpl</span><br><span class="line">                  --enable-nonfree</span><br><span class="line">                  --enable-libfdk-aac</span><br><span class="line">                  --enable-libx264</span><br><span class="line">                  --enable-libx265</span><br><span class="line">                  --enable-filter&#x3D;delogo</span><br><span class="line">                  --enable-debug</span><br><span class="line">                  --disable-optimizations</span><br><span class="line">                  --enable-libspeex</span><br><span class="line">                  --enable-static</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<h2 id="问：make-amp-amp-make-install失败"><a href="#问：make-amp-amp-make-install失败" class="headerlink" title="问：make &amp;&amp; make install失败"></a>问：make &amp;&amp; make install失败</h2><p>答：make &amp;&amp; make install 之所以会失败，则由于该用户没有操作目录的权限引起的。所以只需要在make install 之前加 sudo即可。</p>
<p>另一种方法是将用户切换成 root用户，因 root用户的权力最大，所以这样做也是没问题的。但建议还是用 非 root用户操作，这样更安全。</p>
<h2 id="问：库已经安装好了，但仍报找不到它的错误？"><a href="#问：库已经安装好了，但仍报找不到它的错误？" class="headerlink" title="问：库已经安装好了，但仍报找不到它的错误？"></a>问：库已经安装好了，但仍报找不到它的错误？</h2><p>答：首先确认是否已经将 <code>pkg-config</code>工具安装好了。可以执行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pkg-config</span><br></pre></td></tr></table></figure>
<p>如果提示没有安装，则先将该工具安装好，安装命令如下：</p>
<ul>
<li>ubuntu  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt intall pkg-config</span><br></pre></td></tr></table></figure></li>
<li>mac  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install pkg-config</span><br></pre></td></tr></table></figure></li>
<li>cygwin  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-cyg install pkg-config</span><br></pre></td></tr></table></figure></li>
<li>centos  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install pkg-config</span><br></pre></td></tr></table></figure>
安装完该工具后仍然报错？那再按照具体的错误看下面的解决方案吧。</li>
</ul>
<h2 id="问：libx264库找不到（-ERROR-libx264-not-found-）"><a href="#问：libx264库找不到（-ERROR-libx264-not-found-）" class="headerlink" title="问：libx264库找不到（[ERROR: libx264 not found]）"></a>问：libx264库找不到（[ERROR: libx264 not found]）</h2><p>该问题可能由下面三个方面的问题引起。</p>
<ul>
<li>libx264库没有安装。对于这种情况有两种解决办法:<ul>
<li>其一，是通过平台的安装工作进行安装，如 apt/brew/yum install x264。（注：在Linux下应该安装 libx264-dev）。</li>
<li>其二，是通过源码安装，步骤如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. wget https:&#x2F;&#x2F;code.videolan.org&#x2F;videolan&#x2F;x264&#x2F;-&#x2F;archive&#x2F;master&#x2F;x264-master.tar.bz2</span><br><span class="line">2. bunzip2 x264-master.tar.bz2</span><br><span class="line">3. tar -vxf x264-master.tar.tar</span><br><span class="line">4. .&#x2F;configure --enable-static --enable-shared --disable-asm --disable-avs</span><br><span class="line">5. make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>通过 pkg-config 命令无法找到。对于这类问题，我们可以使用下面的命 <code>pkg-config --cflags --lib libx264</code>看是否可以找到 libx264，如果找不到，就说明确实是这个问题。解决的办法是设置环境变量。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PKG_CONFIG_PATH&#x3D;$PKG_CONFIG_PATH:&#x2F;xxx&#x2F;xxx&#x2F;lib&#x2F;pkgconfig</span><br></pre></td></tr></table></figure>
其中 <code>xxx</code> 由你的实际路径代替。</li>
</ul>
<blockquote>
<p>注，有可能你的系统中并没有装 pkg-config工具，可以使用 brew/apt/yum install pkg-config进行安装。</p>
</blockquote>
<ul>
<li>无法链接上libx264, 这是由于通过环境变量 LD_LIBRARY_PATH 无法定位到 libx264库。解决的办法也很简单，与上面类似，可以通过设置环境变量来解决该问题。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export LD_LIBRARY_PATH&#x3D;$LIB_LIBRARY_PATH:&#x2F;xxx&#x2F;xxx&#x2F;lib</span><br></pre></td></tr></table></figure>
其中，<code>xxx</code>由你的实际路径代替。</li>
</ul>
<p>当然，你也可以将环境变量设置在脚本里，这样就不用每次都写export命令了。只需要将上面的两条语句加入到 <del>/.bashrc / 或</del>/.bash_profil 文件里，然后在控制台执行 <code>source ~/.bashrc</code> 或 <code>source ~/.bash_profile</code>即可。</p>
<h2 id="问：fdk-aac库找不到（-ERROR-libfdk-aac-not-found-）"><a href="#问：fdk-aac库找不到（-ERROR-libfdk-aac-not-found-）" class="headerlink" title="问：fdk-aac库找不到（[ERROR: libfdk_aac not found]）"></a>问：fdk-aac库找不到（[ERROR: libfdk_aac not found]）</h2><p>答：该问题与上面的 libx264 问题类似，所以只需要将上面的 libx264替换为libfdk-aac即可。这里不在赘述。</p>
<h2 id="问：speex库找不到（-ERROR-speex-not-found-）"><a href="#问：speex库找不到（-ERROR-speex-not-found-）" class="headerlink" title="问：speex库找不到（[ERROR: speex not found]）"></a>问：speex库找不到（[ERROR: speex not found]）</h2><p>答：该问题与上面的 libx264 问题类似，所以只需要将上面的 libx264替换为speex即可。这里不在赘述。</p>
<h2 id="问：编译不出ffplay"><a href="#问：编译不出ffplay" class="headerlink" title="问：编译不出ffplay"></a>问：编译不出ffplay</h2><p>答：引起该问题有以下几方面的原因：</p>
<ul>
<li>所使用的操作系统没有安装图形库。如有的同学在阿里的云服务器上想安装ffplay是肯定不行的。</li>
<li>没有安装 SDL2 库。解决办法是通过 brew/apt/yum install sdl2 即可 或 通过 SDL2 源码安装。<strong>安装完成后，要重新进行到 ffmpeg目录下，执行 ./configure…这指命令。</strong></li>
<li>有的同学编译ffmpeg时，在ffmpeg目录执行./configure … 之后，没有修改config.h文件，这样也编译不出ffplay来。解决办法是进入到 ffmpeg 目录下，打开 config.h文件找 FFPLAY 关键字，将其后面的 0 修改为 1，保存并退出该文件。在当前目录下执行 make &amp;&amp; sudo  make install。<strong>注意，修改 config.h文件后，不要再执行./configure …了，否则config.h中的值又都恢复为原来的值了。</strong></li>
<li>SDL2与最新的Mac系统 mojave不兼容。解决办法：<ul>
<li>方法一<ul>
<li>从 <a href="https://www.libsdl.org/tmp/release/SDL2-2.0.9.tar.gz" target="_blank" rel="noopener">SDL</a>下载 2.0.9版本或以后的SDL2代码。</li>
<li>执行 ./configure</li>
<li>执行 make &amp;&amp; sudo make install</li>
<li>执行 export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig</li>
<li>[重新]编译ffmpeg</li>
</ul>
</li>
<li>方法二<ul>
<li>从<a href="https://www.libsdl.org/tmp/release/SDL2-2.0.9.dmg" target="_blank" rel="noopener">SDL</a>下载dmg包。</li>
<li>执行 open SDL2-2.0.9.dmg</li>
<li>[重新]编译ffmpeg</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="SDL在windows的-cygwin下无法打印日志"><a href="#SDL在windows的-cygwin下无法打印日志" class="headerlink" title="SDL在windows的 cygwin下无法打印日志"></a>SDL在windows的 cygwin下无法打印日志</h2><p>在编译 SDL 时，将configure 中的 <code>-mwindows</code> 参数去掉。</p>
<h2 id="问：如何在Windows下编译ffmpeg问题"><a href="#问：如何在Windows下编译ffmpeg问题" class="headerlink" title="问：如何在Windows下编译ffmpeg问题"></a>问：如何在Windows下编译ffmpeg问题</h2><p>答：参见 <a href="https://www.imooc.com/article/247113" target="_blank" rel="noopener">Windows下编译ffmpeg问题</a></p>
<h2 id="问：在Windows下编译安装ffmpeg是不是特别麻烦？"><a href="#问：在Windows下编译安装ffmpeg是不是特别麻烦？" class="headerlink" title="问：在Windows下编译安装ffmpeg是不是特别麻烦？"></a>问：在Windows下编译安装ffmpeg是不是特别麻烦？</h2><p>答：确实是这样。所以建议在Window开发者最好装一个 Ubuntu的虚拟机，这样就方便很多了。如果条件允许的话，最好能用Mac开发。可以说Mac Pro是关专为开发者制造的，一旦你用上它会让你爱不释手。</p>
<h2 id="问：编译时，各种库找不到问题"><a href="#问：编译时，各种库找不到问题" class="headerlink" title="问：编译时，各种库找不到问题"></a>问：编译时，各种库找不到问题</h2><p>答：该问题与上面的 libx264类似，我们可以通过 <code>brew/apt/yum install xxx</code> 命令进行安装，一般情况下这种方式都可以满足我们的需求。如果始终不行的话，就需要源码安装了。源码安装的方法可以参见 <a href="https://www.imooc.com/article/247113" target="_blank" rel="noopener">Windows下编译ffmpeg问题</a> 里的说明。</p>
<h2 id="问：ffmpeg如何使用-libx265"><a href="#问：ffmpeg如何使用-libx265" class="headerlink" title="问：ffmpeg如何使用 libx265"></a>问：ffmpeg如何使用 libx265</h2><p>答：准确的讲ffmpeg应该是一个音视频框架，所有的音视频编解码器都是以插件的方式与ffmpeg联系起来的。换句话说，ffmpeg在上层提供了统一的 API，无法你使用的编解决是 x264, open264, x265, vp8/vp9/av1 上层用户都不管心，它仍然使用同样的 API， 只是在find_decoder 或 find_encoder时，指定具体的编解码器就可以了。也就是说在find_xxx时，你要设置了 x264 它最终就会调用 x264进行编解码，设置了 x265它就使用 x265进行编解码。如些而已。</p>
<h2 id="问：这门课有群吗？"><a href="#问：这门课有群吗？" class="headerlink" title="问：这门课有群吗？"></a>问：这门课有群吗？</h2><p>答：有的，群号：883069602，不过<a href="https://coding.imooc.com/class/279.html?mc_marking=59c321c0417e144904c49c366f94dd57&mc_channel=shouji" target="_blank" rel="noopener">需要购买课程</a>后输入验证码才可以进群。大家可以在群里讨论问题，也可以在课程的评论区里搜索答案。目前评论区里已经积累了大量问题的解决方案。</p>
<h2 id="问：为什么我使用课程中的程序无法成功抽取AAC音频？"><a href="#问：为什么我使用课程中的程序无法成功抽取AAC音频？" class="headerlink" title="问：为什么我使用课程中的程序无法成功抽取AAC音频？"></a>问：为什么我使用课程中的程序无法成功抽取AAC音频？</h2><p>答：<a href="https://www.imooc.com/article/254733" target="_blank" rel="noopener">详细回答在这里</a></p>
<h2 id="问：Android播放器例子为什么调API失败"><a href="#问：Android播放器例子为什么调API失败" class="headerlink" title="问：Android播放器例子为什么调API失败"></a>问：Android播放器例子为什么调API失败</h2><p>答：你目前使用的 NDK 版本与我编译时使用的 NDK 版本不一致造成的，换成 NDK10e试试。</p>
<h2 id="问：NDK10e-从哪里下载"><a href="#问：NDK10e-从哪里下载" class="headerlink" title="问：NDK10e 从哪里下载"></a>问：NDK10e 从哪里下载</h2><p>答：可以到<a href="https://developer.android.com/ndk/downloads/older_releases" target="_blank" rel="noopener">这里</a>下载。</p>
<ul>
<li><a href="https://dl.google.com/android/repository/android-ndk-r10e-darwin-x86_64.zip" target="_blank" rel="noopener">mac NDK10e</a></li>
<li><a href="https://dl.google.com/android/repository/android-ndk-r10e-windows-x86.zip" target="_blank" rel="noopener">windows 32 位 NDK10e</a></li>
<li><a href="https://dl.google.com/android/repository/android-ndk-r10e-windows-x86_64.zip" target="_blank" rel="noopener">windows 64位 NDK10e</a></li>
<li><a href="https://dl.google.com/android/repository/android-ndk-r10e-linux-x86_64.zip" target="_blank" rel="noopener">linux NDK10e</a></li>
</ul>
<h2 id="问：NDKr21-从哪里下载"><a href="#问：NDKr21-从哪里下载" class="headerlink" title="问：NDKr21 从哪里下载"></a>问：NDKr21 从哪里下载</h2><p>答：可以到这里下载。</p>
<ul>
<li><a href="https://dl.google.com/android/repository/android-ndk-r21-darwin-x86_64.zip" target="_blank" rel="noopener">mac NDKr21</a></li>
<li><a href="https://dl.google.com/android/repository/android-ndk-r21-windows-x86_64.zip" target="_blank" rel="noopener">windows NDKr21</a></li>
<li><a href="https://dl.google.com/android/repository/android-ndk-r21-linux-x86_64.zip" target="_blank" rel="noopener">linux NDKr21</a></li>
</ul>
<h2 id="问：ffmpeg安装好后，编译视频中的ffmpeg-log不成功"><a href="#问：ffmpeg安装好后，编译视频中的ffmpeg-log不成功" class="headerlink" title="问：ffmpeg安装好后，编译视频中的ffmpeg_log不成功"></a>问：ffmpeg安装好后，编译视频中的ffmpeg_log不成功</h2><p>答：执行下面的命令进行编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -g -o ffmpeg_log ffmpeg_log.c &#96;pkg-config --libs --cflags libavutil&#96;</span><br></pre></td></tr></table></figure>
<p><strong>注意：pkg-confg 前面的符号不是<code>&#39;</code>哟！它是键盘左上角 ESC键下面的键。</strong></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>该文章会不定期更新，我们将一些大家使用<a href="https://coding.imooc.com/class/279.html?mc_marking=59c321c0417e144904c49c366f94dd57&mc_channel=shouji" target="_blank" rel="noopener">ffmpeg</a>常见的问题更新到这里来。</p>
<h2 id="视频课地址"><a href="#视频课地址" class="headerlink" title="视频课地址"></a>视频课地址</h2><p><a href="https://www.imooc.com/u/4873493/courses?sort=publish" target="_blank" rel="noopener">课程主页地址</a></p>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
        <tag>音视频</tag>
        <tag>直播</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频系统入门常见问题</title>
    <url>/631d466a/</url>
    <content><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/av_base/question.jpg" alt=""></p>
<p>同学们在学习《音视频课小白系统入门》这门课的过程中，经常遇到一些问题，如Mac系统下为什么无法编译ffmpeg? Xcode编译课程中的程序为什么不成功? 为什么我从设备中读的数据很小?等等不足而一。</p>
<p>实际上，大部分同学提出的问题都是重复的。因此，我将一些最常见的问题整理出了答案放在这里，同学们可以根据自己的情况去查找相应的解决办法，以免我个人原因不能及时回答问题时，给大家的学习造成麻烦和不便。</p>
<a id="more"></a>

<h2 id="Q-在-Mac-10-15-3-系统下编译-ffmpeg-成功后，在运行-ffmpeg-命令时出现crash"><a href="#Q-在-Mac-10-15-3-系统下编译-ffmpeg-成功后，在运行-ffmpeg-命令时出现crash" class="headerlink" title="Q: 在 Mac 10.15.3 系统下编译 ffmpeg 成功后，在运行 ffmpeg 命令时出现crash."></a>Q: 在 Mac 10.15.3 系统下编译 ffmpeg 成功后，在运行 ffmpeg 命令时出现crash.</h2><p>A: 重新编译ffmpeg，在执行 ./configure 时增加 –extra-cflags=”fno-static-check” 选项，注意该选项一定要放在前面，否则编译有问题。</p>
<h2 id="Q-在Mac下添加-–extra-cflags-”fno-static-check”-选项仍然-crash"><a href="#Q-在Mac下添加-–extra-cflags-”fno-static-check”-选项仍然-crash" class="headerlink" title="Q: 在Mac下添加 –extra-cflags=”fno-static-check” 选项仍然 crash"></a>Q: 在Mac下添加 –extra-cflags=”fno-static-check” 选项仍然 crash</h2><p>A: 编译时保持尽量少的参数，应该是与其它一些参数有突冲。</p>
<h2 id="Q-无论通过何种方式编译出的ffmpeg都会引发crash，如何解决？"><a href="#Q-无论通过何种方式编译出的ffmpeg都会引发crash，如何解决？" class="headerlink" title="Q: 无论通过何种方式编译出的ffmpeg都会引发crash，如何解决？"></a>Q: 无论通过何种方式编译出的ffmpeg都会引发crash，如何解决？</h2><p>A: 那就只能用命令的方式安装ffmpeg了，执行 <code>brew install ffmpeg</code>即可。</p>
<h2 id="Q-在Mac下，通过命令方式安装的ffmpeg没有带fdk-aac库怎么办"><a href="#Q-在Mac下，通过命令方式安装的ffmpeg没有带fdk-aac库怎么办" class="headerlink" title="Q: 在Mac下，通过命令方式安装的ffmpeg没有带fdk-aac库怎么办?"></a>Q: 在Mac下，通过命令方式安装的ffmpeg没有带fdk-aac库怎么办?</h2><p>A: 以命令方式安装带 fdk-aac 的ffmpeg需要按下面的步骤执行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0. brew unstall ffmpeg</span><br><span class="line">1. brew tap homebrew-ffmpeg&#x2F;ffmpeg</span><br><span class="line">2. brew install homebrew-ffmpeg&#x2F;ffmpeg&#x2F;ffmpeg --with-fdk-aac</span><br></pre></td></tr></table></figure>

<p>注意，安装时如果报<code>ERROR: libsnappy not found</code> 错误，则你需要到<code>https://github.com/google/snappy</code>下载源码，并按照项目的说明编译并安装snappy库。</p>
<p>安装好snappy库后，重新执行<code>brew install homebrew-ffmpeg/ffmpeg/ffmpeg --with-fdk-aac</code>命令。</p>
<h2 id="Q-在Mac下通过命令方式安装ffmpeg库时，如何能带上其它第三方库呢？如x264"><a href="#Q-在Mac下通过命令方式安装ffmpeg库时，如何能带上其它第三方库呢？如x264" class="headerlink" title="Q: 在Mac下通过命令方式安装ffmpeg库时，如何能带上其它第三方库呢？如x264"></a>Q: 在Mac下通过命令方式安装ffmpeg库时，如何能带上其它第三方库呢？如x264</h2><p>A: 与上面安装ffmpeg带fdk-aac库的命令是类似的，命令格式为: <code>brew install ffmpeg --with-xxxx</code>，添加某个库的具体参数可以通过<code>homebrew-ffmpeg/ffmpeg/ffmpeg</code> 来查找。</p>
<h2 id="Q-Xcode-编译课程中的程序成功，但执行失败，报的错误是没有权限该如何解决？"><a href="#Q-Xcode-编译课程中的程序成功，但执行失败，报的错误是没有权限该如何解决？" class="headerlink" title="Q: Xcode 编译课程中的程序成功，但执行失败，报的错误是没有权限该如何解决？"></a>Q: Xcode 编译课程中的程序成功，但执行失败，报的错误是没有权限该如何解决？</h2><p>A:<br><img data-src="https://cdn.avdancedu.com/image/article/av_base/nopriv.jpg" alt=""></p>
<p>如果是上面这种错误信息，解决办法是: 在编译课程中的例子时，先将将沙盒关闭掉，在info.list中增加访问mic phone 访问权限。具体操作如下图所示:</p>
<p><img data-src="https://cdn.avdancedu.com/image/article/av_base/info.jpg" alt=""></p>
<h2 id="Q-info-plist加了权限仍然报没有权限怎么解决？"><a href="#Q-info-plist加了权限仍然报没有权限怎么解决？" class="headerlink" title="Q: info.plist加了权限仍然报没有权限怎么解决？"></a>Q: info.plist加了权限仍然报没有权限怎么解决？</h2><p>A: 按下图操作试试<br><img data-src="https://cdn.avdancedu.com/image/article/av_base/priv2.jpg" alt=""></p>
<h2 id="Q-引入ffmpeg库后，报libavformat-xxx-dylib-未签名，错误信息类似”code-signature…not-valid”"><a href="#Q-引入ffmpeg库后，报libavformat-xxx-dylib-未签名，错误信息类似”code-signature…not-valid”" class="headerlink" title="Q: 引入ffmpeg库后，报libavformat.xxx.dylib 未签名，错误信息类似”code signature…not valid”"></a>Q: 引入ffmpeg库后，报libavformat.xxx.dylib 未签名，错误信息类似”code signature…not valid”</h2><p>A:<br><img data-src="https://cdn.avdancedu.com/image/article/av_base/unsigned.jpg" alt=""><br>如果像上图所展示的一样，则按下面步骤操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 打开 Mac 中的 keychain Access.app, 选择“我的证书”</span><br><span class="line">2. 执行 codesign -f -s &quot;证书名&quot; xxx.dylib</span><br><span class="line">3. 为了避免逐个签名，可以进行批量操作 codesign -f -s &quot;证书名&quot; &#x2F;usr&#x2F;local&#x2F;ffmpeg&#x2F;lib&#x2F;*.dylib</span><br></pre></td></tr></table></figure>

<h2 id="Q-ffmpeg-执行时提示没有权限执行ffmpeg"><a href="#Q-ffmpeg-执行时提示没有权限执行ffmpeg" class="headerlink" title="Q: ffmpeg 执行时提示没有权限执行ffmpeg"></a>Q: ffmpeg 执行时提示没有权限执行ffmpeg</h2><p>A: 将目录切换到你自己的用户目录下再执行ffmpeg试试。</p>
<h2 id="Q-在Linux虚似机中每次获取的音频数据很小，只有64个字节，如果进行重采样？"><a href="#Q-在Linux虚似机中每次获取的音频数据很小，只有64个字节，如果进行重采样？" class="headerlink" title="Q: 在Linux虚似机中每次获取的音频数据很小，只有64个字节，如果进行重采样？"></a>Q: 在Linux虚似机中每次获取的音频数据很小，只有64个字节，如果进行重采样？</h2><p>A: ffmpeg中最低采样个数为32个，所以只有 64 字节数据时，是无进行重采样的。解决办法是将数据放到一个缓冲区中，积攒到一定大小后，再进行重采样。</p>
<h2 id="Q-在从设备采体音频数据时，返回错误-35"><a href="#Q-在从设备采体音频数据时，返回错误-35" class="headerlink" title="Q: 在从设备采体音频数据时，返回错误 -35"></a>Q: 在从设备采体音频数据时，返回错误 -35</h2><p>A: 说明你的设备现在暂时还没准备好，此时你应该等待它几秒，之后就可以正常读数据了。例如：<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while(re&#x3D;av_read_frame(...))&#123;</span><br><span class="line">   if(ret&#x3D;&#x3D;-35) &#123;</span><br><span class="line">       sleep(1);</span><br><span class="line">       continue;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Q-在编码时，编码器返回-35-错误"><a href="#Q-在编码时，编码器返回-35-错误" class="headerlink" title="Q: 在编码时，编码器返回 -35 错误"></a>Q: 在编码时，编码器返回 -35 错误</h2><p>A: 此时说明编码器没有准备好，像上面的一样需要等待一会儿。</p>
<h2 id="Q-采集到的音频数据编码-AAC-时，报无法找到libfdk-aac库"><a href="#Q-采集到的音频数据编码-AAC-时，报无法找到libfdk-aac库" class="headerlink" title="Q: 采集到的音频数据编码 AAC 时，报无法找到libfdk-aac库"></a>Q: 采集到的音频数据编码 AAC 时，报无法找到libfdk-aac库</h2><p>A: 如果是通过命令安装的ffmepg，则上面已经给了答案。下面的方案是通过源码编译出带fdk-aac的ffmeg。具体步骤如下： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 安装好 fdk-aac库</span><br><span class="line">2. 重新在ffmpeg源码目录下执行.&#x2F;configure 并增加--enable-libfdk-aac 参数</span><br><span class="line">3. make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<h2 id="Q-在Linux中何采集音频数据"><a href="#Q-在Linux中何采集音频数据" class="headerlink" title="Q: 在Linux中何采集音频数据"></a>Q: 在Linux中何采集音频数据</h2><p>A: ffmpeg -f alsa -i hw:0,0 xxx.wav</p>
<h2 id="Q-在-Linux-中找不到-alsa-设备"><a href="#Q-在-Linux-中找不到-alsa-设备" class="headerlink" title="Q: 在 Linux 中找不到 alsa 设备"></a>Q: 在 Linux 中找不到 alsa 设备</h2><p>A：可以通过 arecord -l 查看你linux系统下有哪些音频设备。如果没有alsa, 可以使用  oss.</p>
<h2 id="Q-编译ffmpeg-时-filter-编译不过"><a href="#Q-编译ffmpeg-时-filter-编译不过" class="headerlink" title="Q: 编译ffmpeg 时 filter 编译不过"></a>Q: 编译ffmpeg 时 filter 编译不过</h2><p>A：选择使用 libstdc++ 库试试</p>
<h2 id="Q-Windows下编译ffmpeg"><a href="#Q-Windows下编译ffmpeg" class="headerlink" title="Q: Windows下编译ffmpeg"></a>Q: Windows下编译ffmpeg</h2><p>A:  <a href="https://trac.ffmpeg.org/wiki/CompilationGuide/MinGW" target="_blank" rel="noopener">https://trac.ffmpeg.org/wiki/CompilationGuide/MinGW</a></p>
<h2 id="Q-AAC-编码为-AAC-HE-V2-时，声音与原始声音不一样"><a href="#Q-AAC-编码为-AAC-HE-V2-时，声音与原始声音不一样" class="headerlink" title="Q: AAC 编码为 AAC_HE_V2 时，声音与原始声音不一样"></a>Q: AAC 编码为 AAC_HE_V2 时，声音与原始声音不一样</h2><p>A：这是因为老师用的 AAC 版本比较老，老版本的 AAC 与新版本的 AAC 可能有一些差异，这个我会后面查找一下原因。大家测试时可以将profile修改为 AAC HE 或 AAC LC，这样就可以正常编码出 AAC 数据了。</p>
<h2 id="Q-库已经安装好了，但仍报找不到它的错误？"><a href="#Q-库已经安装好了，但仍报找不到它的错误？" class="headerlink" title="Q: 库已经安装好了，但仍报找不到它的错误？"></a>Q: 库已经安装好了，但仍报找不到它的错误？</h2><p>A：首先确认是否已经将 <code>pkg-config</code>工具安装好了。可以执行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pkg-config</span><br></pre></td></tr></table></figure>
<p>如果提示没有安装，则先将该工具安装好，安装命令如下：</p>
<ul>
<li>ubuntu  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt intall pkg-config</span><br></pre></td></tr></table></figure></li>
<li>mac  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install pkg-config</span><br></pre></td></tr></table></figure></li>
<li>cygwin  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-cyg install pkg-config</span><br></pre></td></tr></table></figure></li>
<li>centos  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install pkg-config</span><br></pre></td></tr></table></figure>
安装完该工具后仍然报错？那再按照具体的错误看下面的解决方案吧。</li>
</ul>
<h2 id="Q-libx264库找不到（-ERROR-libx264-not-found-）"><a href="#Q-libx264库找不到（-ERROR-libx264-not-found-）" class="headerlink" title="Q: libx264库找不到（[ERROR: libx264 not found]）"></a>Q: libx264库找不到（[ERROR: libx264 not found]）</h2><p>A:<br>该问题可能由下面三个方面的问题引起。</p>
<ul>
<li>libx264库没有安装。对于这种情况有两种解决办法:<ul>
<li>其一，是通过平台的安装工作进行安装，如 apt/brew/yum install x264。（注：在Linux下应该安装 libx264-dev）。</li>
<li>其二，是通过源码安装，步骤如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. wget https:&#x2F;&#x2F;code.videolan.org&#x2F;videolan&#x2F;x264&#x2F;-&#x2F;archive&#x2F;master&#x2F;x264-master.tar.bz2</span><br><span class="line">2. bunzip2 last_x264.tar.bz2</span><br><span class="line">3. tar -vxf last_x264.tar</span><br><span class="line">4. .&#x2F;configure --enable-static --enable-shared --disable-asm --disable-avs</span><br><span class="line">5. make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>通过 pkg-config 命令无法找到。对于这类问题，我们可以使用下面的命 <code>pkg-config --cflags --lib libx264</code>看是否可以找到 libx264，如果找不到，就说明确实是这个问题。解决的办法是设置环境变量。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PKG_CONFIG_PATH&#x3D;$PKG_CONFIG_PATH:&#x2F;xxx&#x2F;xxx&#x2F;lib&#x2F;pkgconfig</span><br></pre></td></tr></table></figure>
其中 <code>xxx</code> 由你的实际路径代替。</li>
</ul>
<blockquote>
<p>注，有可能你的系统中并没有装 pkg-config工具，可以使用 brew/apt/yum install pkg-config进行安装。</p>
</blockquote>
<ul>
<li>无法链接上libx264, 这是由于通过环境变量 LD_LIBRARY_PATH 无法定位到 libx264库。解决的办法也很简单，与上面类似，可以通过设置环境变量来解决该问题。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export LD_LIBRARY_PATH&#x3D;$LIB_LIBRARY_PATH:&#x2F;xxx&#x2F;xxx&#x2F;lib</span><br></pre></td></tr></table></figure>
其中，<code>xxx</code>由你的实际路径代替。</li>
</ul>
<p>当然，你也可以将环境变量设置在脚本里，这样就不用每次都写export命令了。只需要将上面的两条语句加入到 ~/.bashrc / 或~/.bash_profile 文件里，然后在控制台执行 <code>source ~/.bashrc</code> 或 <code>source ~/.bash_profile</code>即可。</p>
<h2 id="Q-通过-avcodec-find-encoder-by-name-无法找到编码器"><a href="#Q-通过-avcodec-find-encoder-by-name-无法找到编码器" class="headerlink" title="Q: 通过 avcodec_find_encoder_by_name() 无法找到编码器"></a>Q: 通过 avcodec_find_encoder_by_name() 无法找到编码器</h2><p>A：通过以下步骤进行解决</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0. 你使用的ffmpeg必须是经过源码编译的</span><br><span class="line">1. 你在编译 ffmpeg 时，执行.&#x2F;configure时是否将此编码器模块添加到 ffmpeg中了？以 fdk_aac 为例，在执行 .&#x2F;configure …时你应该加上 --enable-libfdk-aac 选项。</span><br><span class="line">2. 如果通过源码编译ffmpeg时有报错，请根据错误信息查看本文档的相应处理方法</span><br><span class="line">3. 确保 pkg-config 命令查询到的是你通过源码编译的ffmpeg库</span><br></pre></td></tr></table></figure>

<h2 id="Q-编译不出ffplay"><a href="#Q-编译不出ffplay" class="headerlink" title="Q: 编译不出ffplay"></a>Q: 编译不出ffplay</h2><p>A：引起该问题有以下几方面的原因：</p>
<ul>
<li>所使用的操作系统没有安装图形库。如有的同学在阿里的云服务器上想安装ffplay是肯定不行的。</li>
<li>没有安装 SDL2 库。解决办法是通过 brew/apt/yum install sdl2 即可 或 通过 SDL2 源码安装。<strong>安装完成后，要重新进行到 ffmpeg目录下，执行 ./configure…这指命令。</strong></li>
<li>有的同学编译ffmpeg时，在ffmpeg目录执行./configure …时没有添加 –enable-sdl2 选项也会导致无法编译出 ffplay</li>
<li>SDL2与最新的Mac系统 mojave不兼容。解决办法：<ul>
<li>方法一<ul>
<li>从 <a href="https://www.libsdl.org/tmp/release/SDL2-2.0.9.tar.gz" target="_blank" rel="noopener">SDL</a>下载 2.0.9版本或以后的SDL2代码。</li>
<li>执行 ./configure</li>
<li>执行 make &amp;&amp; sudo make install</li>
<li>执行 export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig</li>
<li>[重新]编译ffmpeg</li>
</ul>
</li>
<li>方法二<ul>
<li>从<a href="https://www.libsdl.org/tmp/release/SDL2-2.0.9.dmg" target="_blank" rel="noopener">SDL</a>下载dmg包。</li>
<li>执行 open SDL2-2.0.9.dmg</li>
<li>[重新]编译ffmpeg</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Q-非Mac同学如何学习本课程"><a href="#Q-非Mac同学如何学习本课程" class="headerlink" title="Q: 非Mac同学如何学习本课程"></a>Q: 非Mac同学如何学习本课程</h2><p>A：本课程中的例子的界面是由 Swift 编写的，如果你没有 Mac 系统的话，你可以用 Qt 甚至不用界面开发，代码中与ffmpeg相着的代码都是跨平台的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://coding.imooc.com/class/415.html?mc_marking=b587280c0c1c0e76c1092aa21406565a&mc_channel=syb6" target="_blank" rel="noopener">音视频小白系统入门课</a></p>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
        <tag>音视频</tag>
        <tag>直播</tag>
      </tags>
  </entry>
  <entry>
    <title>janus的videoroom插件</title>
    <url>/bb906872/</url>
    <content><![CDATA[<p><img data-src="http://cdn.avdancedu.com/image/article/videoroom/videoroom.jpg" alt="videoroom"></p>
<p>在Janus的众多插件中，大家最感兴趣的恐怕就是<code>VideoRoom</code>插件了。因为它实现的是一个音视频会议的场景，这正是大多数同学所需要的。而且在Janus众多的插件中<code>VideoRoom</code>应该也是最复杂的一个，如果你们撑握了它，再去看其它插件的实现就容易多了。</p>
<p>在<code>VideoRoom</code>中，包括了很多API，这些API是我们打开<code>VideoRoom</code>的一把钥匙，所以本文的重点就是讲解这些API。我相信当你把这些API都撑握之后，再去看<code>VideoRoom</code>插件的代码时就会更加游刃有余了。</p>
<a id="more"></a>

<h2 id="VideoRoom插件"><a href="#VideoRoom插件" class="headerlink" title="VideoRoom插件"></a>VideoRoom插件</h2><p><code>VideoRoom</code>是Janus的一个插件，实现了一个SFU（Selective Forwarding Unit）型的音视频会议。如果你从数据转发的角度看，也可以把它认为是一个音视频<code>路由器</code>。</p>
<p><code>VideoRoom</code>实现的音视频会议是基于<code>发布/订阅</code>模式。每个<code>参与方</code>都可以发布自己的实时音视频流，因此它可以实现几种不同的场景，比如泛娱乐化直播或多人的实时互动产品(如音视频会议、在线教育小班课等）。</p>
<p>考虑到此插件允许一个<code>参与方</code>可以打开多个WebRTC <code>PeerConnection</code>（如每个<code>参与方</code>可以有1个用于推流的<code>PeerConnection</code>和N个拉流的<code>PeerConnection</code>），所以每个<code>参与方</code>需要为订阅不同的流<code>attach</code>到<code>VideoRoom</code>插件几次(每<code>attach</code>一次就会生成一个<code>Handle</code>，每个<code>Handle</code>就是一个上下文)。</p>
<p>因此，对于每个<code>参与方</code>至少要有一个<code>Handle</code>用于管理与插件的关系（如加入一个房间，离开一个房间，静音/取消静音，发布，接收事件）。</p>
<p>每当<code>参与方</code>需要订阅另一个参与方发布的音视频流时，它需要创建一个新的<code>Handle</code>。新创建的<code>Handle</code>在逻辑上属于<strong>“从”</strong><code>Handle</code>，它不能像<strong>“主”</strong><code>Handle</code>一样可以做取消房间静音这样的操作。因此，<strong>从</strong><code>Handle</code>唯一目的是提供一个上下文，在该上下文中创建一个<code>recvonly</code>类型的<code>PeerConnection</code>来订阅发布者的音视频流。</p>
<p>通过上面的描述我们可以知道，主Handle用于管理，而从Handle用于订阅音视频流。</p>
<blockquote>
<p>注意，现在<code>WebRTC</code>已经实现了SSRC复用（Unified Plan），这意味着你可以使用相同的<code>Janus Handle</code> 和<code>PeerConnection</code>同时接收多路音视频流。</p>
</blockquote>
<p>VideoRoom插件功能非常强大，也很灵活，它有很多的配置项，你可以通过<code>conf/janus.plugin.videoroom.jcfg</code>来修改它们。当然Janus也支持动态API修改配置，如通过API创建房间等。</p>
<p>要增加更多房间或修改现有房间信息，你可以向Janus发送下面格式的请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">room- &lt;唯一的房间ID&gt;：&#123;</span><br><span class="line">        description &#x3D; 房间的描述信息</span><br><span class="line">        is_private &#x3D; true | false（是否是私有房间? 如果创建的是私有房间，则无法通过list指令进行查看）</span><br><span class="line">        secret &#x3D; &lt;可选项，操作房间所需的密码，如果设置了，则像做销毁房间这样的操作时你要带上它才行&gt;</span><br><span class="line">        PIN &#x3D; &lt;可选项，加入会议房间的密码&gt;</span><br><span class="line">        require_pvtid &#x3D; true | false（是否订阅音视频流时，需要提供一个与发布者相关的有效private_id， 默认为false）</span><br><span class="line">        publishers &#x3D;  &lt;房间内发布者的最大数&gt;（例如，一个视频会议可以有6个发布者，而广播只有一个，默认&#x3D; 3）</span><br><span class="line">        bitrate &#x3D; &lt;房间里发布者发送数据的最大比特率&gt;（例如128000）</span><br><span class="line">        fir_freq &#x3D; &lt;向发布者发送FIR指令的频率&gt;（0 &#x3D;禁用）</span><br><span class="line">        audiocodec &#x3D; opus | g722 | pcmu | pcma | isac32 | isac16（发布者可以使用的音频编解码器列表，默认为opus。编码器按优先顺序以逗号分隔）</span><br><span class="line">        videocodec &#x3D; vp8 | vp9 | h264 | av1 | h265（发布者可以使用的视频编解码器列表，默认为vp8。可以按优先级顺序用逗号分隔，例如，vp9，vp8，h264）</span><br><span class="line">        vp9_profile &#x3D; VP9首选的profile(&quot;2&quot; 表示 &quot;profile-id &#x3D; 2&quot; ）</span><br><span class="line">        h264_profile &#x3D; H.264首选的profile（&quot;42e01f&quot; 表示 &quot;profile-level-id &#x3D; 42e01f&quot; ）</span><br><span class="line">        opus_fec &#x3D; true | false（是否使用带内FEC；仅适用于Opus，默认为false）</span><br><span class="line">        video_svc &#x3D; true | false（是否启用SVC支持；仅适用于VP9，默认为false）</span><br><span class="line">        audiolevel_ext &#x3D; true | false（对于发布者是否使用RTP扩展ssrc-audio-level？默认为 true）</span><br><span class="line">        audiolevel_event &#x3D; true | false（是否将audiolevel事件发送给其他用户）</span><br><span class="line">        audio_active_packets &#x3D; 100（音频保活包个数，默认值&#x3D; 100，2秒）</span><br><span class="line">        audio_level_average &#x3D; 25（音频音量级别的平均值，127 &#x3D;静音，0 &#x3D;&#39;太大声&#39;，默认&#x3D; 25）</span><br><span class="line">        videoorient_ext &#x3D; true | false（发布者是否使用RTP扩展video-orientation? 默认&#x3D; true）</span><br><span class="line">        playoutdelay_ext &#x3D; true | false（发布者是否使用RTP扩展playout-delay? 默认&#x3D; true）</span><br><span class="line">        transport_wide_cc_ext &#x3D; true | false（发布者是否使用RTP扩展 transport-wide-cc? 默认&#x3D; true）</span><br><span class="line">        record &#x3D; true | false（该房间是否启录制？默认&#x3D; false）</span><br><span class="line">        rec_dir &#x3D; &lt;启用录制后，录制文件存放的目录&gt;</span><br><span class="line">        lock_record &#x3D; true | false（是否锁定录制状态? 默认&#x3D; false）</span><br><span class="line">        notify_joining &#x3D; true | false（可选，当有新的参与方加入房音后，是否通知房间里的所有参与者?</span><br><span class="line">                                       Videoroom插件默认仅通知发布者，启用此功能可能会导致额外的通知传输。</span><br><span class="line">                                       该功能与require_pvtid一起启用时，对管理员管理仅收听的参与者特别有用。默认&#x3D; false）</span><br><span class="line">        require_e2ee &#x3D; true | false（是否启用端到端加密? 默认&#x3D; false）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Video-Room-可以使用的API"><a href="#Video-Room-可以使用的API" class="headerlink" title="Video Room 可以使用的API"></a>Video Room 可以使用的API</h2><p><code>VideoRoom</code> 插件支持很多API。这些API中，一些是同步请求，一些则是异步请求。但无论是同步还是异步请求，当遇到无效的JSON格式或无效的请求时，都使用同步进行错误响应。</p>
<p>接下来，我们首先看看都有那些同步请求API。<code>create</code>，<code>destroy</code>，<code>edit</code>，<code>exists</code>，<code>list</code>，<code>allowed</code>，<code>kick</code>和<code>listparticipants</code>是同步请求API。<code>create</code>允许您动态创建一个新的音视频房间；<code>edit</code>允许您动态编辑房间的属性（例如 修改PIN码）；<code>destroy</code>首先释放视频资源，然后踢除房间里的所有用户，最后销毁音视频房间；<code>exists</code>检查指定的音视频房间是否存在；<code>list</code>列出所有有效的音视频房间; <code>listparticipants</code>列出指定房间中所有激活的参与者及其详细信息。</p>
<p>异步请求API有：<code>join</code>，<code>joinandconfigure</code>，<code>configure</code>，<code>publish</code>，<code>unpublish</code>，<code>start</code>，<code>pause</code>，<code>switch</code>和<code>leave</code>。<code>join</code>允许你加入指定的音视频房间；<code>configure</code>可用于修改某些属性（例如，比特率范围）；<code>joinandconfigure</code>的含义是将前两个请求合并为一个请求（该请求仅适用于发布者）；<code>publish</code>发布媒体流给所有订阅者; <code>unpublish</code>正好与<code>publish</code>相反；<code>start</code>允许你开始接收订阅的媒体流；<code>pause</code>暂停发送媒体流；<code>switch</code>更改指定<code>PeerConnection</code>的媒体源（例如，你正在看A，现在改为看B），但无需为此创建新的Handle；<code>leave</code>离开视频房间。</p>
<p>下面咱们对上面提到的API做一下详细分析，首先看一下<code>create</code>API，它用于创建新的音视频房间，其格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;create&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;可选，房间ID。如果不填，则由插件随机生成&gt;，</span><br><span class="line">        &quot;permanent&quot;：&lt;true | false，是否创建永久房间，默认&#x3D; false&gt;，</span><br><span class="line">        &quot;description&quot;：&quot;&lt;可选，房间的名称&gt;&quot;，</span><br><span class="line">        &quot;secret&quot;：&quot;&lt;可选，编辑&#x2F;销毁房间时用的密码&gt;&quot;，</span><br><span class="line">        &quot;pin&quot;：&quot;&lt;可选，加入房间的密码&gt;&quot;，</span><br><span class="line">        &quot;is_private&quot;：&lt;true | false，是否是私有房间？如果是私有房间则不会出现在房间列表中&gt;，</span><br><span class="line">        &quot;allowed&quot;：[可选，用户加入房间的token数组]，</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的说明已经非常清楚了，这里我就不做简赘述了。</p>
<p>如果<code>create</code>成功，则会返回<code>created</code>响应，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：“created&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;permanent&quot;：&lt;是否是创建的永久房间？是则为true，否则为false&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，如果你请求创建一个永久房间，但<code>permanet</code>返回的是false，很可能是因为权限的问题导致的。</p>
</blockquote>
<p>如果<code>create</code>请求失败，则返回错误信息，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;error_code&quot;：&lt;错误码，每个错误码的含义需要看插件实现代码中的宏定义&gt;，</span><br><span class="line">        &quot;error&quot;：&quot;&lt;错误描述字符串&gt;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里需要注意的是，所有请求的错误响应格式都与上面一样。</p>
</blockquote>
<p>默认情况下，所有用户都可以创建房间，但你可以通过在<code>VideoRoom</code>插件的配置文件中增加<code>admin_key</code>项来限制此功能。此时，只有带了正确的<code>admin_key</code>值的<code>create</code>请求才能成功创建房间。你也可以选择将此功能扩展到RTP转发，只转发受信任的客户端的RTP包。</p>
<p>房间创建好后，您可以用<code>edit</code>API编辑其中的部分（但不是全部）属性。<code>edit</code>允许你修改房间描述，密码，PIN码以及是否为私有。但你将无法修改他的静态属性，例如房间ID，采样率，与扩展相关的内容等。如果你有兴趣更改ACL，还需要查看<code>allowed</code>是否允许。</p>
<p>一个<code>edit</code>请求格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;edit&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;secret&quot;：&quot;&lt;房间密码&gt;&quot;，</span><br><span class="line">        &quot;new_description&quot;：&quot;&lt;房间的新名称，可选&gt;&quot;，</span><br><span class="line">        &quot;new_secret&quot;：&quot;&lt;房间的新密码，可选&gt;&quot;，</span><br><span class="line">        &quot;new_pin&quot;：&quot;&lt;新PIN码，可选&gt;&quot;，</span><br><span class="line">        &quot;new_is_private&quot;：&lt;true | false，房间是否为私有房间?&gt;，</span><br><span class="line">        &quot;new_require_pvtid&quot;：&lt;true | false，房间是否要求订阅者提供private_id&gt;，</span><br><span class="line">        &quot;new_bitrate&quot;：&lt;比特率&gt;，</span><br><span class="line">        &quot;new_fir_freq&quot;：&lt;发送PLI请求关键帧的时间间隔&gt;，</span><br><span class="line">        &quot;new_publishers&quot;：&lt;房间里发布者的最大数&gt;，</span><br><span class="line">        &quot;new_lock_record&quot;：&lt;true | false，如否可以改变录制状态&gt;，</span><br><span class="line">        &quot;permanent&quot;：&lt;true | false，该房间是否是永久房间？默认&#x3D; false&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>edit</code>请求成功，刚收到<code>edited</code>响应：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;edited&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们来看看<code>destroy</code>API，无论你是通过动态创建的还是静态创建的房间，均可使用<code>destroy</code>销毁它，其格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;destroy&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;secret&quot;：&quot;&lt;房间密码&gt;&quot;，</span><br><span class="line">        &quot;permanent&quot;：&lt;true | false，是否是永久房间，默认&#x3D; false&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成功销毁房间后将收到<code>destroyed</code>响应，其格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;destroyed&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>销毁房间后，在房间内的所有参与者都会收到<code>destroyed</code>事件，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;destroyed&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Janus中还提供了<code>exists</code>API，来检查房间是否存在，该请求的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;exists&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请求成功将收到success响应：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：“success&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        “exists&quot;：&lt;true | false 房间是否存在&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>allowed</code>API可以打开/关闭对令牌的检测，它还可以增加/删除允许的用户，其请求格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;allowed&quot;，</span><br><span class="line">        &quot;secret&quot;：&quot;&lt;房间密码，如果已配置，则是必需的&gt;&quot;，</span><br><span class="line">        &quot;action&quot;：&quot;enable | disable | add | remove&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;allowed&quot;：[</span><br><span class="line">                &#x2F;&#x2F;字符串数组</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成功请求将返回success响应：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：“success&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        “allowed&quot;：[</span><br><span class="line">                &#x2F;&#x2F;更新后完整的令牌列表</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你是房间管理员（即你创建了该房间并可以加密访问），则你可以使用<code>kick</code>API踢除房间内的用户。</p>
<blockquote>
<p>注意，这只会将用户踢出房间，但并不能阻止他们重新加入。要禁止他们加入，你需要先从授权用户列表中删除他们（请参阅allowed请求），然后再将其踢掉。<code>kick</code>请求的格式如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;kick&quot;，</span><br><span class="line">        &quot;secret&quot;：&quot;&lt;房间密码&gt;&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;id&quot;：&lt;被踢用户ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请求成功将收到success响应：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;success&quot;，</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你还可以通过<code>list</code>API获取可用房间的列表（不包括配置或创建为私有的房间），其格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：“list&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请求成功将返回success响应，响应中会带有有效的房间列表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：“成功&quot;，</span><br><span class="line">        &quot;rooms&quot;：[&#x2F;&#x2F;房间对象数组</span><br><span class="line">                &#123;&#x2F;&#x2F; 第一个房间</span><br><span class="line">                        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">                        &quot;description&quot;：&quot;&lt;房间名称&gt;&quot;，</span><br><span class="line">                        &quot;pin_required&quot;：&lt;true | false，是否需要输入PIN吗才能加入此房间&gt;，</span><br><span class="line">                        &quot;max_publishers&quot;：&lt;房间内发布者最大数量，&gt;</span><br><span class="line">                        &quot;bitrate&quot;：&lt;发布者使用的（通过REMB）比特率上限&gt;，</span><br><span class="line">                        &quot;bitrate_cap&quot;：&lt;true | false，上述上限是否可以动态更改?&gt;，</span><br><span class="line">                        &quot;fir_freq&quot;：&lt;发送PLI&#x2F;FIR请求关键帧的时间间隔&gt;，</span><br><span class="line">                        &quot;audiocodec&quot;：&quot;&lt;音频编解码器列表，每个编码器以逗号分隔&gt;&quot;，</span><br><span class="line">                        &quot;videocodec&quot;：&quot;&lt;视频编解码器列表，每个编码器以逗号分隔&gt;&quot;，</span><br><span class="line">                        &quot;record&quot;：&lt;true | false，是否打开了录制功能&gt;，</span><br><span class="line">                        &quot;record_dir&quot;：&quot;&lt;如果开启了录掉，.mjr文件保存的路径&gt;&quot;，</span><br><span class="line">                        &quot;lock_record&quot;：&lt;true | false，是否只能通过密码才能更改房间记录状态&gt;，</span><br><span class="line">                        &quot;num_participants&quot;：&lt;房间内参与人的个数&gt;</span><br><span class="line">                &#125;，</span><br><span class="line">                &#x2F;&#x2F;其他房间</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，你要获取特定房间中的参与者列表，可以使用<code>listparticipants</code>请求，其格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;listparticipants&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请求成功将返回一个<code>participants</code>响应：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;participants&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        “participants&quot;：[&#x2F;&#x2F;参与者对象的数组</span><br><span class="line">                &#123;&#x2F;&#x2F;参与者＃1</span><br><span class="line">                        &quot;id&quot;：&lt;用户ID&gt;，</span><br><span class="line">                        &quot;display&quot;：&quot;&lt;用户名；可选&gt;&quot;，</span><br><span class="line">                        &quot;publisher&quot;：&quot;&lt;true | false，用户是否是房间的发布者&gt;&quot;，</span><br><span class="line">                        &quot;talking&quot;：&lt;true | false，用户是否可以说话（仅当使用音频级别时）&gt;</span><br><span class="line">                &#125;，</span><br><span class="line">                &#x2F;&#x2F;其他参与者</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是Janus中的同步API。异步API都是与<code>参与者</code>有关，即<code>参与者</code>如何发布，订阅或管理他们正在发送或接收的媒体流。</p>
<h2 id="VideoRoom-发布者"><a href="#VideoRoom-发布者" class="headerlink" title="VideoRoom 发布者"></a>VideoRoom 发布者</h2><p>在VideoRoom中，<code>发布者</code>是指那些能够在房间中发布<code>媒体流</code>的参与者。</p>
<p>当你以<code>发布者</code>的身份加入到房间里时，您应该发送<code>join</code>请求，并且将ptype设置为<code>publisher</code>。请求的具体格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;join&quot;，</span><br><span class="line">        &quot;ptype&quot;：&quot;pbulisher&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;id&quot;：&lt;发布者ID；可选，如果缺少，将由插件选择&gt;，</span><br><span class="line">        &quot;display&quot;：&quot;&lt;发布者名称；可选&gt;&quot;，</span><br><span class="line">        &quot;token&quot;：&quot;&lt;邀请令牌，如果房间有ACL时需要该字段；可选&gt;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>joid</code>请求成功将收到<code>joined</code>事件，其中包含当前激活的<code>发布者</code>列表，以及任选的<code>参加者</code>列表。<code>joined</code>事件格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;joined&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;description&quot;：&lt;房间名，如果有的话&gt;，</span><br><span class="line">        &quot;id&quot;：&lt;用户ID&gt;，</span><br><span class="line">        &quot;private_id&quot;：&lt;与参与者相关联的不同唯一ID；打算是私人的&gt;，</span><br><span class="line">        “publishers&quot;：[</span><br><span class="line">                &#123;</span><br><span class="line">                        &quot;id&quot;：&lt;活动发布者＃1的唯一ID&gt;，</span><br><span class="line">                        &quot;display&quot;：&quot;&lt;发布者＃1的名称，如果有的话&gt;&quot;，</span><br><span class="line">                        &quot;audio_codec&quot;：&quot;&lt;发布者＃1使用的音频编解码器，如果有的话&gt;&quot;，</span><br><span class="line">                        &quot;video_codec&quot;：&quot;&lt;发布者＃1使用的视频编解码器，如果有的话&gt;&quot;，</span><br><span class="line">                        &quot;simulcast&quot;：&quot;&lt;如果发布者使用simulcast，则为true（仅VP8和H.264）&gt;&quot;，</span><br><span class="line">                        &quot;talking&quot;：&lt;true | false，发布者开启语音聊天（仅在使用音频级别的情况下）&gt;，</span><br><span class="line">                &#125;，</span><br><span class="line">                &#x2F;&#x2F;其他活跃的发布者</span><br><span class="line">        ]，</span><br><span class="line">        &quot;attendees&quot;：[&#x2F;&#x2F;仅当房间的notify_joining设置为TRUE时存在</span><br><span class="line">                &#123;</span><br><span class="line">                        &quot;id&quot;：&lt;与会者＃1的唯一ID&gt;，</span><br><span class="line">                        &quot;display&quot;：&quot;&lt;与会者＃1的名称，如果有的话&gt;&quot;</span><br><span class="line">                &#125;，</span><br><span class="line">                &#x2F;&#x2F;其他参加者</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，如果房间中当前没有人，则<code>发布者</code>列表为空。上面格式中的<code>private_id</code>属性只有在用户订阅时才起作用。</p>
</blockquote>
<p>对于房间里的订阅者来说，会收到<code>event</code>通知。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        “joining&quot;：&#123;</span><br><span class="line">                &quot;id&quot;：&lt;参与者ID&gt;，</span><br><span class="line">                &quot;display&quot;：&quot;&lt;参与者名称&gt;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你想成为<code>发布者</code>，则发送<code>publish</code>请求。该请求必须跟着一个<code>JSEP SDP Offer</code>，用于协商新的<code>PeerConnection</code>。插件会将其与房间配置进行匹配（例如，确保房间中使用协商的编解码器），并使用<code>JSEP SDP answer</code>进行答复从而完成<code>PeerConnection</code>的设置。建立<code>PeerConnection</code>后，发布者立即处于活动状态，其他参与者就可以订阅它发布的流啦。</p>
<p><code>publish</code>请求格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;publish&quot;，</span><br><span class="line">        &quot;audio&quot;：&lt;true | false，是否应该转发音频；默认为true&gt;，</span><br><span class="line">        &quot;video&quot;：&lt;true | false，是否应该转发视频；默认为true&gt;，</span><br><span class="line">        &quot;data&quot;：&lt;true | false，是否应该转发数据；默认为true&gt;，</span><br><span class="line">        &quot;audiocodec&quot;：&quot;&lt;在协商协议中首选的音频编解码器；可选&gt;&quot;，</span><br><span class="line">        &quot;videocodec&quot;：&quot;&lt;在协商协议中首选的视频编解码器；可选&gt;&quot;，</span><br><span class="line">        &quot;bitrate&quot;：&lt;通过REMB返回的比特率上限；可选，如果存在则覆盖全局房间值&gt;，</span><br><span class="line">        &quot;record&quot;：&lt;true | false，是否应该记录此发布者；可选&gt;</span><br><span class="line">        &quot;filename&quot;：&quot;&lt;录制文件名；可选&gt;&quot;，</span><br><span class="line">        &quot;display&quot;：&quot;&lt;用户名称；可选&gt;&quot;，</span><br><span class="line">        &quot;audio_level_average&quot;：&quot;&lt;音频音量平均值，此设置覆盖房间的audio_level_average；可选&gt;&quot;，</span><br><span class="line">        &quot;audio_active_packets&quot;：&quot;&lt;音频保活包数，此设置覆盖房间audio_active_packets；可选&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此请求应该与发布者的<code>JSEP SDP Offer</code>一起提供，插件收到此消息后，将协商与之匹配的<code>JSEP SDP Answer</code>。如果成功，<code>configured</code>事件将被返回，其格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;configured&quot;：“ok&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该事件将与准备好的<code>JSEP SDP Answer</code>一起发送给客户端。</p>
<p>你也可以用<code>configure</code>请求代替<code>publish</code>。两者的功能在<code>发布</code>上是等效的，但从语义的角度来看，<code>publish</code>是发布时要发送的正确消息。<code>configure</code>请求也可以用于更新发布者会话的某些属性，在这种情况下，就不能用<code>publish</code>请求了。</p>
<blockquote>
<p>需要注意的是，如果用户已经发送过<code>publish</code>了，再发送<code>publish</code>将导致失败。</p>
</blockquote>
<p>其实，您可以将<code>join</code>和<code>publish</code>两个API合并为一个API请求。比如你一开始以<code>参与者</code>的身份加入，随后变为<code>发布者</code>，这时你就可以将他们合并。你可以使用<code>joinandconfigure</code>请求来做到这一点，该请求将这两个请求（join与publish)结合在一起。如果成功，则响应一个<code>joined</code>事件，并且将<code>JSEP SDP Answer</code>一起发送出去。</p>
<p>一旦<code>PeerConnection</code>设置成功，且发布者处于激活状态，<code>event</code>就会被发向房间中的所有<code>参与者</code>。其格式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        “publishes&quot;：[</span><br><span class="line">                &#123;</span><br><span class="line">                        &quot;id&quot;：&lt;新发布者的唯一ID&gt;，</span><br><span class="line">                        &quot;display&quot;：&quot;&lt;新发布者的名称，如果有的话&gt;&quot;，</span><br><span class="line">                        &quot;audio_codec&quot;：&quot;&lt;新布者使用的音频编解码器，如果有的话&gt;&quot;，</span><br><span class="line">                        &quot;video_codec&quot;：&quot;&lt;新发布使用的视频编解码器，如果有的话&gt;&quot;，</span><br><span class="line">                        &quot;simulcast&quot;：&quot;&lt;如果发布者使用simucast，则为true（仅VP8和H.264）&gt;&quot;，</span><br><span class="line">                        &quot;talking&quot;：&lt;true | false，发布者是否在讲话（仅在使用音频级别的情况下）&gt;，</span><br><span class="line">                &#125;</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要停止发布并删除相关的<code>PeerConnection</code>，可以使用该<code>unpublish</code>请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：“unpublish&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当插件收到这条请求后，它会删除对应的<code>PeerConnection</code>，并将发布者从活动列表中删除。如果成功，响应如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        “unpublish&quot;：“ok&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当<code>PeerConnection</code>删除后，插件还将向所有其他<code>参与者</code>通知该流不再可用的消息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;unpublished&quot;：&lt;发布者的ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，不光收到<code>unpublish</code>消息会触发上面的事件通知，其实无论什么情况下，只要<code>发布者</code>提供的流消失了（例如，句柄已关闭或用户失去连接），都会发同样的<code>事件</code>。此外，你可以使用同一句柄的上下文多次执行<code>发布</code>或<code>取消发布</code>操作。</p>
</blockquote>
<p>正如我们上面讲过的，你可以使用<code>configure</code>请求调整发布者会话的某些属性。该请求的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;configure&quot;，</span><br><span class="line">        &quot;audio&quot;：&lt;true | false，取决于是否应该转发音频；默认为true&gt;，</span><br><span class="line">        &quot;video&quot;：&lt;true | false，取决于是否应该转发视频；默认为true&gt;，</span><br><span class="line">        &quot;data&quot;：&lt;true | false，取决于是否应该转发数据；默认为true&gt;，</span><br><span class="line">        &quot;bitrate&quot;：&lt;比特率上限；可选，如果存在则覆盖全局房间值（除非设置了bitrate_cap）&gt;，</span><br><span class="line">        &quot;keyframe&quot;：&lt;true | false，是否向发布者发送关键帧请求&gt;，</span><br><span class="line">        &quot;record&quot;：&lt;true | false，是否开启录制；可选&gt;</span><br><span class="line">        &quot;filename&quot;：&quot;&lt;如果开启了录制，指明录制路径&#x2F;文件；可选&gt;&quot;，</span><br><span class="line">        &quot;display&quot;：&quot;&lt;用户名称；可选&gt;&quot;，</span><br><span class="line">        &quot;audio_active_packets&quot;：&quot;&lt;音频保活包个数，audio_active_packets；可选&gt;&quot;，</span><br><span class="line">        &quot;audio_level_average&quot;：&quot;&lt;音频音量平均值，audio_level_average；可选&gt;&quot;，</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>configure</code>基本上与<code>publish</code>的属性相同。这就是为什么两个请求都可以用来开始发布的原因。如果<code>configure</code>成功，则返回<code>configured</code>事件，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;configured&quot;：“ok&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当发送<code>configure</code>请求RTP扩展<code>ssrc-audio-level</code>时，如果<code>audiolevel_event</code>设置为true ，则可能会向所有发布者发送一些临时事件。这些事件将具有以下格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&lt;&quot;talking&quot;|&quot;stopped-talking&quot;，是否发布者开始或停止发言&gt;，</span><br><span class="line">        &quot;room&quot;：&lt;房间的唯一ID&gt;，</span><br><span class="line">        &quot;id&quot;：&lt;发布者的唯一ID&gt;，</span><br><span class="line">        &quot;audio-level-dBov-avg&quot;：&lt;音平音量的平均值，127 &#x3D;静音，0 &#x3D;&#39;太大声&#39;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>VideoRoom</code>插件的主要目的是从WebRTC源(发布者)获取媒体，并将其转发到WebRTC目的地（订阅者），但实际上存在几种方案，可以将媒体转发给外部（不一定与WebRTC兼容）组件。例如，用于媒体处理，外部录制，转码，级联等等。<code>rtp_forward</code>顾名思义，就是将发布者发送的RTP包（普通或加密）实时转发到远程后端。</p>
<p>您可以使用<code>rtp_forward</code>请求为现有发布者添加新的RTP转发器，其格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;rtp_forward&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;publisher_id&quot;：&lt;发布者ID&gt;，</span><br><span class="line">        &quot;host&quot;：&quot;&lt;将RTP和数据包转发到的host主机IP地址&gt;&quot;，</span><br><span class="line">        &quot;host_family&quot;：&quot;&lt;ipv4 | ipv6，使用IPv4还是IPv6；默认情况下，无论我们得到什么&gt;&quot;，</span><br><span class="line">        &quot;audio_port&quot;：&lt;音频RTP数据包转发到的端口&gt;，</span><br><span class="line">        &quot;audio_ssrc&quot;：&lt;音频SSRC，用于流式传输；可选&gt;</span><br><span class="line">        &quot;audio_pt&quot;：&lt;音频有效负载类型；可选&gt;</span><br><span class="line">        &quot;audio_rtcp_port&quot;：&lt;接收方接收音频RTCP反馈端口；可选，当前未用于音频&gt;，</span><br><span class="line">        &quot;video_port&quot;：&lt;将视频RTP数据包转发到的端口&gt;，</span><br><span class="line">        &quot;video_ssrc&quot;：&lt;视频 SSRC；可选&gt;</span><br><span class="line">        &quot;video_pt&quot;：&lt;视频有效载荷类型；可选&gt;</span><br><span class="line">        &quot;video_rtcp_port&quot;：&lt;接收方接收视频RTCP反馈端口；可选&gt;</span><br><span class="line">        &quot;video_port_2&quot;：&lt;如果simulcast，则视频第二个的RTP数据端口&gt;，</span><br><span class="line">        &quot;video_ssrc_2&quot;：&lt;如果simulcast，则视频第二个的SSRC；可选&gt;</span><br><span class="line">        &quot;video_pt_2&quot;：&lt;如果simulcast，则视频第二个的有效载荷类型；可选&gt;</span><br><span class="line">        &quot;video_port_3&quot;：&lt;如果simulcast，则视频第三个RTP数据包端口&gt;，</span><br><span class="line">        &quot;video_ssrc_3&quot;：&lt;如果simulcast，则视频第三个SSRC；可选&gt;</span><br><span class="line">        &quot;video_pt_3&quot;：&lt;如果simulcast，则视频第三个的有效载荷类型；可选&gt;</span><br><span class="line">        &quot;data_port&quot;：&lt;数据通道消息端口&gt;，</span><br><span class="line">        &quot;srtp_suite&quot;：&lt;身份验证标签的长度（32或80）；可选&gt;</span><br><span class="line">        &quot;srtp_crypto&quot;：&quot;&lt;用作加密的密钥（如SDES中的base64编码的密钥；可选&gt;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，如上所述，如果您配置了admin_key属性，则在请求中也需要提供它，否则未授权的请求将被拒绝。默认情况下，没有对rtp_forward进行限制。</p>
</blockquote>
<p>如果请求成功则返回<code>rtp_forward</code>响应，其中格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;rtp_forward&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;publisher_id&quot;：&lt;发布者ID&gt;</span><br><span class="line">        &quot;rtp_stream&quot;：&#123;</span><br><span class="line">                &quot;host&quot;：&quot;&lt;接收流的主机IP，如果未解析，则与请求相同&gt;&quot;，</span><br><span class="line">                &quot;audio&quot;：&lt;音频RTP端口，与请求相同（如果已配置）&gt;，</span><br><span class="line">                &quot;audio_rtcp&quot;：&lt;音频RTCP端口，与请求相同（如果已配置）&gt;，</span><br><span class="line">                &quot;audio_stream_id&quot;：&lt;分配给音频RTP转发器的唯一数字ID，如果有的话，&gt;</span><br><span class="line">                &quot;video&quot;：&lt;视频RTP端口，与请求相同（如果已配置）&gt;，</span><br><span class="line">                &quot;video_rtcp&quot;：&lt;视频RTCP端口，如果配置，则与请求相同，&gt;</span><br><span class="line">                &quot;video_stream_id&quot;：&lt;分配给主视频RTP转发器的唯一数字ID，如果有的话，&gt;</span><br><span class="line">                &quot;video_2&quot;：&lt;第二个视频端口，与请求相同（如果已配置）&gt;，</span><br><span class="line">                &quot;video_stream_id_2&quot;：&lt;分配给第二层视频RTP转发器的唯一数字ID，如果有的话，&gt;</span><br><span class="line">                &quot;video_3&quot;：&lt;第三个视频端口，与请求相同（如果已配置）&gt;，</span><br><span class="line">                &quot;video_stream_id_3&quot;：&lt;分配给第三个视频RTP转发器的唯一数字ID，如果有，&gt;</span><br><span class="line">                &quot;data&quot;：&lt;数据端口，与请求相同（如果已配置）&gt;，</span><br><span class="line">                &quot;data_stream_id&quot;：&lt;分配给数据通道消息转发器的唯一数字ID（如果有）&gt;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要停止以前创建的RTP转发器，可以使用<code>stop_rtp_forward</code>请求，其格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;stop_rtp_forward&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;publisher_id&quot;：&lt;发布者ID&gt;，</span><br><span class="line">        &quot;stream_id&quot;：&lt;RTP转发器ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请求成功，则返回<code>stop_rtp_forward</code>响应：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;stop_rtp_forward&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;publisher_id&quot;：&lt;发布者ID，与请求相同，&gt;</span><br><span class="line">        &quot;stream_id&quot;：&lt;流ID，与请求相同&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要获取特定房间中所有转发器的列表，可以使用<code>listforwarders</code>请求，其格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;listforwarders&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间的唯一数字ID&gt;，</span><br><span class="line">        &quot;secret&quot;：&quot;&lt;房间密码；如果已配置，则是必需的&gt;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请求成功，则返回forwarders响应，其中包括RTP转发器列表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;forwarders&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间的唯一ID&gt;，</span><br><span class="line">        &quot;rtp_forwarders&quot;：[&#x2F;&#x2F;具有RTP转发器的发布者数组</span><br><span class="line">                &#123;&#x2F;&#x2F;发布者＃1</span><br><span class="line">                        &quot;publisher_id&quot;：&lt;发布者＃1的唯一数字ID&gt;，</span><br><span class="line">                        &quot;rtp_forwarders&quot;：[&#x2F;&#x2F; RTP转发器数组</span><br><span class="line">                                &#123;&#x2F;&#x2F; RTP转发器＃1</span><br><span class="line">                                        &quot;audio_stream_id&quot;：&lt;音频RTP转发器的唯一ID，如果有的话&gt;，</span><br><span class="line">                                        &quot;video_stream_id&quot;：&lt;视频RTP转发器的唯一ID，如果有的话&gt;，</span><br><span class="line">                                        &quot;data_stream_id&quot;：&lt;数据通道消息转发器的唯一ID（如果有）&gt;，</span><br><span class="line">                                        &quot;ip&quot;：&quot;&lt;接收端IP&gt;&quot;，</span><br><span class="line">                                        &quot;port&quot;：&lt;接收端端口&gt;，</span><br><span class="line">                                        &quot;rtcp_port&quot;：&lt;接收端RTCP端口，如果有的话&gt;，</span><br><span class="line">                                        &quot;ssrc&quot;：&lt;转发器正在使用的SSRC，如果有的话&gt;，</span><br><span class="line">                                        &quot;pt&quot;：&lt;转发器正在使用的有效负载类型&gt;，</span><br><span class="line">                                        &quot;substream&quot;：&lt;视频子流，如果有&gt;，</span><br><span class="line">                                        &quot;srtp&quot;：&lt;true | false，RTP流是否已加密&gt;</span><br><span class="line">                                &#125;，</span><br><span class="line">                                &#x2F;&#x2F;此发布者的其他转发器</span><br><span class="line">                        ]，</span><br><span class="line">                &#125;，</span><br><span class="line">                &#x2F;&#x2F;其他发布者</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在会议进行期间启用或禁用录制，您可以使用<code>enable_recording</code>请求，该请求的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;enable_recording&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;secret&quot;：&quot;&lt;房间密码；如果已配置，则是必需的&gt;&quot;</span><br><span class="line">        &quot;record&quot;：&lt;true | false，是否自动记录此会议室中的参与者&gt;，</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，参与者通常也可以通过configure请求来更改自己的录制状态：这样做是为了获得最大的灵活性，您可能希望单独记录一些流，而不是全局或自动记录一些内容，到特定文件。就是说，如果你希望确保在启用全局录制后参与者不能停止其录制，或者在不应该录制该会议室的情况下启动它，那么您应该确保在创建会议室时使用lock_record属性，将其设置为true。这样，只有在提供了房间密码的情况下，才能更改录制状态，从而确保只有管理员才能执行此操作。</p>
</blockquote>
<p>最后，您可以使用<code>leave</code>请求离开会议室。如果您是会议室中的活动发布者，这也将隐式取消你的发布。该leave请求如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;leave&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果成功，响应将如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;leave&quot;：&quot;ok&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他参与者将收到”leave”事件，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;leave：&lt;离开的参与者的唯一ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您是活跃的发布者，则其他用户也将收到相应的<code>unpublish</code>事件，以通知他们该流不再可用。如果您只是潜伏而不是发布者，则其他参与者将仅收到”leave”事件。</p>
<h2 id="VideoRoom-订阅者"><a href="#VideoRoom-订阅者" class="headerlink" title="VideoRoom 订阅者"></a>VideoRoom 订阅者</h2><p>订阅者在加入房间时，join请求的ptype属性应该设置为<code>subscriber</code>，并指定要订阅的确切的媒体流。该请求的确切语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;join&quot;，</span><br><span class="line">        &quot;ptype&quot;：&quot;subscriber&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;feed&quot;：&lt;发布者ID；强制性&gt;，</span><br><span class="line">        &quot;private_id&quot;：&lt;发起此请求的用户ID；可选的，除非房间配置要求&gt;</span><br><span class="line">        &quot;close_pc&quot;：&lt;true | false，发布者离开时是否应自动关闭PeerConnection；默认为true&gt;，</span><br><span class="line">        &quot;audio&quot;：&lt;true | false，是否转发音频；默认为true&gt;，</span><br><span class="line">        &quot;video&quot;：&lt;true | false，是否转发视频；默认为true&gt;，</span><br><span class="line">        &quot;data&quot;：&lt;true | false，是否转发数据；默认为true&gt;，</span><br><span class="line">        &quot;offer_audio&quot;：&lt;true | false; 是否应该协商音频；如果发布者的音频&gt;，默认为true</span><br><span class="line">        &quot;offer_video&quot;：&lt;true | false; 是否应该协商视频；如果发布者的视频&gt;，默认为true</span><br><span class="line">        &quot;offer_data&quot;：&lt;true | false; 是否应该协商数据通道；如果发布者的datachannels&gt;为默认值，则为true</span><br><span class="line">        &quot;substream&quot;：&lt;启用了simulcast情况下，要接收的子流（0-2）；可选&gt;</span><br><span class="line">        &quot;temporal&quot;：&lt;启用simulcast情况下，要接收的时间层（0-2）；可选&gt;</span><br><span class="line">        &quot;fallback&quot;：&lt;多少时间（在我们这里，默认为250000）没有接收到数据包将使我们下降到下面的子流&gt;，</span><br><span class="line">        &quot;spatial_layer&quot;：&lt;启用VP9-SVC时要接收的空间层（0-2）；可选&gt;</span><br><span class="line">        &quot;temporal_layer&quot;：&lt;启用VP9-SVC时要接收的时间层（0-2）；可选&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如您所见，只要指定好要订阅的发布者ID，并在需要时指定好<code>private_id</code>(订阅者ID)，其它的都可以不设置。不过请求中的<code>offer_audio</code>，<code>offer_video</code>和<code>offer_data</code>特别有意思，你可以通过它们订阅媒体的一个子集(音频\视频\数据）。</p>
<p>默认情况下，发送<code>join</code>请求时会导致插件层创建<code>SDP Offer</code>，用以协商发布者提供那些媒体。此外，如果发布者发布的是<code>simulcast</code>或<code>VP9 SVC</code>，那么你还可以订阅你感兴趣的子流，例如，获得最佳质量的中间质量。更有意思的是，你可以使用<code>configure</code>请求随时动态更改这些设置。</p>
<p>上面的请求如果成功，将生成一个新的<code>JSEP SDP Offer</code>，并伴随一个attached事件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;attached&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;feed&quot;：&lt;发布者ID&gt;，</span><br><span class="line">        &quot;display&quot;：&quot;&lt;发布者的名称，如果有的话&gt;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此阶段，为了完成<code>PeerConnection</code>的设置，订阅者应将<code>JSEP SDP Answer</code>发送回插件。此操作是通过<code>start</code>请求来完成的，在这种情况下，请求必须与<code>JSEP SDP Answer</code>相关联，但是不需要任何参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：“start&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果成功，此请求将返回一个started事件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;started&quot;：&quot;ok&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成此操作后，所需要做的就是等待WebRTC <code>PeerConnection</code>建立成功。一旦<code>PeerConnection</code>建立成功，Streaming插件就可以开始向订阅的观众转发媒体了。</p>
<blockquote>
<p>注意，在需要重新协商（例如出于ICE重启目的）的情况下，您也可以使用我们刚经历的相同步骤（watch请求，然后插件创建<code>JSEP Offer</code>，最后客户端发送<code>start</code>请求和<code>JSEP Answer</code>）。</p>
</blockquote>
<p>作为<code>订阅者</code>，您可以发送<code>pause</code>临时暂停或发送<code>start</code>恢复整个媒体的传送（在这种情况下，不附带任何JSEP SDP Answer）。因为上下文中已经有了相关信息，所以不需要重新进行协商。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;pause&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;start&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，它们会分别导致paused和started事件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;paused&quot;：&quot;ok&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;started&quot;：&quot;ok&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>configure</code>请求可以对<code>订阅</code>做更多深入操作。该请求允许<code>订阅者</code>动态更改与媒体订阅有关的某些属性，<code>configure</code>请求的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;configure&quot;，</span><br><span class="line">        &quot;audio&quot;：&lt;true | false，是否应该转发音频；可选&gt;</span><br><span class="line">        &quot;video&quot;：&lt;true | false，是否应该转发视频；可选&gt;</span><br><span class="line">        &quot;data&quot;：&lt;true | false，是否转发数据；可选&gt;</span><br><span class="line">        &quot;substream&quot;：&lt;启用simulcast情况下，要接收的子流（0-2）；可选&gt;</span><br><span class="line">        &quot;temporal&quot;：&lt;启用simulcast，要接收的时间层（0-2）；可选&gt;</span><br><span class="line">        &quot;fallback&quot;：&lt;多少时间（在我们这里，默认为250000）没有接收到数据包将使我们下降到下面的子流&gt;，</span><br><span class="line">        &quot;spatial_layer&quot;：&lt;启用VP9-SVC时要接收的空间层（0-2）；可选&gt;</span><br><span class="line">        &quot;temporal_layer&quot;：&lt;启用VP9-SVC时要接收的时间层（0-2）；可选&gt;</span><br><span class="line">        &quot;audio_level_average&quot;：&quot;&lt;如果提供，将覆盖此用户的房间audio_level_average；可选&gt;&quot;，</span><br><span class="line">        &quot;audio_active_packets&quot;：&quot;&lt;如果提供，将覆盖此用户的房间audio_active_packets；可选&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正如你所看到的audio，video和data属性可以用作媒体级的暂停/恢复功能，而pause与start只是简单地暂停/恢复所有数据流。</p>
<p>下面来说说<code>switch</code>，switch 请求格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;switch&quot;，</span><br><span class="line">        &quot;feed&quot;：&lt;要切换到的新发布者的唯一ID；强制性&gt;，</span><br><span class="line">        &quot;audio&quot;：&lt;true | false，取决于是否应该中继音频；可选&gt;</span><br><span class="line">        &quot;video&quot;：&lt;true | false，取决于是否应该中继视频；可选&gt;</span><br><span class="line">        &quot;data&quot;：&lt;true | false，取决于是否应该中继数据通道消息；可选&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果成功，您将退订之前的发布者，然后订阅新的发布者。确认切换成功的事件如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;switched&quot;：&quot;ok&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;id&quot;：&lt;新发布者的唯一ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，要停止订阅并删除相关的PeerConnection，可以使用该leave请求。由于上下文是隐式的，因此不需要其他参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;leave&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果成功，该插件将尝试拆除PeerConnection，并发送回一个left事件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;left&quot;：&quot;ok&quot;，</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>VideoRoom</code>插件是Janus的一个特别重要的插件，对于该插件的理解对于我们理解整个Janus有至关重要的意义。本文说细分析了<code>VideoRoom</code>插件中所有的信令，大体上我们可以将它们人成两在类，一类是房间管理信令，另一类是用户信令。</p>
<p>这些信令设计的非常巧妙，对我们研发自己的SFU会议系统是一个很好的借鉴。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.avdancedu.com/947c722a/" target="_blank" rel="noopener">多人实时互动之各WebRTC流媒体服务器比较</a><br><a href="http://www.avdancedu.com/d7281c13/" target="_blank" rel="noopener">janus前端核心库源码分析</a></p>
]]></content>
      <categories>
        <category>WebRTC</category>
      </categories>
      <tags>
        <tag>videoroom</tag>
      </tags>
  </entry>
  <entry>
    <title>WebRTC常见问题</title>
    <url>/af19ebea/</url>
    <content><![CDATA[<h2 id="DTLS-SRTP-与-DTLS-的区别"><a href="#DTLS-SRTP-与-DTLS-的区别" class="headerlink" title="DTLS-SRTP 与 DTLS 的区别"></a>DTLS-SRTP 与 DTLS 的区别</h2><p>DTLS用于数据加密，它是从 TLS 发展而来。 TLS用于TCP，而DTLS用于UDP。<br>DTLS-SRTP 只用户握手，交换<code>fingerprint</code>和密钥，真正的加密由SRTP来完成。</p>
<h2 id="是否开启-DTLS-SRTP"><a href="#是否开启-DTLS-SRTP" class="headerlink" title="是否开启 DTLS-SRTP"></a>是否开启 DTLS-SRTP</h2><p>在创建PeerConnection时设置<code>DtlsSrtpKeyAgreement</code>参数可以关闭/打开 DTLS-SRTP<br><a href="https://groups.google.com/forum/#!topic/discuss-webrtc/t8XT0IxoHgw" target="_blank" rel="noopener">discuss-webrtc</a></p>
]]></content>
      <categories>
        <category>WebRTC</category>
      </categories>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title>janus前端核心库源码分析</title>
    <url>/d7281c13/</url>
    <content><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/janus_js/janus_logo.jpg" alt=""></p>
<p>Hello,大家好！今天我们继续来分析janus。相信现在大家应该对<a href="https://janus.conf.meetecho.com/" target="_blank" rel="noopener">janus</a> 都比较熟悉了，它是一套完整的音视频会议系统，包括了WebRTC流媒体服务器和客户端API两大部分。</p>
<p>其中，客户端又包括Android、iOS以及浏览器端。今天我们要分析的内容就是浏览器端中的<code>janus.js</code>文件。之所以要分析它，是因为它是浏览器端最关键的一个文件，了解了它我们基本上就将浏览器端的逻辑全部撑握了。</p>
<p>从大的方面说，<code>janus.js</code>主要完成两方面的事儿。一是封装了浏览器与janus流媒体服务器之间的业务接口，使得在浏览器端开发音视频会议系统变得特别简单；二是对WebRTC的API做了封装，这样用户不用再理会WebRTC底层API该何使用了。</p>
<p>总之一句话，就是大大的减了少JS用户使用janus的难度。</p>
<a id="more"></a>

<p>在阅读本文之前你应该已经熟悉了JavaScript语法，且对浏览器下调用WebRTC的API十分精通，否则你应该先去补齐相关知识再来阅读本文。 这里有一些参考资料仅供参考：<a href="http://avdancedu.com/18fc7df1/" target="_blank" rel="noopener">《js类的探究》</a>，在这篇文章中有介绍ES5与ES6之间的区别。<a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门与实战课程》</a>，该课程详细讲解了在浏览器下该如何使用WebRTC。</p>
<p>下面我们开始<code>janus.js</code>源码分析。</p>
<h2 id="核心类Janus"><a href="#核心类Janus" class="headerlink" title="核心类Janus"></a>核心类Janus</h2><p>对于<code>janus</code>源码的目录结构我已经在之前的文章中向你介绍过了，如果你还没看过，可以到<a href="">这里</a>看一下。通过目录结构我们可以知道，<code>janus.js</code>就在<code>janus</code>源码的<code>html</code>目录下。</p>
<p>大体浏览一下<code>janus.js</code>你会发现，整个文件有3000多行代码，但只有一个<code>类</code>，即<code>Janus</code>类。该类中实现了很多方法，然而核心代码量并不大，经抽丝拨茧，你会发现下面几个方法是比较关键的。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Janus(gatewayCallbacks) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建一个Session，私有方法</span><br><span class="line">    function createSession(callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;消毁Session，私有方法</span><br><span class="line">    function destroySession(callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;用于处理Janus信令</span><br><span class="line">    function eventHandler()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;信令事件处理函数，私有方法</span><br><span class="line">    function handleEvent(json, skipTimeout);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;发送消息，私有方法</span><br><span class="line">    function sendMessage(handleId, callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建插件处理函数，私有方法</span><br><span class="line">    function createHandle(callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;消毁插件处理方法</span><br><span class="line">    function destroyHandle(handleId, callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;发送candidate，私有方法</span><br><span class="line">    function sendTrickleCandidate(handleId, candidate);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建PC</span><br><span class="line">    function streamsDone(handleId, jsep, media, callbacks, stream);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;准备WebRTC</span><br><span class="line">    function prepareWebrtc(handleId, offer, callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;接收远端的SDP，并设备远端描述符</span><br><span class="line">    function prepareWebrtcPeer(handleId, callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建Offer</span><br><span class="line">    function createOffer(handleId, media, callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建answer</span><br><span class="line">    function createAnswer(handleId, media, callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;发送SDP</span><br><span class="line">    function sendSDP(handleId, callbacks);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对上面的这些方法，我们可以按类别将其划分成以下几类：</p>
<ul>
<li><p>Session相关</p>
<ul>
<li>createSession</li>
<li>destorySession</li>
</ul>
</li>
<li><p>信令处理</p>
<ul>
<li>handleEvent</li>
<li>eventHandler</li>
<li>sendMessage</li>
</ul>
</li>
<li><p>Plugin相关</p>
<ul>
<li>createHandle</li>
<li>destoryHandle</li>
</ul>
</li>
<li><p>WebRTC相关</p>
<ul>
<li>prepareWebrtc</li>
<li>prepareWebrtcPeer</li>
<li>createOffer</li>
<li>createAnswer</li>
<li>sendSDP</li>
<li>streamDone</li>
</ul>
</li>
</ul>
<p>接下来，我们就对这几个函数做下详细介绍，整体的介绍思路是：首先介绍一下它的主要功能是什么，然后再讨论一下它是怎么实现的。</p>
<h2 id="Session-相关"><a href="#Session-相关" class="headerlink" title="Session 相关"></a>Session 相关</h2><p>首先我们来看看 <code>Session</code> 的作用是什么。<code>Session</code>表示的是一个客户端与<code>janus</code>服务器之间建立的一个<code>信令通道</code>。janus客户端与服务器之间就是通过这个<code>信令通道</code>传输信令的。</p>
<p>Session是如何创建的呢？下面我们就来看一下<code>createSession</code>函数的处理逻辑。在<code>createSession</code>中，首先创建了一个JSON对象<code>request</code>，该对象中包括了以下几个信息：</p>
<ul>
<li>janus，代表一个信令，<code>create</code>表示要创建一个<code>session</code>。</li>
<li>token，唯一标识，用于鉴权。</li>
<li>apisecret，API调用码密，用于安全访问。</li>
</ul>
<p><code>request</code>对象构建好后，<code>createSession</code>函数会根据server地址的类型(如ws://、http://）判断是使用 websocket 接口还是使用 HTTP RESTFUL接口。判断逻辑如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">if(!server &amp;&amp; Janus.isArray(servers)) &#123;</span><br><span class="line">    &#x2F;&#x2F; We still need to find a working server from the list we were given</span><br><span class="line">    server &#x3D; servers[serversIndex];</span><br><span class="line">    if(server.indexOf(&quot;ws&quot;) &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">        websockets &#x3D; true;</span><br><span class="line">        Janus.log(&quot;Server #&quot; + (serversIndex+1) + &quot;: trying WebSockets to contact Janus (&quot; + server + &quot;)&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        websockets &#x3D; false;</span><br><span class="line">        Janus.log(&quot;Server #&quot; + (serversIndex+1) + &quot;: trying REST API to contact Janus (&quot; + server + &quot;)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果<code>createSession</code>判断server使用的是<code>websocket</code>接口，它就会走到<code>websocket</code>的处理逻辑分支。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(websockets)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个分支中，首先通过<code>Janus.newWebSocket</code>方法与server（janus服务器）建立连接。然后向websocket注册侦听事件，当websocket接收到不同的事件后就跳到对应事件的处理函数中执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">ws &#x3D; Janus.newWebSocket(server, &#39;janus-protocol&#39;);</span><br><span class="line">wsHandlers &#x3D; &#123;</span><br><span class="line">    &#39;error&#39;: ...,</span><br><span class="line">    &#39;open&#39;: ...,</span><br><span class="line">    &#39;message&#39;: ...,</span><br><span class="line">    &#39;close&#39;: ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(var eventName in wsHandlers) &#123;</span><br><span class="line">    ws.addEventListener(eventName, wsHandlers[eventName]);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在上代码中，注册到 websocket 中的 open 和 message 事件特别重要。websocket收到<code>open</code>事件说明与janus服务器之间已经成功建立了连接，此时我们就可以将之前准备好的 <code>request</code> 发送出去了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">transactions[transaction] &#x3D; function()...;</span><br><span class="line">ws.send(JSON.stringify(request));</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>当websocket连接创建好后，<code>janus.js</code>首先在transctons中创建一个新的<code>transaction</code>，然后将之前准备好的request发送给服务器。</p>
<blockquote>
<p>这里需要注意的是transaction，它表示一个事务或称之为上下文，当一件事儿由多个步骤多阶段组合完成时，我们一般都使用这种设计方案。</p>
</blockquote>
<p>服务端收到消息后进行逻辑处理，之后通过上面建立的连接将处理结果返回给<code>janus.js</code>，此时就会触发我们上面注册的<code>message</code>事件。在message事件中，对所有接收到的服务端的消息都由<code>handleEvent</code>函数进行处理。对于该函数我们后面还会做详细介绍，这里就不过多讲解了。</p>
<p>至此，<code>createSession</code> 函数的主要作用我们就分析完了，而<code>destorySession</code>是<code>createSession</code>的反函数，用于销毁<code>createSession</code>创建的资源，大家自己去看代码就好了，我这里不再做过多描述了。</p>
<p>接下来我们来看一下<code>janus.js</code>是如何处理从服务端接收到的信令的。</p>
<h2 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h2><p>上面讲解<code>Session</code>的创建时，我已经向你介绍了janus默认提供了两种传输信令的接口，即<code>websocket</code>处<code>http</code>。janus会根所用户访问地址的协议头来自动判断使用那种协议进行信令的传输。</p>
<p>对于服务端来讲，这两种接口的实现是在<code>janus</code>源码目录下的 <code>transports</code> 目录下，对应的实现文件为janus_websockets.c和janus_http.c文件，通过文件名我们也可以知道他们分别是websocket和http接口的实现了。</p>
<blockquote>
<p>当然janus不光支持这两种接口，它还支持好几种接口，但需要你手工配置。如果你不进行任何配置的话，它默认只支持这两种接口。</p>
</blockquote>
<p>下面是<code>janus</code>信令处理的简化架构图，我们通过这张图先从整体上了解一下janus是如何处理信令的。</p>
<p><img data-src="https://cdn.avdancedu.com/image/article/janus_js/janus_command.jpg" alt=""></p>
<p>上图将janus分成了两大部分，服务端和客户端。我们分别来介绍一下，首先来看看服务端的处理过程。</p>
<h3 id="服务端接收消息"><a href="#服务端接收消息" class="headerlink" title="服务端接收消息"></a>服务端接收消息</h3><p>通过上图我们可以看到，janus服务端的信令处理是由<code>transports</code>完成的，<code>transports</code>中包括很多插件，图中展示的<code>websocket</code>和<code>http</code>就是其中的两个。</p>
<p>这两个<code>transport</code>插件是在janus服务启动时加载起来的。以websocket插件为例，当该插件被加载后，websocket服务随即开启。此时，<code>janus.js</code>(JS客户端）就可以向该websocket服务发送消息了，同时<code>janus.js</code>也可以通过websocket连接接收来自服务端的信息。</p>
<p>当在服务端通过<code>websocket</code>收到消息后，最终会调用janus_websockets.c中的<code>janus_websockets_common_callback</code>方法将收到的消息传给janus core。janus core 收到消息后再根据消息类型做相应的处理。关于这块的逻辑我们先暂时放一放，待以有时间了我再说细介绍。</p>
<p>接下来我们再看客户端<code>janus.js</code>是如何处理的。</p>
<h3 id="客户端接收消息"><a href="#客户端接收消息" class="headerlink" title="客户端接收消息"></a>客户端接收消息</h3><p>客户端是如何处理消息的呢？我们还是从<code>Session</code>创建之后讲起。在<code>创建Session</code>一节中我已经介绍了，janus在websocket上侦听了<code>message</code>事件，每当websocket收到服务端发来的消息时，就会触发该事件。</p>
<p><code>janus.js</code>对该事件的处理方法是也比较简单，不管三七二十一直接将event中带来的数据交收<code>handleEvent</code>处理。<code>handleEvent</code>又是如何做的呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function handleEvent(json, skipTimeout) &#123;</span><br><span class="line">  ...</span><br><span class="line">  if(json[&quot;janus&quot;] &#x3D;&#x3D;&#x3D; &quot;keepalive&quot;) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; else if(json[&quot;janus&quot;] &#x3D;&#x3D;&#x3D; &quot;ack&quot;) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; else if(json[&quot;janus&quot;] &#x3D;&#x3D;&#x3D; &quot;success&quot;) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; else if(...</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>handleEvent</code>处理逻辑就如上面所示，对消息类型做判断，根据不同的类型做不同的处理。它能处理的消息包括以下几种:</p>
<ul>
<li>keepalive，心跳消息。</li>
<li>ack，确认消息。也就是说之前客户端发送了一个信令给服务端，服务端收到之后给客户端回了一个<code>ack</code>，确认服务端已经收到该消息了。</li>
<li>success，消息处理成功。该消息与 ack 消息是类似的，当服务器完成了客户端的命令后会返回该消息。</li>
<li>trickle，收集<code>候选者</code>用的消息。里边存放着 candidate，janus.js收到该消息后，需要将Candidate解析出来。</li>
<li>webrtcup，表示一个peer上线了，此时要找到以应的业务插件（plugin）做业务处理。</li>
<li>hangup，用户挂断，找到对应的plugin，进行挂断操作。</li>
<li>detached，某个插件要求与Janus Core之间断开连接。</li>
<li>media，开始或停信媒体流。</li>
<li>slowlink，限流？</li>
<li>error，错误消息</li>
<li>event，插件发磅的事件消息。</li>
<li>timeout，超时。</li>
</ul>
<p>对于janus.js来讲，上面这些消息有些是不需要再做处理的，有些是需要修改状态的，还有一些是与业务插件有关的，需要交由<code>pluginHandle</code>做进一步处理。 关于<code>pluginHandle</code>后面我们再做介绍。</p>
<p>以上就是janus客户端对从服务端接收到的消息的处理过程。当然在你阅读代码时还会看到<code>eventHandler</code>函数，这个函数是对handleEvent函数简单的封装，用在http接口上。由于websocket接口是长连接，所以直接使用的handleEvent函数，我们清楚这两个函数的联系与区别就OK了。</p>
<h3 id="客户端发送消息"><a href="#客户端发送消息" class="headerlink" title="客户端发送消息"></a>客户端发送消息</h3><p>上面我们主要介绍了从服务端来的消息janus是如何处理的，那客户端是如何发送消息的呢？</p>
<p>在<code>janus.js</code>中为上层应用封装了一个发送消息的方法，即<code>config.send()</code>。这个函数实际调用的是janus的<code>sendMessage</code>方法。我们来看一下它的大体实现吧。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sendMessage(handleId, callbacks) &#123;</span><br><span class="line">    ...</span><br><span class="line">    var pluginHandle &#x3D; pluginHandles[handleId];</span><br><span class="line">    ...</span><br><span class="line">    var message &#x3D; callbacks.message;</span><br><span class="line">    ...</span><br><span class="line">    if(pluginHandle.token)</span><br><span class="line">        request[&quot;token&quot;] &#x3D; pluginHandle.token;</span><br><span class="line">    ...</span><br><span class="line">    var request &#x3D; &#123; &quot;janus&quot;: &quot;message&quot;, &quot;body&quot;: message, &quot;transaction&quot;: transaction &#125;;</span><br><span class="line">    ...</span><br><span class="line">    if(websockets)&#123;</span><br><span class="line">        ws.send(JSON.stringify(request));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码我们可以发现，在<code>sendMessage</code>中主要是构造<code>request</code>对象，然后将构造好的<code>request</code>消息通过<code>websocket</code>发送出去。</p>
<p>消息发送给janus服务器，服务器处理好后又会给客户端返回消息。消息返回到客户端后，后会触发websocket的<code>message</code>事件，这样就又回到了我们上面介绍的<code>handleEvent</code>处理函数。</p>
<h2 id="Plugin相关"><a href="#Plugin相关" class="headerlink" title="Plugin相关"></a>Plugin相关</h2><p>在<code>janus.js</code>中，<code>Plugin</code>相关函数的主要作用是，在客户端创建一个<code>pluginHandle</code>对象，并让该对象与janus服务端的某个插件关联。</p>
<p>所谓的关联就是在<code>pluginHandle</code>对象中保存着可以访问janus服务端插件的信息。该对象中存放着很多的信息，如session、plugin、webrtc等信息。下面我抽取了一些比较关键的信息，我们来详细分析一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">session : that,</span><br><span class="line">plugin : plugin,</span><br><span class="line">...</span><br><span class="line">token : handleToken,</span><br><span class="line">detached : false,</span><br><span class="line">webrtcStuff : &#123;</span><br><span class="line">    ...</span><br><span class="line">    mySdp : null,</span><br><span class="line">    mediaConstraints : null,</span><br><span class="line">    pc : null,</span><br><span class="line">    trickle : true,</span><br><span class="line">    iceDone : false,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>上面的字段就是<code>pluginHandle</code>对象的一些重要信息，在这些信息中包括了两在部分，基础信息部分和WebRTC信息部分。</p>
<p>首先我们看一下基础信息。session中保存的是<code>janus</code>核心类对象；plugin指明我们要与服务端那个个插件建立联接，例如<code>vidoeroom</code>插件；token用于安全访问；detached表明是否已经与服务端对应的<code>plugin</code>建立了联系。</p>
<p>接下来<code>webrtcStuff</code>域是与webrtc相关的参数。mySdp中保存的是本地SDP信息；mediaConstrains存放用于采集音视频数据的限制参数；pc表示PeerConnection；trickle指明在使用WebRTC时是否使用<code>trickle</code>机制；iceDone表明是否ICE建立成功了。</p>
<p>该对象中的内容是由<code>createHandle</code>函数创建和填充的，下面我们就来看一下<code>createHandle</code>函数做了哪些事儿？</p>
<p>在该函数中，它首先构造<code>request</code>对象，该对象包括以下几个信息：</p>
<ul>
<li>janus域，表示信令类型， <code>attach</code>表示与某个<code>plugin</code> 进行绑定。</li>
<li>plugin，表示绑定哪个plugin。<code>janus.plugin.videoroom</code></li>
<li>opaque_id，一个唯一的ID。</li>
<li>transaction，表示一个事务ID。</li>
<li>token，用于与服务器连接的合法标识</li>
<li>apisecret，API密码。</li>
<li>sessionID，session的唯一标识。</li>
</ul>
<p><code>request</code>对象创建好后，通过websocket发送给服务端，这样就在客户端与服务端的plugin插件建立了联接。</p>
<p>除了创建<code>request</code>对象外，该函数还创建了一个transaction对象，并将它存放在 <code>transactions</code> 数组中(<code>transactions[transaction]</code>)。</p>
<p>实际上 <code>transaction</code> 是一个函数，该函数中会创建一个<code>pluginHandle</code>对象，<code>pluginHandle</code>创建好后，也会被保存起来放到<code>pluginHandles</code>里以备后面使用。</p>
<p>除了<code>createHandle</code>函数之外，在janus.js中还有<code>destoryHandle</code>函数，它是<code>createHandle</code>的反函数，用于做释放操作。</p>
<p>以上就是janus.js中处理Plugin相关的函数。</p>
<h2 id="Webrtc相关"><a href="#Webrtc相关" class="headerlink" title="Webrtc相关"></a>Webrtc相关</h2><p>在<code>janus.js</code>中WebRTC相关的方法是最多的，也是最为重要的。其中尤以<code>prepareWebRTC</code>最为重要。下面我们就来详细介绍一下这个函数。</p>
<p>这个函数的作用是什么呢？说来起它还是蛮复杂的，我们来一项一项来介绍。一、它要过浏览器采集音视频数据，以便可以将数据上传给远端；二要与按照WebRTC的规规范进行媒体协商；三协商成功后要与远端建立连接；最后把采集的数据压缩编码后传到远端；</p>
<p>这个函数代码量非常大，我抽取了函数中重要的逻辑，这样更有利于我们撑握整个函数的流程脉络。代码整理如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">if(isAudioSendEnabled(media) || isVideoSendEnabled(media)) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;media为空，或者media.video不为屏幕，说明现在想采集视频数据</span><br><span class="line">    if(!media || media.video !&#x3D;&#x3D; &#39;screen&#39;) &#123;</span><br><span class="line">        &#x2F;&#x2F;遍历每个设备</span><br><span class="line">        navigator.mediaDevices.enumerateDevices().then( function(devices) &#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;如果是音频输入设备</span><br><span class="line">            var audioExist &#x3D; devices.some(function(device) &#123;</span><br><span class="line">                                return device.kind &#x3D;&#x3D;&#x3D; &#39;audioinput&#39;;</span><br><span class="line">                            &#125;),</span><br><span class="line">            &#x2F;&#x2F;如果是视频输入设置</span><br><span class="line">            videoExist &#x3D; isScreenSendEnabled(media) || devices.some(function(device) &#123;</span><br><span class="line">                                return device.kind &#x3D;&#x3D;&#x3D; &#39;videoinput&#39;;</span><br><span class="line">                            &#125;);</span><br><span class="line">           ...</span><br><span class="line">           &#x2F;&#x2F;设置采集数据的限制条件</span><br><span class="line">           var gumConstraints &#x3D; &#123;</span><br><span class="line">              audio: (audioExist &amp;&amp; !media.keepAudio) ? audioSupport : false,</span><br><span class="line">              video: (videoExist &amp;&amp; !media.keepVideo) ? videoSupport : false</span><br><span class="line">           &#125;;</span><br><span class="line"></span><br><span class="line">           ...</span><br><span class="line">           &#x2F;&#x2F;采集数据</span><br><span class="line">           navigator.mediaDevices.getUserMedia(gumConstraints)</span><br><span class="line">             .then(function(stream) &#123;</span><br><span class="line">               ...</span><br><span class="line">               &#x2F;&#x2F;</span><br><span class="line">               streamsDone(handleId, jsep, media, callbacks, stream);</span><br><span class="line">             &#125;).catch(function(error) &#123;...&#125;);</span><br><span class="line"></span><br><span class="line">        &#125;).catch(...);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过代码的梳理我们可以看到<code>prepareWebrtc</code>函数首先遍历所有设备，找出可用的设备，之外调用`getUserMedia函数去采集音视频数据。之后像媒体协商、Candidate的收集都在 streamDone 函数中完成。</p>
<p>接下来我们继续分析<code>streamsDone</code> 函数。下面是<code>streamsDone</code>函数的主要脉络代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function streamsDone(handleId, jsep, media, callbacks, stream) &#123;</span><br><span class="line">    ...</span><br><span class="line">    var config &#x3D; pluginHandle.webrtcStuff;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;创建PeerConnection</span><br><span class="line">    f(!config.pc) &#123;</span><br><span class="line">        var pc_config &#x3D; &#123;&quot;iceServers&quot;: iceServers, &quot;iceTransportPolicy&quot;: iceTransportPolicy, &quot;bundlePolicy&quot;: bundlePolicy&#125;;</span><br><span class="line">        ...</span><br><span class="line">        var pc_constraints &#x3D; &#123;</span><br><span class="line">            &quot;optional&quot;: [&#123;&quot;DtlsSrtpKeyAgreement&quot;: true&#125;]</span><br><span class="line">        &#125;;</span><br><span class="line">        ...</span><br><span class="line">        config.pc &#x3D; new RTCPeerConnection(pc_config, pc_constraints);</span><br><span class="line">        config.pc.oniceconnectionstatechange &#x3D; ...;</span><br><span class="line">        config.pc.onicecandidate &#x3D; ...;</span><br><span class="line">        config.pc.ontrack &#x3D; ...;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将本地track添加到流中</span><br><span class="line">    if(addTracks &amp;&amp; stream) &#123;</span><br><span class="line">        ...</span><br><span class="line">        config.pc.addTrack(track, stream);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建offer进行媒体协商</span><br><span class="line">    if(!jsep) &#123;</span><br><span class="line">        createOffer(handleId, media, callbacks);</span><br><span class="line">    &#125;else&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该函数中首先会根据限制条件创建一个<code>PeerConnection</code>。PeerConnection简称PC，它是浏览器下使用WebRTC的核心，想了解这块知识的同学可以看一下我的课程<a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门与实战》</a>，这里我就不过多讲解这部分内容了。</p>
<p>PC创建好后，需要将之前从<code>prepareWebrtc</code>中获取的本地音视频轨添加到PC中，为媒体协商做好准备。最后调用createOffer函数生成媒体协商中的<code>Offer</code>SDP与远端交换从成完成媒体协商。</p>
<p>现在你应该了解<code>streamsDone</code>函数的作用了吧？同时也应该清楚<code>prepareWebrtc</code>函数是干什么的了。</p>
<p>当我们将<code>prepareWebrtc</code>函数的功能搞清楚之后，对于其它的WebRTC相关API就比较容易理解了，由于篇幅的原因我就不在这里一一做介绍了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>上面我对janus.js文件做了全面的剖析，通过本文你应该知道<code>janus.js</code>的API可以分成四大类，分别是Session相关，信令相关，Plugin相关以及WebRTC相关的API。同时你也应该清楚，janus中的Session表示的是客户端与服务端之间的网络连接；客户端与服务器之间的信令是如何交互的，以及包括了哪些信令；<code>pluginHandle</code>的作用是用来保存访问远端插件的信息用的，同时它也保存了操作WebRTC相关的信息；而WebRTC相关的API是janus.js中最关键，最为复杂的。尤其是<code>prepareWebrtc</code>函数是最核心的API。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://avdancedu.com/18fc7df1/" target="_blank" rel="noopener">《js类的探究》</a>文中介绍了ES5与ES6之间的区别</li>
<li><a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门与实战课程》</a></li>
</ul>
]]></content>
      <categories>
        <category>WebRTC</category>
      </categories>
      <tags>
        <tag>janus</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript入门</title>
    <url>/48922786/</url>
    <content><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/typescript/typescript.jpg" alt="TypeScript"><br>我们要学习一门新知识，首先要了解一些新知识的历史。<code>TypeScript</code> 是微软开发的，它的出现是为了解决 <code>JavaScript</code> 没有类型检查的弊端。因此，<code>TypeScript</code>并不是一门新语言，它的作用就是帮<code>JavaScript</code>检查数据类型是否正确，所以称它为<code>JavaScript</code>的一个<code>超集</code>是更贴切的。</p>
<p>有很多同学对 <code>TypeScript</code> 产生疑惑，他们会问 <code>TypeScript</code> 可以在浏览器上运行吗？</p>
<a id="more"></a>
<p>虽然<code>TypeScript</code>是<code>JavaScript</code>的一个<code>超集</code>，但由于它要进行类型检查，所以就与 JavaScript 的语法有一些不同了，因此 TypeScript 编写的程序是无法直接运行在浏览器上的。</p>
<h2 id="TypeScript-工作原理"><a href="#TypeScript-工作原理" class="headerlink" title="TypeScript 工作原理"></a>TypeScript 工作原理</h2><p>在讲解 <code>TypeScript</code> 工作原理之前，有一句话是你必须清楚且要印在脑子里的: <strong>在浏览器上，只能运行 JavaScript 脚本</strong>。</p>
<p>既然浏览器里只能运行<code>JavaScript</code>，那<code>TypeScript</code>具体又做了什么事儿呢？下面我就向你解释一下<code>TypeScript</code>都做了哪些事儿。</p>
<p>学习过编译原理的同学都清楚，<strong>类型检查</strong>就是<strong>语法分析</strong>，它属于编译器的范筹。TypeScript官网说: <strong>“TypeScrpt是JavaScript的超集，可以进行JavaScript类型检查。”</strong> 表明<code>TypeScript</code>为<code>JavaScript</code>增加了<strong>类型语法</strong>，并且它还有一个<strong>编译器</strong>，可以将用<code>TypeScript</code>语法编写的程序（.ts文件)，<strong>翻译成</strong> <code>JavaScript</code> 脚本语言。</p>
<p>因此，<code>TypeScript</code>的使用步骤一定是这样的: 首先用 <code>TypeScript</code> 语法编写程序；然后<strong>编译</strong>，输出<code>JavaScript</code>脚本；最终在浏览器中引用生成的 JavaScript 脚本这样一个过程。</p>
<p>实际情况也确实如此，在TypeScript的官网上你可以找到，TypeScript 有一个编译工具称为 <code>tsc</code>，即 <code>t</code>(ype) <code>s</code>(cript) <code>c</code>(ompiler)的缩写 。</p>
<h2 id="JavaScript的最大问题"><a href="#JavaScript的最大问题" class="headerlink" title="JavaScript的最大问题"></a>JavaScript的最大问题</h2><p>使用过其它面向对象语言的同学们再使用JavaScript开发时，都会觉得特别<code>难受</code>，因为JavaScript无法进行类型检查。对于Javascript语法来说，你传给它什么类型的数据都可以，这样虽然看似很<code>很好</code>，但一旦你将数据传错了，你得到的结果就是错误的。当错误出现时，没有任何的提示，光凭我们肉眼去查找错误实在是太费力了，这就是JavaScript的最大问题。</p>
<p>我们来看一个最简单的JavaScript例子你应该就清楚了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function func(msg)&#123;</span><br><span class="line">    console.log(&quot;the message is :&quot; + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码是一段最简单的JS代码，它需要一个字符串参数。但由于JavaScript并没有对参数的类型做限制，所以你在调用这个函数时，可以给他传任意的值。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func(123);</span><br><span class="line">func(&#39;this is my book!&#39;);</span><br><span class="line">func(func);</span><br></pre></td></tr></table></figure>
<p>我的本意是只有第二种调用<code>func</code>的方式才是正确的，但在JavaScript中上面这几种调用<code>func</code>函数的方法都是正确的。在我们实际工作中，我们写了很长的代码后，传入了一个错误的值时JavaScript就无法为我们检测出那里出错了，这是最可怕的。</p>
<p>这也是为什么<code>TypeScript</code>逐渐受到大家喜欢的原因。</p>
<h2 id="一个最简单的-TypeScript-程序"><a href="#一个最简单的-TypeScript-程序" class="headerlink" title="一个最简单的 TypeScript 程序"></a>一个最简单的 TypeScript 程序</h2><p>下面我们就来写一个最简单的 TypeScript程序，了解一下整个使用过程。咱们还是以 Helloworld 为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function hello(person: string) &#123;</span><br><span class="line">  return &#39;Hello , &#39; + person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let user&#x3D;&#39;xxx&#39;</span><br><span class="line">console.log(hello(user));</span><br></pre></td></tr></table></figure>
<p>上面就是一个简单的 TypeScript脚本，有了这个脚本后我们需要先对其进行编译，编译执行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tsc hello.ts</span><br></pre></td></tr></table></figure>
<p>编译出 JavaScript 脚本后，通过 HTML5 引用一下就好了，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;user typescript&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;.&#x2F;hellots.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br></pre></td></tr></table></figure>
<p>至此，一个 TypeScript的简单使用过程就完成了，还是蛮简单的对吧！</p>
<h2 id="TS-调用JS"><a href="#TS-调用JS" class="headerlink" title="TS 调用JS"></a>TS 调用JS</h2><p>我们在使用TS开发时最常见的一个问题是如何通过 TS 调用 JS。产生该问题的根本原因是一些著名的 JS 库(如VUE）的TS版本还没有开发出来，但我们的项目中又必须使用他们，因此就产生了我前面所说的TS 库要调用 JS 库的情况。</p>
<p>我们前面也讲了 TS 本来就是 JS 的一个<code>超集</code>，因此它是有办法调用JS库的。从原理上我们可以证明这一点，因为TS程序最终要经过编译生成JS脚本程序后才能被浏览器执行，因此只要在浏览器上引入它需要的 JS 库，经编译后的 TS 程序就可以与其它的JS库相互调用。</p>
<p>按照上面的描述好像TS 调JS是很简单的事儿，那问题在哪儿呢？其实问题在于如果我们自己写的 TS 程序调用了其它第三方 JS 库，那么正常情况下 <code>tsc</code> 编译我们的 <code>ts</code> 程序时就会报错。所以实际的问题应该是，我们编写的TS程序在调用第三方JS库时，如何可以顺利编译通过呢？</p>
<p>我们在网上可以找到以下几种方案，第一种是将引用到的 JS 库直接翻译成 TS 库。很多同学看到这句话会<code>嗤之以鼻</code>，这明显就是行不通的方案。不过这种方案虽然难度很大，但总归还是一种方案不是；第二种是让<code>tsc</code>编译器不进行类型检查，那也就失去了 <code>TS</code> 的意义，所以这种方法也不是好办法；第三种是为 JS 库增加声名函数，这种方式既可以让<code>tsc</code>在编译时顺利通过，又同时可以检查我们写的代码是否有问题。</p>
<p>所以综上所述，第三种方案是最优的方案。</p>
<p>接下来我就来重点讲解一下如何通过第三种方案实现<code>TS</code>调用第三方<code>JS库</code>。首先我们先来创建一个JS库<code>test.js</code>，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function showmsg(msg)&#123;</span><br><span class="line">    console.log(&quot;the msg is :&quot; + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码非常简单，只实现了一个函数。该函数有一个参数<code>msg</code>，当该函数被调用时，输出传入的参数值。</p>
<p>接下来我们来看一下在<code>TS</code>中如何调用JS中的方法。为了使 TS 可以调用JS的方法，我们需要写一个与<code>JS</code>文件名对应的<code>.d.ts</code>文件。对于我们上面的<code>test.js</code>则需要有一个<code>test.d.ts</code>与之对应。</p>
<p>编写<code>.d.ts</code>文件也很简单，对于test.js来说，它的<code>.d.ts</code>文件内容如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare function showmsg( msg: string) : void;</span><br></pre></td></tr></table></figure>

<p>只需要这样一句就可以了。实际上，它就是为test.js文件中的showmsg函数定个声名。然后我们在使用它的TS文件中引用这个<code>.d.ts</code>文件就好了。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;reference path &#x3D; &quot;.&#x2F;test.d.ts&quot; &#x2F;&gt;</span><br><span class="line">function doSomeThing()&#123;</span><br><span class="line">    showmsg(&#39;ts&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doSomeThing();</span><br></pre></td></tr></table></figure>

<p>在TS文件中引用<code>.d.ts</code>文件的方法是，在文件的开头写上 <code>/// &lt;reference path=&quot;./test.d.ts&quot; /&gt;</code> 即可。这样当我们使用<code>tsc</code>去编译<code>.ts</code>文件时就不会报错了。</p>
<p>当<code>tsc</code>编译好TS文件后，我们可以在HTML中引入生成的JS文件以及它所使用的JS库了。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt; test ts call js&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;script src&#x3D;&quot;.&#x2F;test.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">        &lt;script src&#x3D;&quot;.&#x2F;my.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>此时，在浏览器的<code>debugger</code>里就可以看到<code>the msg is :ts</code>这句话了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我向你介绍了<code>TypeScript</code>的基本工作原理，从中我们可能知道TypeScript解决了JavaScript最大的问题，即类型检测。但TypeScript并不是一门新语言，它也不会代替JavaScript，它只是JavaScript的一个超集而以。</p>
]]></content>
      <categories>
        <category>TypeScript, JavaScript</category>
      </categories>
      <tags>
        <tag>TypeScript, TS, JS, JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>多人实时互动之各WebRTC流媒体服务器比较</title>
    <url>/947c722a/</url>
    <content><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/sfu/conference.jpg" alt="SUF"><br>随着网络基础设施的提高，音视频实时通信越来越成为人们日常生活和工作中必不可少的需求。2011年 WebRTC的出现，则更加速了这种需求变为现实的可能性。</p>
<p>熟悉 WebRTC 的同学应该都知道，WebRTC规范只定义了实时通信中客户端的行为，而没有规范服务端（包括哪些信令、数据如何流转）的行为。所以，你可以使用WebRTC库方便的实现 1:1 实时通信，但对于多人实时互动，光依靠 WebRTC库显然就无法完成要求了。</p>
<p>那我们该如何实现多人实时互动通信呢？</p>
<a id="more"></a>

<h2 id="WebRTC-流媒体服务器"><a href="#WebRTC-流媒体服务器" class="headerlink" title="WebRTC 流媒体服务器"></a>WebRTC 流媒体服务器</h2><p>要想实现多人的实时互动，如音视频会议、在线教育这类产品，我们必须使用 WebRTC + WebRTC流媒体服务器这种方案。</p>
<p>目前有很多比较有名的开源流媒体服务器，如 Janus、Medooze、Mediasoup、Licode(OWT)、Jitsi等等。这些流媒体服务器各有优缺点，下面我就对这几种流媒体服务器作下简要的介绍与比较。</p>
<p>通过本文，你将知道各 WebRTC 流媒体服务器的优缺点，并依俱它们的优缺点选择出更适合你的那款WebRTC流媒体服务器。</p>
<h3 id="Mediasoup"><a href="#Mediasoup" class="headerlink" title="Mediasoup"></a>Mediasoup</h3><p><img data-src="https://cdn.avdancedu.com/image/article/sfu/mediasoup.jpg" alt="mediasoup 整体结构"></p>
<p>上图是Mediasoup整体架构图，通过该图我们可以知道 Mediasoup 流媒体服务器是由 Nodejs 和 Mediasoup(C++) 两部分组成。</p>
<ul>
<li>Nodejs，负责 Mediasoup 的信令接收与业务管理。如创建/消毁房间，创建/关闭生产者，创建/关闭消费者等。</li>
<li>Mediasoup(C++)，这是一个单独的程序，但该程序无法直接启动。因为它在内部会判断是否是 Nodejs 将它启动起来了。只有在Nodejs 的 Mediasoup 管理模块加载之后，再将 Mediasoup(C++)启动起来，这样它才能正常工作。</li>
</ul>
<p>在众多的 WebRTC 流媒体服务器中，Mediasoup 可以说是性能最优秀的WebRTC流媒体服务器。它使用 C++ 作为开发语言，底层使用 libuv 处理 I/O 事件。</p>
<p>有很多人对 Nodejs 比较诟病，认为 Nodejs 提拱不了高性能的流媒体服务器。实际上，如果按照传输的 Nodejs 应用开发出的流媒体服务器肯定是不能胜任这项工作的。但对于 Mediasoup 来讲，它只不过使用 Nodejs 做 信令处理 及 业务的管理 工作，所以它的负担并不重。对性能要求高的是媒体数据流的转发工作，而这部分工作是由 Mediasoup(C++)部分实现的。Nodejs 与 Mediasoup之间通过管道进行通信。</p>
<p>严格意义上来说，Mediasoup是单进程的。但你不要以为这就影响了它的性能。实际上，它是使用单进程的方式将服务器上CPU某个 <code>核</code> 充分利用好，然后在业务层控制进程的个数。比如说你的服务器是个 8 核的CPU，那么在业务层你就该启动 8 个Mediasoup进程。通过这种方式来达到对 CPU 的充分利用。</p>
<p><img data-src="https://cdn.avdancedu.com/image/article/sfu/mediasoup_arch.jpg" alt="mediasoup结构图"></p>
<p>Mediasoup中的每个进程称为一个 Worker, 你也可以把它理解为一个<code>节点</code>，在每个 Worker 中可以有多个 Router。对于 Router，你站在不同的解度可以有不同的理解。如果你占在应用层的角度，你可以把它理解为一个房间；如果你站在数据流转的角度，可以把它理解为一个路由器，数据通过 <code>路由器</code> 转发给目标用户。</p>
<p>想了解更多Mediasoup的细节，可以观看我的视频课 <a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">《百万级高并发WebRTC流媒体服务器设计与开发》</a>，在这个视频中我对 Mediasoup 源码做了深入剖析。</p>
<h3 id="Janus"><a href="#Janus" class="headerlink" title="Janus"></a>Janus</h3><p><img data-src="https://cdn.avdancedu.com/image/article/sfu/janus_arch.jpg" alt="Janus架构"></p>
<p>上面这张图是 Janus 的整体架构图。在这张图中我们可以看到， 从大的方面说 Janus 由 Janus CORE、Janus Plugin 以及信令接口三部分组成。</p>
<ul>
<li>信令接口，Janus 支持的信令协议比较多，如 HTTP、WebSocket、RabbitMQ 等。这些信令协议使得 Janus 具有非常好的接入性。因为很多公司喜欢各种不同的协议，如有的喜欢 websocket，有的喜欢http，proto等。因此 Janus 在信令接入方面具有很大的优势。</li>
<li>Janus Plugin，Janus 的业务管理是按照 Plugin 的方式管理的，因此你可以在Janus中根据自己的需要实现自己的业务插件。实际上，对于一般性的需求 Janus 已经相关的插件。如：<ul>
<li>VideoRoom，用于多人音视频互动，像音视频会议，在线教育都可以通过该插件来实现。</li>
<li>VideoCall，用于 1:1 的音视频通信。</li>
<li>SIP，用于与传统电话设备对接。</li>
<li>Streaming，用于广播，也就是我们通常所说的一人共享，多人观看的直播模式。</li>
<li>TextRoom，它是一个聊天室，通过它可以进行文本聊天。</li>
<li>RecordPlay，用于录制和回放。</li>
</ul>
</li>
<li>Janus Core 是Janus的核心，其作用是处理流的转发，各种协议的接入。以浏览器为例，要想让浏览器接入到 WebRTC 流媒体服务器上，那流媒体服务器必须要支持 STUN、DTLS、SRTP、ICE 等协议。而 Janus Core 就是专门做这事儿的。</li>
</ul>
<p>Janus 是由 C语言开发的，因此它的性能非常优秀。要说不足的话，janus 底层没有使用 epoll 这类异步I/O事件处理机制，这应该说是它的一大缺陷；另外，Janus还使用 glib 库，由于 glib 库对于国内的很多开发同学来说用的比较少，所以会有一定的学习成本。</p>
<p>整体上看，Janus采用了插件的架构设计方案。这种方案非常适合于有多种业务模型或业务经常发生变化的公司或项目。另外 Janus 支持多种消息传输协议，这对于开发人员来说具有极大的吸引力。</p>
<h2 id="Medooze"><a href="#Medooze" class="headerlink" title="Medooze"></a>Medooze</h2><p><img data-src="https://cdn.avdancedu.com/image/article/sfu/medooze_arch.jpg" alt="Medooze 架构.png"></p>
<p>Medooze 的整体架构与 Mediasoup 类似，不过它的信令处理、业务管理以及媒体数据的转发功能都是放在 Nodejs下进行统一管理的。实际上，这样的管理方式也不会对性能造成什么影响，因为重的媒体流的转发工作仍然是使用的 C++ 在 Nodejs 底层实现的。</p>
<p>Medooze 的业务功能要比 Mediasoup 强大，像服务端录制、推流这些 Mediasoup 没有的功能它都支持。但它性能没有 Mediasoup 做的极致，在Medooze的底层使用的poll来处理I/O事件，poll与epoll性能相差距大。除此之外，Medooze的业务逻辑也没有Mediasoup简洁；另外与 Janus 相比，它的业务管理不如 Janus 灵活，Janus 的插件管理方式显然要优于 Medooze 和 mediasoup。</p>
<p>但总的来说，Medooze还是一款非常不错的 WebRTC 流媒体服务器。虽然有一些小的暇疵，但还是非常不错的一款流媒体服务器。</p>
<p>想了解更多 Medooze 细节的同学可以看我的专栏 <a href="https://time.geekbang.org/column/article/136000" target="_blank" rel="noopener">《从0打造音视频直播系统》</a>。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过上面的描述，我想你应该对目前主流的 WebRTC 流媒体服务器有了一个大体的了解。所以在选型上你可以按照自己团队的能力进行评估到底该用那个流媒体服务器。</p>
<p>如果你团队能力比较强，可以做底层开发，那么建议你使用 Mediasoup。因为 Mediasoup 不关心应用层，它关注的是底层数据如何高效的流转，代码简洁、高效，性能极佳。</p>
<p>如果你们要做的业务种类比较多，变化比较快，那建议你选择使用 Janus 作为流媒体服务器。将你的业务做成一个插件放到 Janus上很快就能实现你们的业务需求。</p>
<p>如果你们的业务变化不大，除了追求性能外，还需要录制、推流之类的功能，那么你可以选择使用Medooze，它可以很好的满足你们的需求。</p>
<p>当然，除了上面我介绍到的几款比较流行的 WebRTC 流媒体服务器外，还有一些其它的流媒体服务器，如 Licode、OWT、Jitsi等也可以选择。</p>
<p>Licode 之所以名气比较大，是因为它推出的时间比较早。而 OWT 是 Licode 的一个变种，它在 Licode上实现了 SFU 功能。看一下 Licode 代码你就会发现，Licode 实现了一套完整的音视频会议系统，对于这样一套系统它的实现非常复杂。如果你的团队没有音视频方面的开发人才的话，可以考虑Licode，将它搭建出来之后就可以直接使用了。但如果你有业务变化想修改它就太麻烦了。</p>
<p>Jitsi 上层是使用 Java 语言开发的，但底层也是使用的 C/C++ 语言。它通过 JNI 来实现Java与 C/C++之间的通信。在 2018 年有机构做过一次性能评测，当时 Jitsi 表现比较差强人意，不知现在是否已经有了改进。</p>
<p>以上就是对几款 WebRTC流媒体服务器的比较，希望本文可以帮助你解决WebRTC流媒体服务器的选择问题。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">《百万级高并发WebRTC流媒体服务器设计与开发》</a></li>
<li><a href="https://time.geekbang.org/column/article/136000" target="_blank" rel="noopener">《从0打造音视频直播系统》</a></li>
<li><a href="https://www.jianshu.com/p/159ab573c38d" target="_blank" rel="noopener">音视频会议系统 Janus 的布署与安装</a></li>
<li><a href="https://www.jianshu.com/p/98674c32aef8" target="_blank" rel="noopener">Janus的线程模型</a></li>
<li><a href="https://www.jianshu.com/p/7867916c52e3" target="_blank" rel="noopener">理解Janus中的Plugin</a></li>
</ul>
]]></content>
      <categories>
        <category>WebRTC</category>
      </categories>
      <tags>
        <tag>WebRTC mediasoup janus medooze licode owt 音视频 流媒体服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>js类的探究</title>
    <url>/18fc7df1/</url>
    <content><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/js/javascript.png" alt="javascript"></p>
<p>随着浏览器的发展，JS（JavaScript) 越来越受到人们的欢迎。它不再像以前只能做单一的渲染页面这样的事情了，在Chrome等现代浏览器上，你甚至可以用JS来做音视频的处理，是不是觉得很神奇？</p>
<p>不过今天我要讨论的并不是如何使用JS来做一些<strong>神奇</strong>的事儿，而是来重新认识一下JS中<strong>类</strong>的使用。对于这部分知识的理解，将为我们后面阅读Janus(一款WebRTC流媒体服务器)代码有着至关重要的作用。</p>
<a id="more"></a>

<h2 id="JS中的function"><a href="#JS中的function" class="headerlink" title="JS中的function"></a>JS中的function</h2><p>在ES5以前，JS中并没有<strong>class</strong>关键字，那时候JS是如何表示一个类的呢？说来也奇怪，它使用<strong>function</strong>来表示。</p>
<p>我在了解这部分知识的时候也是觉得不可思意！实际上我早在2003年的时候就学习并使用JS了，那时候JS还很简单。虽然后来很久没有再碰过它，但印象中<strong>function</strong>一直是用来定义一个函数的，现在怎么又用来定义<strong>类</strong>了呢？</p>
<p>后来看了一些资料才逐渐理清，原来现在的JS中<code>function</code>既可以用来定义函数，也可以用来定义类。有点类似于语文中的<strong>一语双关</strong>。</p>
<p>之所以<code>function</code>有双层含义，是因为JS最开始并不支持面向对象开发模式。但随着技术的发展，面向对象的开发模式越来越受到人们的欢迎，JS为了能跟上时代，所以也必须支持面向对象开发。</p>
<p>不过JS在转向面向对象语言时面临一种选择，即从原生语言上支持<code>class</code>，那JS解析器就要做大的调整，这可不是一时半会儿可以完成的。而如果在原有的基础上修改则要容易得多。</p>
<p>权衡利弊之后，JS<code>大神</code>们还是决定在现有的基础上修改是最省时少力的。于是就借用了<code>function</code>函数，把它看作是一个<strong>构造函数</strong>，这样就可以快速的将JS改造成面向对象的开发语言了。</p>
<p>以上就是JS中使用<code>function</code>定义类的大致由头！下面我们就来看看在ES5上该如何定义一个<strong>类</strong>。</p>
<h2 id="类及成员"><a href="#类及成员" class="headerlink" title="类及成员"></a>类及成员</h2><p>在JS中如何定义一个类呢？实际上它与其它面向对象语言(如Java)是很类似的，只不过在Java中定义类用的是<code>class</code>关键字，而在JS中用<code>function</code>代替而以。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function classname() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Java 中，类的成员按安全性可以分为<strong>公有</strong>和<strong>私有</strong>，JS中是否也有类似的概念呢？答案是肯定的，接下来我们就来看一下在JS类中如何定义公有成员和私有成员吧。</p>
<p>JS中公有成员和私有成员的定义都是隐式的，不像Java有明确的<code>public</code>和<code>private</code>关键字来指明它们的权限。在JS类中直接定义的函数或变量都是私有成员，在类成员或函数前面加<code>this</code>关键字的，则表式是公有成员。</p>
<p>我们来看个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myclass ()&#123;</span><br><span class="line"></span><br><span class="line">    function test()&#123;</span><br><span class="line">        console.log(&quot;testA function&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; new myclass();</span><br><span class="line">obj.test();</span><br></pre></td></tr></table></figure>
<p>如果我们在浏览器执行上面的代码，在浏览器的<code>debugger</code>中你一定可以看到这样一条错误信息<code>“Uncaught TypeError: obj.testfunc is not a function”</code>，这说明通过<code>obj</code>对像是无法访问到<code>test()</code>函数的。</p>
<p>我们稍微调整一下这段代码，修改如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myclass ()&#123;</span><br><span class="line"></span><br><span class="line">    this.test &#x3D; test() &#123; &#x2F;&#x2F;这里加了this 关键字</span><br><span class="line">        console.log(&quot;testA function&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; new myclass();</span><br><span class="line">obj.test();</span><br></pre></td></tr></table></figure>
<p>我们在<code>test</code>函数前加上<code>this.</code>，只做这一点点修改，这段代码就可以在浏览器上成功运行了。</p>
<p>由此我们可以知道，如果你想让外面访问对象中的成员（成员变量或成员方法），你就应该在这些成员前面加上<code>this</code>关键字。反过来讲，如果你不想让外面访问到对象中的成员，则不要在这些成员前面加<code>this</code>。</p>
<h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><p>在Java中除了有对象成员外，还可以有类成员，比如在使用单例模式时，我们都会定义一个静态的成员。在JS中如何做到这点呢？我们来看个具体例子吧。还是刚才那个代码，我们在其基础上稍做修改即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义类方法</span><br><span class="line">myclass.init &#x3D; function()&#123; </span><br><span class="line">    console.log(&quot;class method!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function myclass ()&#123;</span><br><span class="line"></span><br><span class="line">    this.test &#x3D; test() &#123; &#x2F;&#x2F;这里加了this 关键字</span><br><span class="line">        console.log(&quot;testA function&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调用类方法</span><br><span class="line">myclass.init();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建对象</span><br><span class="line">var obj &#x3D; new myclass();</span><br><span class="line">obj.test();</span><br></pre></td></tr></table></figure>

<p>在这段代码中，加入了类方法的定义及调用类方法的代码。从上述代码中我们可以知道，在JS中类方法是在类之外定义的，而不像Java在是类内加<code>static</code>关键字。</p>
<h2 id="类的原型prototype"><a href="#类的原型prototype" class="headerlink" title="类的原型prototype"></a>类的原型prototype</h2><p>在JS中，每个类都有一个类属性<code>prototype</code>，用来指向类原型。或者你可以把它理解为指向<strong>类原型的地址</strong>。当我们想为这个类添加方法或成员变量的时候，就可以通过prototype来实现，只需修改prototype指向的内存地址的内容就可以达到添加成员的目的。</p>
<p>举个例子，假设我们定义了一个类如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myjs()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目前在这个类中没有写任何方法或成员变量，只是定义了一个空类。下面我想修改这个类，给这个类增加一些内容，该怎么做呢？实现的方法很简单，修改prototype即可，看下面的例子你就明白了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myjs()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myjs.prototype.a  &#x3D; 5;</span><br><span class="line">myjs.prototype.test &#x3D; function() &#123;</span><br><span class="line">    console.log(&quot;this is a function of myjs object!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; new myjs();</span><br><span class="line">console.log(&quot;myjs.a &#x3D;&#x3D; &quot; + obj.a );</span><br><span class="line">obj.test();</span><br></pre></td></tr></table></figure>

<p>通过上面的代码，我们就给<code>myjs</code>类增加了两个成员，即一个变量<code>a</code>和一个方法<code>test</code>。当我们生成myjs对象时，生成的对象中就有我们之前添加的成员变量和成员方法了。</p>
<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>JS中没有专门用于类继承的语法，不过你可以通过上一节介绍的prototype来实现<code>类继承</code>。在我们正式讲解继承之前，我们先了解一下prototype在内存中是如何表示的。如下图所示：<br><img data-src="https://cdn.avdancedu.com/image/article/js/prototype.jpg" alt="prototype"></p>
<p>通过上图我们可以看到，使用<code>function</code>定义的类并非真实的<code>类</code>，更准确的说它应该是一个<code>构造函数</code>。而类属性<code>prototype</code>指向的才是类的真正地址。</p>
<p>可能很多同学会问JS是如何通过构造函数找到它所在的类的呢？其实这是C语言的一个小巧，其过程是JS调用浏览器，通过浏览器使用C语言中的<code>技巧</code>获取构造函数所在类的地址，这对于浏览器来当然是小菜一碟。</p>
<p>了解了<code>prototype</code>的物理意义后，接下来我们看看类生成的对象在内存中的情况，它与prototype之间的关系又是怎样的？如下图所示。<br><img data-src="https://cdn.avdancedu.com/image/article/js/js_obj.jpg" alt="对象在内存中"></p>
<p>通过上图我们可以看到，JS在创建对象时会为每个对象分配内存空间。更为重要的一点是，多个相同类型的<code>对象</code>会指向同一个prototype。</p>
<p>了解了上面的特性后，我们就可以利用<code>prototype</code>来实现类的继承了。如何来做呢？我们再来举个例子。</p>
<p>首先，我们定义一个基类，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function parent() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;给基类添加一个新的属性 a</span><br><span class="line">parent.prototype.a &#x3D; 1;</span><br></pre></td></tr></table></figure>

<p>然后，我们创建一个子类，并让子类的prototype指向父类，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function child() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">child.prototype &#x3D; new parent();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;再给子类添加一个属性 b</span><br><span class="line">child.prototype.b &#x3D; 2;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建子类</span><br><span class="line">var obj_child &#x3D; new child();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;访问子类的属性</span><br><span class="line">console.log(&quot;a &#x3D; &quot; + obj_child.a);</span><br><span class="line">console.log(&quot;b &#x3D; &quot; + obj_child.b);</span><br></pre></td></tr></table></figure>

<p>执行上面的例子，我们通过浏览器的<code>debugger</code>就可以看到如下结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; 1</span><br><span class="line">b &#x3D; 2</span><br></pre></td></tr></table></figure>

<p>说明child子类确实是继承了parent类。我们再深扒一下，对于上面这段代码表示的继承关系在内存中的物理意义是什么呢？如下图所示：</p>
<p><img data-src="https://cdn.avdancedu.com/image/article/js/js_extend.jpg" alt="js继承"></p>
<p>在JS中，正常情况下每生成一个对象，该对象的 <code>__proto__</code> 都指向该对象的<strong>原始类的地址</strong>。如上图所示parent对象的<code>__proto__</code>指向parent.prototype，child对象的<code>__proto__</code>指向child.prototype。</p>
<p>为什么会这样呢？要理解其中的奥秘，我们必须要知道JS中 <code>new xxx</code> 做了哪些事儿。实际上，<code>new xxx</code> 做了四件事儿，我们以上图中的<code>new parent()</code>为例，它做的四件事儿如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123;&#125;;</span><br><span class="line">obj.__proto__ &#x3D; parent.prototype; &#x2F;&#x2F;即parent</span><br><span class="line">parent.call(obj);                 &#x2F;&#x2F;调用parent的构造函数</span><br><span class="line">return obj;</span><br></pre></td></tr></table></figure>

<p>在这步中，第二步是最关键的，它表明了新对象的<code>__proto__</code>指向了哪里。这样我们就可以理解 <strong>“对象的 <code>__proto__</code> 都指向该对象的原始类的地址”</strong> 这句话了。</p>
<p>当我们理解了 <code>new xxx</code> 的真实含义之后，<code>child.prototype = new parent()</code> 这句代码的含义立马就清楚了，它的含义是改变 <code>child.prototype</code> 的指向， 让他重新指向<code>parent</code>对象。</p>
<p>由于生成parent对象时，它的<code>__proto__</code>指向了parent的<strong>原始类</strong>，因此child.prototype就与parent的prototype建立了连接。</p>
<p>在接下来创建<code>obj_child</code>对象时，由于child.prototype已经指向了parent对象，因此<code>obj_child.__proto__</code>也就指向了parent对象。此时通过 old_child 就可以访问到parent对象的内容了，从而也就达到了继承的目的。</p>
<h2 id="ES6-中的类"><a href="#ES6-中的类" class="headerlink" title="ES6 中的类"></a>ES6 中的类</h2><p>大家对于在JS中使用<code>function</code>方式定义类实在感到很厌烦，就不能与其它语言一样可以使用<code>class</code>来定义类吗？在ES6时代，JS终于可以做到这一点了。</p>
<p>现在我们来看看在JS中该如何定义类吧，例子如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class cls &#123;</span><br><span class="line">    constructor(arg)&#123;</span><br><span class="line">        this.a &#x3D; arg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    do()&#123;</span><br><span class="line">        console.log(&quot;a value &#x3D;&#x3D;&quot; + this.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var t &#x3D; new cls(&#39;hello&#39;);</span><br><span class="line">t.do();</span><br></pre></td></tr></table></figure>

<p>上面的代码是不是看着就舒服多了？但实际上，ES6中的<code>class</code>只是一个<code>语法糖</code>。啥意思呢？也就是说虽然语法上JS改成了与其它面向对象语言一致的用法，但在JS内部还是使用的<code>function</code>的机制来实现的。</p>
<h3 id="公有成员与私有成员"><a href="#公有成员与私有成员" class="headerlink" title="公有成员与私有成员"></a>公有成员与私有成员</h3><p>使用 ES6 中的 <code>class</code> 定义类时，类中的成员默认都是公有成员，外面都可以直接访问到。当然在class中也可以使用<code>#</code>来定义私有成员变量，但一般情况下我们很少用到。我们来看一下例子吧，在上面的代码中做一点修改即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class cls &#123;</span><br><span class="line">    #a;</span><br><span class="line">    constructor(arg)&#123;</span><br><span class="line">        this.#a &#x3D; arg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    do()&#123;</span><br><span class="line">        console.log(&quot;a value &#x3D;&#x3D;&quot; + this.#a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var t &#x3D; new cls(&#39;hello&#39;);</span><br><span class="line">console.log(&quot;#a&#x3D; &quot; + t.#a);</span><br><span class="line">t.do();</span><br></pre></td></tr></table></figure>
<p>我们在上面代码中增加了 <code>#a</code> 变量，因<code>#</code>表示的是私有成员，所以当我们创建对象 <code>t</code> 后，通过 <code>t.a</code> 是无法访问它的，此时只能通过cls类的成员方法<code>do()</code>才能访问 <code>#a</code>变量。</p>
<h3 id="类的继承-1"><a href="#类的继承-1" class="headerlink" title="类的继承"></a>类的继承</h3><p>接下来我们再来看看在 ES6 中如何实现<code>类的继承</code>。在ES5中要实现类继承必须使用<code>prototype</code>，如果你不从内存存储的角度去思考的话，就很难理解它是如何实现<code>类继承</code>的。而在 ES6 中，类的继承就就像我们使用其它语言中的类继承一样，让我们一目了然。</p>
<p>我们来举个例子，你一看就明白了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class parent &#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.a &#x3D; &#39;hello&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class child extends parent &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.b &#x3D; &#39;world&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var c &#x3D; new child();</span><br><span class="line"></span><br><span class="line">console.log(c.a + &quot; &quot; + c.b);</span><br></pre></td></tr></table></figure>

<p>上面的代码定义了两个类，一个父类<code>parent</code>;一个子类<code>child</code>。当我们创建 <code>child</code> 对象 <code>c</code>时，首先会触发 child的构造函数。在child构造函数中，它首先调用 <code>super()</code>方法，而该方法会调用<code>parent</code> 类的构造函数，从而将parent类中的<code>a</code>属性进行初始化。之后又回到child构造函数中对<code>b</code>属性进行初始化，至此所有的初始化工作完成，最终<code>c</code>对象被创建出来。</p>
<p>当c对象创建好后，我们就可以直接访问它里边的 <code>a</code> 和 <code>b</code> 属性了，以上就是ES6中类继承的过程。其过程与其它面向对象语言完成一致，所以大家在使用它时会觉得非常自然。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上我对JS中 ES5 和 ES6 标准中的<code>类</code>做的一些浅显的探究，在ES5 中类是通过<code>function</code>创建了，由于JS最开始并不支持面向对象开发，所以在ES5中使用JS实现面向对象开发的方式让人觉得很<code>诡异</code>。我在理解这部分知识时，也颇费了一翻周折。不过如果你对内存管理比较熟悉的话，从内存管理的角度去理解 ES5 中的类与继承就比较容易了。</p>
<p>对于 ES6 来说，类的定义与类的继承几乎完全照搬了 Java 的语法，所以我们在学习和使用它时就非常方便了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="noopener">阮一峰</a></p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js class typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo中如何画图</title>
    <url>/f3ccc53/</url>
    <content><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/markdown_flow/markdown.jpg" alt="Markdown时序图"></p>
<p>有很多同学觉得用Markdown画图是一个很鸡肋的事儿，一是Markdown画不了太复杂的图，如果图太复杂了估计能把自己绕晕；二是Markdown画不了特别漂亮的图，比如你想通过颜色来区分一些元素的作用Markdown就无能为力了。</p>
<p>我以前也是持有这种态度，所以一直很反对使用Markdown画图。但最近我的思想有所改变，我认为Markdown画图还是有它的优势的。</p>
<a id="more"></a>

<p>Markdown绘图有两方面优势，一是通过Markdown画的图不占带宽，这个优势对我来说特别有吸引力。因为我的主机本来带宽就不足，要是在一篇文章中图片太多的话页面加载的速度就太慢了。</p>
<p>二是Markdown的绘图功能还在不断发展中，没准那天就可以做到手工在页面里直接编辑的程度了，我相信这一天不会太迟到来。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>下面这两幅图就是用Markdown语法绘制的，第一个是流程图，第二个是时序图。看着是不是觉得也还蛮不错的呢？</p>
<ul>
<li><p>流程图</p>
<center>
<div id="flowchart-0" class="flow-chart"></div>
</center>
</li>
<li><p>时序图</p>
</li>
</ul>
<center>
<div id="sequence-0"></div>
</center>

<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>当然，目前要想实现Markdown绘图还需要安装插件，对于每种不同类型图要安装不同的插件。绘制流程图要安装<code>hexo-filter-flowchart</code>; 绘制时序图要安装<code>hexo-filter-sequence</code>。</p>
<p>安装的方法以及Markdown的语法我以后再来补充</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在Markdown上绘制图型还是有它的优势的，尤其对于自建博客的同学会更愿意偿试这种方式绘制图型。</p>
<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: Start|past:>http://www.google.com[blank]
e=>end: End:>http://www.google.com
op1=>operation: My Operation|past
op2=>operation: Stuff|current
sub1=>subroutine: My Subroutine|invalid
cond=>condition: Yes
or No?|approved:>http://www.google.com
c2=>condition: Good idea|rejected
io=>inputoutput: catch something...|request

st->op1(right)->cond
cond(yes, right)->c2
cond(no)->sub1(left)->op1
c2(yes)->io->e
c2(no)->op2->e</textarea><textarea id="flowchart-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.27/webfontloader.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">Alice->Bob: Hello Bob, how are you?
Note right of Bob: Bob thinks
Bob-->Alice: I am good thanks!</textarea><textarea id="sequence-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script>]]></content>
      <tags>
        <tag>hexo 流程图 时序图</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用命令及一些特殊用法</title>
    <url>/423abe9e/</url>
    <content><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/git/git-banner.jpg" alt=""><br>本文主要记录一些工作中常用的 git 命令，以及一些比较特殊的git用法，希望这些命令对您也能有所帮助。</p>
<a id="more"></a>

<h2 id="git-的基本工作原理"><a href="#git-的基本工作原理" class="headerlink" title="git 的基本工作原理"></a>git 的基本工作原理</h2><p>其实要想使用好git，你必须要知道一点git的工作原理，否则你在使用git时就只能死记硬背一些命令。如果你还处理死记硬背一些git命令的阶段，那么一旦你遇到一个非常复杂的或非手棘手的git case时，可以100%肯定你是无法解决的。</p>
<p>因此，了解一点git的基本工作原理是我们每个开发人员都必须的基础知识，下面我就对git的的基本工作原理做一下简要介绍。</p>
<h3 id="git的结构"><a href="#git的结构" class="headerlink" title="git的结构"></a>git的结构</h3><p>首先我们必须要清楚是，git是由三大部分组成的，即本地工作区，本地仓库以及远程仓库。</p>
<ul>
<li>本地工作区，就是你平常写代码或修改代码的地方。</li>
<li>本地仓库，就是我们工作区中.git目录。它里边有一堆子目录，这些子目录都有各自的用途，我们暂且不管。</li>
<li>远程仓库，这个比较好理解了，就是远端的git仓库，比如我们在github上创建的仓库。</li>
</ul>
<p>通过下面这张图我们可以更直观的了解这三大部分：<br><img data-src="https://cdn.avdancedu.com/image/article/git/git_base.jpg" alt="git结构图"></p>
<p>从图中我们可以清楚的知道，平时我们使用git的三个主要命令(git add、git commit、git push)具体都做了些什么:</p>
<ul>
<li>git add: 将本地工作区中代码的修改保存到本地仓库的staged区，即暂存区。</li>
<li>git commit: 将staged区中的内容保存到本地仓库。</li>
<li>git push: 将本地仓库中的内容推送给远程仓库保存。</li>
</ul>
<p>通过上面这张图我们可以得出以下几点重要结论。</p>
<p>第一，git在处理我们的提交时是按顺序、分阶段的。比如我们的一个提交，必须先到 staged 后才能进入本地仓库，这个处理顺序是不能乱的。</p>
<p>第二，git管理中有一个 HEAD 指针，它始终指向正在处理的git commit。而它的前一次git commit 可以用<code>HEAD^</code>表式，它的上上次commit可以用<code>HEAD ^^</code>表式。</p>
<p>第三，当我们想用地本仓库的内容更新本地工作区的内容时，如果 staged 中没有内容，则可以直接用本地仓库的内容更新本地工作区内容。但如果 staged 中有内容，则需要先更新staged ，然后再更新本地工作区。</p>
<p>第四，git的核心是本地仓库，所有的操作都是围绕着它来的。它既是用户<code>commit</code>的终点，又是远程仓库的接收<code>commit</code>起点。我们在使用git时，可以向本地仓库提交多次修改，而只向远程仓库推送一次，git推送时会将之前的多个<code>commit</code>合并到一起。</p>
<h3 id="git的分支管理"><a href="#git的分支管理" class="headerlink" title="git的分支管理"></a>git的分支管理</h3><p>在git中还有一个特别重要的概念就是branch，即分支。它是我们多人合作开发的基础。如下图所示：<br><img data-src="https://cdn.avdancedu.com/image/article/git/git_branch.jpg" alt="git 分支"></p>
<p>通过上图我们可以清楚的知道，git是以<strong>指针</strong>的方式对分支进行管理的。下面我们来详述一下git是如何管理分支的。</p>
<p>当我们执行<code>git init</code>时，git默认为我们创建一个分支，即<code>Master</code>分支。而HEAD指针也被初始化指向Master分支，因此每当你提交新的修改时，这些修改都会被压入到Master分支<strong>栈</strong>上。</p>
<p>当然一般情况下我们都不会轻易对Master分支做操作，而是创建一个<code>Dev</code>分支作为我们的开发分支。在git中你可以执行<code>git branch branchname</code>命令来创建一个新分支，比如将branchname设置为<code>Dev</code>，这样我们就创建出了<code>Dev</code>分支。</p>
<p>然后你可以执行<code>git checkout Dev</code> 命令，它的作用是让<code>HEAD</code>指向Dev分支。后面你所有的commit就都被<strong>push</strong>到Dev分支上了。</p>
<p>如果你觉得执行两条命令比较麻烦，你也可以将上面的两步合并为一步，执行<code>git checkout -b branchname</code>这一条命令就可以了，这也是我们平常真正使用的命令。</p>
<p>通过上面的描述，我想你应该对git的工作原理有了最基本的了解了，下面我们再来看这些命令时就很容易理解它们的作用以及为什么要这么做了。</p>
<h2 id="已有代码该如何提效到仓库中"><a href="#已有代码该如何提效到仓库中" class="headerlink" title="已有代码该如何提效到仓库中"></a>已有代码该如何提效到仓库中</h2><p>第一步，在github 上创建一个仓库。<br>第二步，执行下面的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:avdance&#x2F;test.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<h2 id="本地与远程有突冲，想放弃本地修改"><a href="#本地与远程有突冲，想放弃本地修改" class="headerlink" title="本地与远程有突冲，想放弃本地修改"></a>本地与远程有突冲，想放弃本地修改</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard FETCH_HEAD</span><br></pre></td></tr></table></figure>

<h2 id="重新从远端拉取某个文件"><a href="#重新从远端拉取某个文件" class="headerlink" title="重新从远端拉取某个文件"></a>重新从远端拉取某个文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -- a.c</span><br></pre></td></tr></table></figure>

<h2 id="撤消某次-add"><a href="#撤消某次-add" class="headerlink" title="撤消某次 add"></a>撤消某次 add</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rm --cached &lt;added_file_to_undo&gt;</span><br></pre></td></tr></table></figure>

<h2 id="撤消某次-commit"><a href="#撤消某次-commit" class="headerlink" title="撤消某次 commit"></a>撤消某次 commit</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --soft commitID  只是删除了commitId之后的commit记录,但是代码改动仍然存在</span><br><span class="line">git reset --hard commitID  彻底的回到CommitID时候的版本,之后的改动不存在了</span><br></pre></td></tr></table></figure>

<h2 id="将本地修改先暂存起来"><a href="#将本地修改先暂存起来" class="headerlink" title="将本地修改先暂存起来"></a>将本地修改先暂存起来</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash 将本地修改暂存起来</span><br><span class="line">git stash pop 弹出暂存的修改</span><br></pre></td></tr></table></figure>

<h2 id="查看有冲突的文件"><a href="#查看有冲突的文件" class="headerlink" title="查看有冲突的文件"></a>查看有冲突的文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status -uno</span><br></pre></td></tr></table></figure>

<h2 id="不显示临时文件"><a href="#不显示临时文件" class="headerlink" title="不显示临时文件"></a>不显示临时文件</h2><p>在 .gitignore 中添加不想被 git staus 看到的文件或目录</p>
<h2 id="暂时回滚到某版本"><a href="#暂时回滚到某版本" class="headerlink" title="暂时回滚到某版本"></a>暂时回滚到某版本</h2><p>首先通过 git log查看你之前的提交码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log | more</span><br></pre></td></tr></table></figure>
<blockquote>
<p>commit 4adb3f0ecd9dbc79bd09666d88f8c2520305c001<br>Author: xxxxxx<br>Date:   Thu Jan 25 11:51:45 2018 +0800</p>
</blockquote>
<p>摘取 commit 码的前 7位，执行下面的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout 4adb3f0</span><br><span class="line">git reset --hard 4adb3f0</span><br></pre></td></tr></table></figure>

<h2 id="切换-回滚到主分支"><a href="#切换-回滚到主分支" class="headerlink" title="切换/回滚到主分支"></a>切换/回滚到主分支</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>

<h2 id="服务端有更新，但你却-commit了你的代码"><a href="#服务端有更新，但你却-commit了你的代码" class="headerlink" title="服务端有更新，但你却 commit了你的代码"></a>服务端有更新，但你却 commit了你的代码</h2><ul>
<li><p>先拉取服务端代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure></li>
<li><p>提交代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure></li>
<li><p>如果你在 dev分支，此时还要拉取master的代码<br><strong>1. 先 切换到 master 分支</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>

<p><strong>2. 拉取代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<p><strong>3. 重新切换到 dev 分支</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout dev</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="查看每次提交的文件列表"><a href="#查看每次提交的文件列表" class="headerlink" title="查看每次提交的文件列表"></a>查看每次提交的文件列表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --stat | more</span><br></pre></td></tr></table></figure>

<h2 id="查看某些提交代码的变化"><a href="#查看某些提交代码的变化" class="headerlink" title="查看某些提交代码的变化"></a>查看某些提交代码的变化</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git show &lt;commit id&gt; [&lt;filename&gt;]</span><br></pre></td></tr></table></figure>
<h2 id="显示所有本地与远端分支"><a href="#显示所有本地与远端分支" class="headerlink" title="显示所有本地与远端分支"></a>显示所有本地与远端分支</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure>
<h2 id="显示所有远程分支"><a href="#显示所有远程分支" class="headerlink" title="显示所有远程分支"></a>显示所有远程分支</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure>
<h2 id="显示远端地址"><a href="#显示远端地址" class="headerlink" title="显示远端地址"></a>显示远端地址</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>
<h2 id="创建一个新分支"><a href="#创建一个新分支" class="headerlink" title="创建一个新分支"></a>创建一个新分支</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b new_branch</span><br><span class="line">git --set-upstream origin new_branch</span><br><span class="line">git push origin new_branch</span><br></pre></td></tr></table></figure>
<h2 id="远程仓库已经删除，而本地仓库还在，如果清除？"><a href="#远程仓库已经删除，而本地仓库还在，如果清除？" class="headerlink" title="远程仓库已经删除，而本地仓库还在，如果清除？"></a>远程仓库已经删除，而本地仓库还在，如果清除？</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull -p</span><br></pre></td></tr></table></figure>
<h2 id="git-diff-不显示修改的内容"><a href="#git-diff-不显示修改的内容" class="headerlink" title="git diff 不显示修改的内容"></a>git diff 不显示修改的内容</h2><p>有些情况下，通过 <code>git status</code> 能查到某些文件有变化，但使用 <code>git diff</code> 却看不到修改的内容。可以使用下面的面试查看变化。</p>
<ul>
<li>第一种方法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff --cached 文件名</span><br></pre></td></tr></table></figure></li>
<li>或者<br>先将修改的文件重命名，然后执行下面的语句<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset HEAD</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="配置更好的-git-diff-工具"><a href="#配置更好的-git-diff-工具" class="headerlink" title="配置更好的 git diff 工具"></a>配置更好的 git diff 工具</h2><p>在使用 git diff 时，常常发现有很多不方便的地方。因为git diff 默认使用 patch 方式展示代码的不同。如果想看修改后代码的上下文就比较麻烦了（比如代码 review）。</p>
<p>其实 git 已经提供了扩展功能。可经将它的默认 diff 工具修改为vimdiff。配置如下：</p>
<ul>
<li>首先打开 git config 文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~&#x2F;.gitconfig</span><br></pre></td></tr></table></figure></li>
<li>增加配置项<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[difftool]</span><br><span class="line">    prompt &#x3D; false</span><br><span class="line">[diff]</span><br><span class="line">    vimdiff</span><br><span class="line">    tool &#x3D; vimdiff</span><br><span class="line">[difftool &quot;vimdiff&quot;]</span><br><span class="line">    path &#x3D; &#x2F;usr&#x2F;bin&#x2F;vimdiff</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="打tag"><a href="#打tag" class="headerlink" title="打tag"></a>打tag</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;为git打tag, 第一次需要在前面加一个v</span><br><span class="line">git tag &quot;v1.0.0&quot;</span><br><span class="line">&#x2F;&#x2F;将tag推送到远程仓库</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure>

<h2 id="git-merge-每次都生成一次commit"><a href="#git-merge-每次都生成一次commit" class="headerlink" title="git merge 每次都生成一次commit"></a>git merge 每次都生成一次commit</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge --no-ff</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：ff表示 fast forward</p>
</blockquote>
<h2 id="切到某个tag"><a href="#切到某个tag" class="headerlink" title="切到某个tag"></a>切到某个tag</h2><p>与切到某个分支是类似的，只不过将branch 名换为 tag 名而以。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout tag_name</span><br></pre></td></tr></table></figure>

<h2 id="查看某个人的所有提交"><a href="#查看某个人的所有提交" class="headerlink" title="查看某个人的所有提交"></a>查看某个人的所有提交</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --author&#x3D;“author”</span><br></pre></td></tr></table></figure>

<h2 id="为git设置默认用户名和密码"><a href="#为git设置默认用户名和密码" class="headerlink" title="为git设置默认用户名和密码"></a>为git设置默认用户名和密码</h2><p>在使用Git 的时候，经常会遇到需要频繁输入密码的情况，每次git push 和 git pull 都要求输入用户名和密码，如果提交频繁的话就十分不方便。</p>
<p>可以使用下面的方法，只需要第一次输入用户名和密码，以后都不用再输入了。</p>
<h3 id="进入Git-配置文件"><a href="#进入Git-配置文件" class="headerlink" title="进入Git 配置文件"></a>进入Git 配置文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~&#x2F;.gitconfig</span><br></pre></td></tr></table></figure>

<h3 id="修改配置文件，添加下面这一行。"><a href="#修改配置文件，添加下面这一行。" class="headerlink" title="修改配置文件，添加下面这一行。"></a>修改配置文件，添加下面这一行。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[credential]  </span><br><span class="line">    helper &#x3D; store</span><br></pre></td></tr></table></figure>

<p>##修改已提交的commit的用户名邮箱</p>
<ol>
<li><p>第一步</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;newName&quot;</span><br><span class="line">git config --global user.email &quot;newEmail&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改已提交commit的用户名邮箱</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit --amend --author&#x3D;&quot;userName &lt;userEmail&gt;&quot;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>注意不能缺少<code>&lt; &gt;</code></strong><br><strong>此指令仅能更新最近的一次commit的用户名邮箱</strong></p>
<h2 id="git-应用-patch"><a href="#git-应用-patch" class="headerlink" title="git 应用 patch"></a>git 应用 patch</h2><ol>
<li>预览patch的结是</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git apply --stat file.patch</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>检测patch后是否有错误</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git apply --check file.patch</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>打patch</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git am --signoff &lt; a_file.patch</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>执行commit</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git  commit -m &quot;&quot;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>提交代码</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>

<h2 id="循环克隆"><a href="#循环克隆" class="headerlink" title="循环克隆"></a>循环克隆</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone --recursive https:&#x2F;&#x2F;xxx.git</span><br></pre></td></tr></table></figure>
<h2 id="给代码设置两个不同的源"><a href="#给代码设置两个不同的源" class="headerlink" title="给代码设置两个不同的源"></a>给代码设置两个不同的源</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote set-url origin https:&#x2F;&#x2F;xxx.git</span><br></pre></td></tr></table></figure>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>命令在不断更新中…</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">廖雪峰git教程</a></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客系统的实现原理与搭建</title>
    <url>/2ef51851/</url>
    <content><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/hexo/hexo-logo.png" alt=""></p>
<p>作为技术人员，定期写Blog是一个非常好的习惯。你可以通过它将自己的一些学习心得记录下来，也可以对平常的工作做一些经验总结等等。对于我来说Blog就更为重要了，因为Blog是我推广<strong>音视频技术</strong>的一块<strong>“阵地”</strong>，我需要将我写的一些<strong>音视频技术</strong>知识、视频课程中的问题解答等内容放在它上面，以便同学们交流学习。</p>
<a id="more"></a>

<p>以前，我的文章一直都在<strong>简书</strong>上发布，可最近不知为何，简书将我的账户封掉了。我经多次申诉却依然无果，既不告之那里违规，也不给我解封，真让人无语！考虑到在其它平台也可能遇到类似情况，因此决心搭建自己的博客，这样才能放心。</p>
<p>如何才能快速搭建一套比较专业的博客系统呢？通过调研，我发现开源项目<strong>hexo</strong>完全可以满足我的要求。它既可以发布文章，还支持一些常见的功能，如阅览数、文章字数统计、本地搜索等等。下面我就来详细讲述一下我是如何通过<strong>hexo</strong>搭建自已的博客系统的。</p>
<h2 id="Blog系统"><a href="#Blog系统" class="headerlink" title="Blog系统"></a>Blog系统</h2><p>在搭建Blog系统之前，我们有必要先了解一下Blog系统是干什么的，它都应该有哪些功能。</p>
<p>Blog是在2000年左右出现的，原本的称法为weblog，即网络日志。后来逐渐被人们改为 we blog，进而简称为Blog。Blog中的每一篇文章/日志就是一个页面，Blog将这些页面聚集在一起就形成了现在的形式。</p>
<p>现在大家在写Blog时已经很少直接写在页面里了，而是改用Markdown语法，这种语法非常简洁，特别适合我们平常的写作。所以现今的Blog系统最重要的一个环节就是，将Markdown语法写成的文档转化成HTML页面，然后放到Web服务器上发布出来。除此之外，Blog还要有一个管理系统可以将这些页面管理起来，如生成目录、标签，分类、搜索等等。</p>
<p>如果要我们自己实现这样一套系统还是非常麻烦的，好在已经有开源项目实现了，这就是<strong>hexo</strong>。hexo 不但实现了这些功能，还实现了很多其它的功能，如文章浏览次数、打赏、接入评论系统等等。这些功能对于我们来说都是非常有用的，然而在讲解如何搭建这些功能之前，我们先来了解一下hexo的实现原理，这样可以让我们更容易理解后面的知识。</p>
<h2 id="hexo基本原理"><a href="#hexo基本原理" class="headerlink" title="hexo基本原理"></a>hexo基本原理</h2><p>要了解hexo的实现原理，我们首先要知清楚 hexo 的目录结构，这样可以更有助于了解hexo。</p>
<p>hexo由以下几个重要文件/目录组成：</p>
<ul>
<li>_config.yml，该文件是hexo 的<code>站</code>级配置文件。所谓<strong>站</strong>级配置文件是指，对整个站点起效果的配置文件。</li>
<li>source目录，该目录存放源文件。即用户编写的博文都放在该目录下。在该目录下又有几个子目录我们来分别看一下。<ul>
<li>_post，用于存放博文，基本上每篇文章都是由Markdown语法编写的。</li>
<li>tags，存放tag 的文件。hexo中的tags是自动生成的，所以我们不用手动修改tags目录下的index.md文件，在发布时它会自动生成。</li>
<li>categories，存放<strong>分类</strong>。它与tags是类似的，也是自动生成的，所以不需要我们手工修改。</li>
<li>…</li>
</ul>
</li>
<li>themes目录，该目录用于存放主题，目前hexo中最热门的主题就是<strong>next</strong>了。最近的 next release 版本是 7.8 。</li>
<li>public目录，该目录存放hexo转出的文件，如html、css、js等。</li>
<li>scaffolds目录，它里面存放了一些<strong>“脚手架”</strong>程序，用于生成模板页面，如执行<code>hexo new &quot;title&quot;</code>时，就会生成一个Markdown文件模板。</li>
</ul>
<p>上面就是hexo中最重要的几个文件和目录了。</p>
<p>清楚之hexo目录结构之后，我们再来看看hexo的基本原理。</p>
<p>hexo最基本的功能是将Markdown程序转成HTML页面，而这个转换并不是一次完成的，要经历两步:</p>
<ul>
<li><p>第一步，将Markdown翻译成下面格式的JSON对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">article: &#123;</span><br><span class="line">  title:</span><br><span class="line">  date:</span><br><span class="line">  tags:</span><br><span class="line">  categories:</span><br><span class="line">  content:</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步，根据上面生成的JSON对象生成 HTML 页面。</p>
</li>
</ul>
<p>对于我们来说，清楚了上面hexo将Markdown转HTML页面的过程后，我们就很容易理解hexo 在执行不同命令时它都在做什么事儿了。</p>
<p>下面我们再来看看<strong>hexo</strong>的组成，它由三部分组成: <strong>hexo-cli</strong>、<strong>hexo-core</strong>以及<strong>hexo plugs</strong>。在这三部分中最核心的是hexo-core模块，它的作用就是执行上面讲的两步转换，从而生成目标文件；hexo-cli为我们供了一些非常方便的命令。当我们敲入命令时，它会根据命令调用不同的模块；hexo plugin是hexo的扩展，当hexo本身不能完成某项任务时，它允许你自己开发一个插件来完成。当然你也可以使用其它人写好的插件。</p>
<p>上以就是hexo的基本原理。</p>
<h2 id="hexo的常用命令"><a href="#hexo的常用命令" class="headerlink" title="hexo的常用命令"></a>hexo的常用命令</h2><p><strong>hexo</strong> 提供了几个常用命令，如<code>hexo clean</code>、<code>hexo g</code>、<code>hexo s</code>等等。下面我们分别看一下这几个命令的具体作用是什么：</p>
<ul>
<li>hexo clean: 删除 hexo 生成的所有文档。当我们执行这个命令后，你会发现public目录被删除了。</li>
<li>hexo g: 根据 source 目录中的文件生成html等可以发布的文件。</li>
<li>hexo s: 在本地起动 <strong>http</strong> 服务，将生成的 html  等输出文件布署到本地服务器上。 </li>
<li>hexo d: 将生成的html代码推送到 github 上</li>
</ul>
<p>这几个命令的含义都非常清晰，我就不再做其它赘述了。</p>
<h2 id="hexo发布页面"><a href="#hexo发布页面" class="headerlink" title="hexo发布页面"></a>hexo发布页面</h2><p>如上面所介绍的，我们可以使用<code>hexo d</code>命令将生成的目标文件发布出来，但在使用它之前，你需要在站节点的_config.yml文件中配置发布的方法。我们举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">- type: git #leancloud_counter_security_sync #git</span><br><span class="line">  repo: git@github.com:avdance&#x2F;avdance.github.io.git</span><br></pre></td></tr></table></figure>

<p>当我们执行<code>hexo d</code>命令时，它会调用 hexo 中的 <code>hexo-deployer-git</code> 插件。在该插件内部会启动一个进程调用<code>git</code>命令，从而将生成的html等代码上传到 github上。</p>
<p>这里可能有些同学会有疑问，为什么上传到github上就算是发布了呢？这是因为github为我们提供了免费的个人博客空间。只要你在github上创建一个<code>用户名.github.io</code>的项目，github就会自动将这个项目中的文件发布出来。</p>
<p>当然你也可以采用传输的方式，自己购买台云主机，然后在云主机上用ngnix、nodejs等搭建一个Web服务，最终将页面发布出来。</p>
<h2 id="next主题的安装与配置"><a href="#next主题的安装与配置" class="headerlink" title="next主题的安装与配置"></a>next主题的安装与配置</h2><p>hexo中有很多的主题，但其中用的最多的、最著名的就是<strong>next</strong>主题了。下面我们就来介绍一下，如何安装next主题并对其做一些简单的配置。</p>
<p>next的安装比简单了，你只需要将next源码从github上下载下来，然后放到hexo的themes目录下即可。如下面这行语句:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone --branch v7.8.0 https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next.git themes&#x2F;next</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，我们在github中搜索关键字<code>hexo-theme-next</code>时，你会发现有两个github star数特别多，这两个地址分别是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;iissnan</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;theme-next</span><br></pre></td></tr></table></figure>
<p>上面的地址是next老版本的官方地址，下面这个是新版本的官方地址。你清楚他们之间的关系就不会给你造成混乱了。</p>
<p>next下载好后，下一步就是进行配置了。在themes/next目录下也有一个_config.yml文件，它是next主题的配置文件，千万不要将它与站点的_config.yml弄混了。</p>
<p>如果你要配置next主题时，需要修改的是themes/next目录下的_config.yml文件。</p>
<p>打开该文件，找到<code>Scheme</code>关键字，你会发现next支持多种Scheme。你可以根据喜好选择你自己喜欢的Scheme，我这里选择的是<code>Gemini</code>。选择好Scheme后，我们博客的基本结构就定下来了。接下来你可以对它进行配置了。具体的配置我会在下面再做详细论述。</p>
<p>当所有的配置都修改好后，你可以执行下面的命令将博客发布出来了。</p>
<blockquote>
<ul>
<li>hexo clean</li>
<li>hexo g</li>
<li>hexo s</li>
</ul>
</blockquote>
<h2 id="高级知识"><a href="#高级知识" class="headerlink" title="高级知识"></a>高级知识</h2><p>通过上面的操作，我们就将自己的Blog搭建好了。但此时这个Blog还只是一个最基本、最简单的Blog。如果你想让你的Blog更专业的话，还要对它进行细细的打磨。</p>
<p>接下来，我们就来看看还需要对我们的Blog做哪些处理?</p>
<ul>
<li>为文章设置摘要</li>
<li>增加图片床</li>
<li>统计阅读次数</li>
<li>显示文章字个数</li>
<li>添加评论区</li>
<li>文章置顶</li>
<li>设置标签</li>
<li>设置标签云</li>
<li>增加本地搜索</li>
<li>设置关于</li>
<li>设置404</li>
<li>SEO优化</li>
</ul>
<p>下面我们就按着这个清单细细打磨我们的Blog吧。</p>
<h3 id="为文章设置摘要"><a href="#为文章设置摘要" class="headerlink" title="为文章设置摘要"></a>为文章设置摘要</h3><p>在hexo中实现摘要有两种方法，一种主是在正文中加入如下代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure>

<p>它的作用是将<code>more</code>之前的文字作为摘要。</p>
<p>需要注意的是，一般情况下摘要都在 200 字以内，所以你自己要控制好放置<code>more</code>的位置。这种方式是我最常使用的方式，感觉非常方便。</p>
<p>第二种方法是，在文章头的 <code>description</code> 域写摘要，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: xxxx</span><br><span class="line">date: xxxx-xx-xx</span><br><span class="line">...</span><br><span class="line">description: xxxxxxx...</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>这处方式的好处是，可以将文中某一段设置为摘要，或者自己单独写一段摘要。所以这种方式更灵活，也更便于做 SEO 优化。</p>
<p>以上两种方法都可以，你可以根据自己的习惯选择最合适自已的方法。</p>
<h3 id="增加图片床"><a href="#增加图片床" class="headerlink" title="增加图片床"></a>增加图片床</h3><p>我们文章发布时，一般都是通过github发布出来，但必竟github给我们每个人的资源是有限的。如果你在github上放一些特别大的文件的话，那么你博客的访问速度一定很慢，甚至会严重影响用户的体验。</p>
<p>另外不论你在哪儿发布文章，一条必须遵守的原则是，尽量避免在主站上放置特别大的文件，尤其是图片。但现实是残酷的，有写作经验的同学都知道，在文章中放一些图片不但可以让读者更容易理解的要表达的思想，而且还有美化文章的作用。</p>
<p>如何解决上述的矛盾呢？ 答案就是使用<strong>图床</strong>。所谓图床，其实就是使用云存储(像阿里云、腾讯云、七牛云)来存储图片，然后用CDN进行加速。这样可以大大优化网站的访问速度。</p>
<p>我搭建的Blog使用的就是阿里云的云加速。对于使用阿里云加速的方法我这里就不赘述了，有兴趣的小伙伴可以到阿里的官网上自行查阅使用说明。</p>
<h3 id="统计阅读次数"><a href="#统计阅读次数" class="headerlink" title="统计阅读次数"></a>统计阅读次数</h3><p>由于hexo自己没有提供数据库的功能，因此对文章访问次数的统计需要通过第三方云服务来提供支持。</p>
<p>大多数情况下，我们使用leancloud做服务统计，而且hexo中也实现了与之相关的接入代码。当然，你也可以通过云数据库来实现这个功能，至于你选择那种方案就看你自己的喜好了。</p>
<p>下面我就来介绍一下通过leancloud如何实现统计阅读次数这一功能。</p>
<p>首先，你要注册一个leancloud账户。leancloud上提供了两种用户类型，一种是developer，一种是商业用户。developer用户是免费的，但有限制。不过这种限制对于我们这种访问量很少的Blog来说是无所谓的。</p>
<p>注册好用户后，我们需要在leancloud上创建一个<strong>class</strong>，这里的<code>class</code>类似于关系型数据库中的表。class的名子是固定的，必须是<code>Counter</code>，只有这样 hexo 才能将数据保存到leancloud上，也才能真正的实现阅读量的统计，</p>
<p>leancloud class创建好后，我们就要对hexo进行配置了。实际上，真正进行统计的模块是next。如果你使用的是其它主题的话，那就要找对应的统计方法。</p>
<p>对于next来说，它的V5版本与V7版本在使用leancloud的方法是不一样的。据说V5版本存在统计漏洞，很容易被黑客攻击，因此改为现然V7的方式了。</p>
<p>不过经我测试，V5的方式配置起来比较简单，V7的方式我没有验证通过。也就是说，通过V7的方法无法进行阅读量统计。我想一定是我那里没有配置对，希望有这方面经验的同学可以分享一下。</p>
<p>下面我们来看看如何修改next的配置使其与leancloud相联(这里讲的是V5的方法)。打开themes/next目录下的_config.yml文件，找到<code>leadcloud_visitors</code>关键字，修改其配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">leancloud\_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  app\_id: &lt;your app id&gt;</span><br><span class="line">  app\_key: &lt;your app key&gt;</span><br></pre></td></tr></table></figure>

<p>这三个字段的含义如下，<code>enable</code>表示是否开启leadcloud_visitors功能，所以这个选项我们要修改为true；<code>app_id</code>是你注册leancloud时分配给你的ID; <code>app_key</code>也是你注册leancloud时分配的。只要我们将上面的参数配置好后，当你再浏览你的文章时，就会发现访问次数发生变化了。</p>
<h3 id="统计文章字数"><a href="#统计文章字数" class="headerlink" title="统计文章字数"></a>统计文章字数</h3><p>hexo本身并不支持文章字数的统计，因此要想实现这一功能我们需要安装一个插件，即<code>hexo-symbols-count-time</code>。在以前，大家都使用wordcount插件，但到了next V6之后<code>hexo-symbols-count-time</code>逐渐替代了<code>wordcount</code>。</p>
<p>下面我们来看一下如何使用<code>hexo-symbols-count-time</code>插件。使用它之前我们需要先将其安装好，执行下面的命令即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>

<p>hexo-symbols-count-time插件安装完成后，我们要修改两个配置文件: hexo 中的_config.yml文件和next主题中的_config.yml文件。</p>
<p>第一步，修改hexo中的_config.xml的<code>symbols\_count\_time</code>项，修改配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置博客单词统计</span><br><span class="line">symbols_count_time:</span><br><span class="line">  # 文章字数统计</span><br><span class="line">  symbols: true</span><br><span class="line">  # 文章阅读时间统计</span><br><span class="line">  time: true</span><br><span class="line">  # 站点总字数统计</span><br><span class="line">  total_symbols: false</span><br><span class="line">  # 站点总阅读时间统计</span><br><span class="line">  total_time: false</span><br><span class="line">  exclude_codeblock: false</span><br></pre></td></tr></table></figure>
<p>第二步，修改 themes/next 目录下的 _config.yml 文件，仍然找 <code>symbols_count_time</code> 项，配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置博客单词统计</span><br><span class="line">symbols_count_time:</span><br><span class="line">  # 是否另起一行（true的话不和发表时间等同一行）</span><br><span class="line">  separated_meta: true</span><br><span class="line">  # 首页文章统计数量前是否显示文字描述（本文字数、阅读时长）</span><br><span class="line">  item_text_post: true</span><br><span class="line">  # 页面底部统计数量前是否显示文字描述（站点总字数、站点阅读时长）</span><br><span class="line">  item_text_total: false</span><br><span class="line">  # 平均字长</span><br><span class="line">  awl: 4</span><br><span class="line">  # 每分钟阅读字数</span><br><span class="line">  wpm: 275</span><br></pre></td></tr></table></figure>

<p>上面的配置修改后，文章字数统计功能就算配置好了，现在只要你重新生成静态页面，然后发布出来就可以看到效果了。</p>
<h3 id="如何添加评论系统"><a href="#如何添加评论系统" class="headerlink" title="如何添加评论系统"></a>如何添加评论系统</h3><p>hexo还可以接入评论系统，而且可以接入多种评论系统。在从多的评论系统中，Valine是其中一款比较出众的评论系统。</p>
<p>hexo接入valine非常容易，就像之前介绍的接入阅读统计系统一样，它也需要在leancloud系统上创建一个类，即 <code>Comment</code>类，用于保存用户的评论。</p>
<p>因此我们在接入用户评论系统时，需要经过以下几步:</p>
<ul>
<li>第一步，在leancloud上创建comment类；</li>
<li>第二步，修改 themes/next 目录下的_config.yml 文件，做如下配置：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">valine:</span><br><span class="line">  enable: true #是否接入valine 系统</span><br><span class="line">  appid:  #LeanClound获得的appid</span><br><span class="line">  appkey: #LeanClound获得的appkey</span><br><span class="line">  notify: false # 邮件提醒</span><br><span class="line">  verify: false # Verification code</span><br><span class="line">  placeholder: 欢迎畅所欲言 # 占位字符串 </span><br><span class="line">  avatar: mm #默认头像设置</span><br><span class="line">  guest_info: nick #评论区的title </span><br><span class="line">  pageSize: 10 # Pagination size</span><br><span class="line">  language: zh-cn # Language, available values: en, zh-cn # 语言，设为zh-cn</span><br><span class="line">  # 是否开启当前文章阅读量统计</span><br><span class="line">  visitor: false #这个要设置为false，以免与 leancloud_visitors 突冲 </span><br><span class="line">  comment_count: true #是否在主页里也显示评论个数，为false是不显示</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>通过上面的设置后，你就可以在文章中看到评论区了。</p>
<p>实际上，我们还可以真对每一篇文章单独设置是否显示评论区，如何做呢？</p>
<p>只要你在想要关闭评论区的文章头加上<code>comments: false</code>这句即可。具体例子如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">date: 2019-07-18 15:16:50</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure>

<p>到此为止，我们就将评论系统接入到我们的博客中了。</p>
<h3 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h3><p>文章写好后，有一些我们认为特别好的文章希望置顶，这该如何做呢？</p>
<p>hexo默认的方式是按时间顺序排放文章的，也就是最后写完的文章会放在最一个。如果要打破这个规则，我们就需要给它建立一个新规则。</p>
<p>应该定义个什么样的规则呢？实际上已经有人帮我们想好了，就是给文章做个编号，有编号的优先排序，并且按照编号进行排序；而没有编号的再按时间排序，这样就解决了我们想将文章顶置的需求。</p>
<p>更好的消息时，现在hexo已经有了这样一个新的排序插件叫<code>hexo-generator-index-pin-top</code>，我们只需要用它替换原来老的排序插件即可。具体操作步骤如下：</p>
<ul>
<li>先将老的排序插件删除掉<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn remove hexo-generator-index</span><br></pre></td></tr></table></figure></li>
<li>按装新插件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add hexo-generator-index-pin-top</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>光安装好插件还不行，我们要想让文章置顶还要修改文章的title域，在title域中增加一个<strong>top</strong> 域，这样这篇文章就会被置顶了。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----</span><br><span class="line">title: xxxx</span><br><span class="line">date: xxxx-xx-xx</span><br><span class="line">...</span><br><span class="line">top: 1</span><br><span class="line">...</span><br><span class="line">----</span><br></pre></td></tr></table></figure>
<p>经上面这样设置后，我们想置顶的文章就会跑到主页的顶部，马上去试试看吧。</p>
<p>不过这里还有一个小问题，文章是置顶了，但对于用户来说却感受不到。从用户的角度看，如果不仔细观察的话还真不会发现前面几篇文章是置顶文章。有没有办法可以将置顶文章做个标识呢？</p>
<p>当然有办法，不过我们需要修改一点next主题的代码了。我们进行到<code>next/layout/_macro</code>目录下，打开post.swig文件，找到 <code>&lt;div class=&quot;post-meta&quot;&gt;</code> 标记，然后在它下面添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">  &lt;i class&#x3D;&quot;fa fa-thumb-tack&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  &lt;font color&#x3D;7D26CD&gt;置顶&lt;&#x2F;font&gt;</span><br><span class="line">  &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>经过这样的设置后，我就可以在博客主页中看到前面被置顶的文章被打上标记了。打开<a href="https://blog.avdancedu.com">我的博客</a>你应该就可以看到真实的效果了。</p>
<h3 id="如何开启打赏功能"><a href="#如何开启打赏功能" class="headerlink" title="如何开启打赏功能"></a>如何开启打赏功能</h3><p>hexo 中 next 主题开启打赏功能非常简单，只要稍微配置一下就可以了。在里需要普及一些支付的基本知识，对于正常的支付来说，当用户点击打赏时，可以选择要打赏的金额，之后应该调用腾讯或阿里的支付接口，最终完成支付。但对于hexo来说，显然它做不了这么复杂的交互逻辑，那它是如何做的呢？</p>
<p>实际上，它只是将微信/支付完的收款二维码放到网页上面来实现打赏功能的。具体的步骤如下：</p>
<ul>
<li>生成收款二维码，打开微信/支付宝，将收款二维码保存成图片。</li>
<li>编辑next主题下面的_config.xmy文件，将该文件中的<code>reward\_settings</code>打开即可。具体配置如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Reward (Donate)</span><br><span class="line">reward\_settings:</span><br><span class="line">  enable: true</span><br><span class="line">  animation: true</span><br><span class="line">  comment: 只想买包辣条</span><br><span class="line"></span><br><span class="line">reward:</span><br><span class="line">  wechatpay: &#x2F;images&#x2F;wechatpay.png   #微信收款码</span><br><span class="line">  alipay: &#x2F;images&#x2F;alipay.png   #支付宝收款码</span><br><span class="line">  #bitcoin: &#x2F;images&#x2F;bitcoin.png</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>通过上面的设置，我们就将hexo的打赏功能设置好了。</p>
<h3 id="添加标签和分类"><a href="#添加标签和分类" class="headerlink" title="添加标签和分类"></a>添加标签和分类</h3><p>在hexo中给文章添加标签并给文章分类很容易，只要在文章头里加 <code>tags</code> 和<code>categories</code>域即可。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: xxx    &#x2F;&#x2F;在此处添加你的标题。</span><br><span class="line">date: 2016-10-07 13:38:49   &#x2F;&#x2F;在此处输入编辑这篇文章的时间。</span><br><span class="line">tags: [aaa, bbb, ccc]    &#x2F;&#x2F;在此处输入这篇文章的标签。</span><br><span class="line">categories: xxx, yyy    &#x2F;&#x2F;在此处输入这篇文章的分类。</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>通过上面的例子我们可以看到，可以给一篇文章增加多个tag，也可以将文章划分到多个不同的类别中去。</p>
<p>除了在文章中我们可以给文章打多个标签和分类外，我们还应该将hexo next中的标签/分类入口打开，这样可以方便用户查看博客中所有的标签和分类，从而可以快速找到它们感兴趣的文章。</p>
<p>具体做法如下，进入到 themes/next 目录，打开_config.yml 文件，找到<code>menu</code>项，配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">home: &#x2F;|| home</span><br><span class="line">tags: &#x2F;tags&#x2F;|| tags</span><br><span class="line">categories: &#x2F;categories&#x2F;|| th</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>通过上面的配置，我们就将<strong>标签</strong>和<strong>分类</strong>入口打开了。不过光打开入口还不行，我们还要创建 tag 和 categories 目录和文章，执行下面的命令即可完成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page tags&#x2F;categories</span><br></pre></td></tr></table></figure>

<p>执行完上述命令后，我们就可以在source目录下看到tags和categories目录了。</p>
<p>此时，我们重新执行<code>hexo g</code>生成页面，你就可以看到我们在文章中打的标签和分类被写到各目录的index文件中了。</p>
<h3 id="如何设置标签云"><a href="#如何设置标签云" class="headerlink" title="如何设置标签云"></a>如何设置标签云</h3><p>当我在浏览其它人使用hexo搭建的博客时，发现它的标签特别炫，有一些标签用的少就会是很小的字体，而一些经常用的标签则是很大的字体。经了解才知道这就是标签云。可以通过<code>hexo-tag-cloud</code>插件来实现。该插件除了可以实现我上面所说的功能外，还能在你的博客的左边或右边出现标签滚动的效果。</p>
<p>下面我们就来看看该如何设置标签云吧。第一步自然不必多说，一定是安装插件，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add hexo-tag-cloud --save</span><br></pre></td></tr></table></figure>
<p>插件安装好后，在站点的_config.yml文件中添加如下配置信息:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># hexo-tag-cloud 标签云 | see https:&#x2F;&#x2F;github.com&#x2F;MikeCoder&#x2F;hexo-tag-cloud</span><br><span class="line">tag_cloud:</span><br><span class="line">  textFont: Trebuchet MS, Helvetica # 字体</span><br><span class="line">  textColor: &#39;#555&#39; # 字体颜色</span><br><span class="line">  textHeight: 25 # 字体高度</span><br><span class="line">  outlineColor: &#39;#E2E1D1&#39; # 字体背景色</span><br><span class="line">  maxSpeed: 0.1 # 标签云最大移动速度</span><br></pre></td></tr></table></figure>
<p>上面的配置信息是用于控制标签云显示的效果的。其中，<code>maxSpeed</code>我们要介绍一下，该值为 1 时运转的速度最快，该值为0是基本处理不动的状态。当然如果你不喜欢标签滚动的效果，则可以不设置这些信息。</p>
<p>对于要达到滚动效果的标签云来说，光有这些信息还不够，还要修改一点代码。打开source/layout/_macro/sidevar.swig文件，在文中搜索找到<code>sidebar-inner</code> 的 div 元素，在其下面加入下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if site.tags.length &gt; 1 %&#125;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; charset&#x3D;&quot;utf-8&quot; src&#x3D;&quot;&#123;&#123; url_for(&#39;&#x2F;js&#x2F;tagcloud.js&#39;) &#125;&#125;&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; charset&#x3D;&quot;utf-8&quot; src&#x3D;&quot;&#123;&#123; url_for(&#39;&#x2F;js&#x2F;tagcanvas.js&#39;) &#125;&#125;&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;widget-wrap&quot;&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;myCanvasContainer&quot; class&#x3D;&quot;widget tagcloud&quot;&gt;</span><br><span class="line">    &lt;canvas width&#x3D;&quot;220&quot; height&#x3D;&quot;250&quot; id&#x3D;&quot;resCanvas&quot; style&#x3D;&quot;width&#x3D;100%&quot;&gt;</span><br><span class="line">        &#123;&#123; list_tags() &#125;&#125;</span><br><span class="line">    &lt;&#x2F;canvas&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的配置我们就将标签云设置好了。</p>
<h3 id="如何添加本地搜索"><a href="#如何添加本地搜索" class="headerlink" title="如何添加本地搜索"></a>如何添加本地搜索</h3><p>在hexo中支持很多种搜索，这里我就不一一介绍了，我只用到了其中的本地搜索，并感觉hexo本地搜索的表现还是不错的，所以我也推荐大家用本地搜索。hexo本地搜索的原理很简单，就是通过hexo-generator-search插件在本地生成一个search.xml/json文件，通过这个文件实现搜索功能。</p>
<p>为hexo添中本地搜索功能的步骤很简单，第一步是按装插件，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-search</span><br><span class="line">npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure>

<p>然后修改 hexo 下面的配置文件_config.yml，在其中增加下面配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>

<p>接下来我们把本地搜索入口打开，打开next/_config.yml文件，找到<code>local\_search</code>选项，将该选项设置为true就好了。具体设置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local\_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # if auto, trigger search by changing input</span><br><span class="line">  # if manual, trigger search by pressing enter key or search button</span><br><span class="line">  trigger: auto</span><br><span class="line">  # show top n results per article, show all results by setting to -1</span><br><span class="line">  top\_n\_per\_article: 1</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>上面都配置好后，使用hexo命令重新生成代码并重新进行布署，这样我们就可以看到搜索功能的效果了。</p>
<h3 id="设置关于"><a href="#设置关于" class="headerlink" title="设置关于"></a>设置关于</h3><p>hexo上设置关于与设置标签是类似的，首先执行下面的命令生成关于目录和源码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;about&quot;</span><br></pre></td></tr></table></figure>
<p>该命令执行后，你就可以在source/ 目录下面看到about目录了。然后向 about 目录中的index.md 写入关于的信息就好了。</p>
<p>除此之外，我们还应该像创建标签一样在 themes/next 目录下_config.yml文件中将 about 的入口打开。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">home: &#x2F;|| home</span><br><span class="line">tags: &#x2F;tags&#x2F;|| tags</span><br><span class="line">...</span><br><span class="line">about: &#x2F;about&#x2F;|| about</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这样我们就将关于页面加载好了。</p>
<h3 id="设置404"><a href="#设置404" class="headerlink" title="设置404"></a>设置404</h3><p>设置 404 与设置关于是类似的，也是首先执行 <code>hexo new page &#39;404&#39;</code>命令生成对应的目录和文件，之后是编写404页面。在编写 404 页面时有一点需要注意，就是在404页面的头部要加<code>permalink</code>关键字，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">...</span><br><span class="line">permalink: &#x2F;404</span><br><span class="line">...</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>这样当用户访问非发布的页面时，hexo会始终定位到 404 页面上。</p>
<h3 id="将文章名修改为数字码"><a href="#将文章名修改为数字码" class="headerlink" title="将文章名修改为数字码"></a>将文章名修改为数字码</h3><p>当我在hexo发布文件时发现一个问题，就是hexo生成的文章名如果有中文的话会被转码，这样就变成了一个特别长的字符串，让人看起来非常别拗。能不能将它修改为像简书一样的字符串呢？hexo同样提供了这样一个插件，叫<code>hexo-abbrlink</code>。我们只要装上这个插件再修改一下配置文件就OK了。下面我们就来偿试下吧。</p>
<p>首先还是安装插件，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add hexo-abbrlink --save</span><br></pre></td></tr></table></figure>
<p>插件安装好后，我们再来修改一下配置文件，打开站目录下的_config.yml文件，找到<code>permalink</code>并将它的值修改为 <code>post/:abbrlink/</code>，之后添加abbrlink属性。具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">permalink: posts&#x2F;:abbrlink&#x2F;</span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32</span><br><span class="line">  rep: hex</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>全部配置好后我们就可以重新生成静态文件了。当我们将静态文件发布出来后，你再访问文章时你就会发现以前一长号字符的地址现在已经变的非常短了。</p>
<h3 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h3><p>涉及的知识比较多，待进一步完成！</p>

 <!-- 引入 flv.js 库 -->
 <!--
 <video id="flv_file" controls autoplay>
          You Browser doesn't support video tag
 </video>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/flv.js/1.5.0/flv.min.js"></script>
 <script>
            //通过 JavaScript 脚本创建 FLV Player
            if (flvjs.isSupported()) {
                var videoElement = document.getElementById('flv_file');
                var flvPlayer = flvjs.createPlayer({
                    type: 'flv',
                    url: 'https://avdancevod.oss-cn-beijing.aliyuncs.com/vodio/killer.flv'
                });
                flvPlayer.attachMediaElement(videoElement);
                flvPlayer.load();
                flvPlayer.play();
            }
 </script>
 -->


<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文是我自己搭建博客的总结文章。该文记录的是从我对hexo有所了解，到逐步深入，再到一步一步搭建出我们自己比较满意的博客的过程。在整个过程中，我感触最多的是我在搭建过程中对博客技术的思考以及对技术的重新认知，这两个方面是我对hexo特别兴奋点。也正因于此，才使我写出这一万多字的文章。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>Blog</tag>
        <tag>博客</tag>
        <tag>标签</tag>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
</search>
