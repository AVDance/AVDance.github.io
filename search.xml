<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ffmpeg精讲常见问题</title>
    <url>/f3f66133/</url>
    <content><![CDATA[<h2 id="问：编译-ffmpeg-方法"><a href="#问：编译-ffmpeg-方法" class="headerlink" title="问：编译 ffmpeg 方法"></a>问：编译 ffmpeg 方法</h2><p>答：在各个平台编译方法基本都是一样的。</p>
<ul>
<li>首先下载 ffmpeg 源码，地址为: <a href="https://www.ffmpeg.org/download.html" target="_blank" rel="noopener">https://www.ffmpeg.org/download.html</a></li>
<li>进入到下载后的<a href="https://coding.imooc.com/class/279.html?mc_marking=59c321c0417e144904c49c366f94dd57&mc_channel=shouji" target="_blank" rel="noopener">ffmpeg目</a>录下，执行下面的指令：<a id="more"></a>
<ul>
<li>Mac 平台：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;ffmpeg</span><br><span class="line">                  --enable-gpl</span><br><span class="line">                  --enable-nonfree</span><br><span class="line">                  --enable-libfdk-aac</span><br><span class="line">                  --enable-libx264</span><br><span class="line">                  --enable-libx265</span><br><span class="line">                  --enable-filter&#x3D;delogo</span><br><span class="line">                  --enable-debug</span><br><span class="line">                  --disable-optimizations</span><br><span class="line">                  --enable-libspeex</span><br><span class="line">                  --enable-videotoolbox</span><br><span class="line">                  --enable-shared</span><br><span class="line">                  --enable-pthreads</span><br><span class="line">                  --enable-version3</span><br><span class="line">                  --enable-hardcoded-tables</span><br><span class="line">                  --cc&#x3D;clang</span><br><span class="line">                  --host-cflags&#x3D;</span><br><span class="line">                  --host-ldflags&#x3D;</span><br></pre></td></tr></table></figure></li>
<li>Linux平台<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;ffmpeg</span><br><span class="line">                  --enable-gpl</span><br><span class="line">                  --enable-nonfree</span><br><span class="line">                  --enable-libfdk-aac</span><br><span class="line">                  --enable-libx264</span><br><span class="line">                  --enable-libx265</span><br><span class="line">                  --enable-filter&#x3D;delogo</span><br><span class="line">                  --enable-debug</span><br><span class="line">                  --disable-optimizations</span><br><span class="line">                  --enable-libspeex</span><br><span class="line">                  --enable-shared</span><br><span class="line">                  --enable-pthreads</span><br></pre></td></tr></table></figure></li>
<li>Windows平台<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;ffmpeg</span><br><span class="line">                  --enable-gpl</span><br><span class="line">                  --enable-nonfree</span><br><span class="line">                  --enable-libfdk-aac</span><br><span class="line">                  --enable-libx264</span><br><span class="line">                  --enable-libx265</span><br><span class="line">                  --enable-filter&#x3D;delogo</span><br><span class="line">                  --enable-debug</span><br><span class="line">                  --disable-optimizations</span><br><span class="line">                  --enable-libspeex</span><br><span class="line">                  --enable-static</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<h2 id="问：make-amp-amp-make-install失败"><a href="#问：make-amp-amp-make-install失败" class="headerlink" title="问：make &amp;&amp; make install失败"></a>问：make &amp;&amp; make install失败</h2><p>答：make &amp;&amp; make install 之所以会失败，则由于该用户没有操作目录的权限引起的。所以只需要在make install 之前加 sudo即可。</p>
<p>另一种方法是将用户切换成 root用户，因 root用户的权力最大，所以这样做也是没问题的。但建议还是用 非 root用户操作，这样更安全。</p>
<h2 id="问：库已经安装好了，但仍报找不到它的错误？"><a href="#问：库已经安装好了，但仍报找不到它的错误？" class="headerlink" title="问：库已经安装好了，但仍报找不到它的错误？"></a>问：库已经安装好了，但仍报找不到它的错误？</h2><p>答：首先确认是否已经将 <code>pkg-config</code>工具安装好了。可以执行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pkg-config</span><br></pre></td></tr></table></figure>
<p>如果提示没有安装，则先将该工具安装好，安装命令如下：</p>
<ul>
<li>ubuntu  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt intall pkg-config</span><br></pre></td></tr></table></figure></li>
<li>mac  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install pkg-config</span><br></pre></td></tr></table></figure></li>
<li>cygwin  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-cyg install pkg-config</span><br></pre></td></tr></table></figure></li>
<li>centos  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install pkg-config</span><br></pre></td></tr></table></figure>
安装完该工具后仍然报错？那再按照具体的错误看下面的解决方案吧。</li>
</ul>
<h2 id="问：libx264库找不到（-ERROR-libx264-not-found-）"><a href="#问：libx264库找不到（-ERROR-libx264-not-found-）" class="headerlink" title="问：libx264库找不到（[ERROR: libx264 not found]）"></a>问：libx264库找不到（[ERROR: libx264 not found]）</h2><p>该问题可能由下面三个方面的问题引起。</p>
<ul>
<li>libx264库没有安装。对于这种情况有两种解决办法:<ul>
<li>其一，是通过平台的安装工作进行安装，如 apt/brew/yum install x264。（注：在Linux下应该安装 libx264-dev）。</li>
<li>其二，是通过源码安装，步骤如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. wget https:&#x2F;&#x2F;code.videolan.org&#x2F;videolan&#x2F;x264&#x2F;-&#x2F;archive&#x2F;master&#x2F;x264-master.tar.bz2</span><br><span class="line">2. bunzip2 x264-master.tar.bz2</span><br><span class="line">3. tar -vxf x264-master.tar.tar</span><br><span class="line">4. .&#x2F;configure --enable-static --enable-shared --disable-asm --disable-avs</span><br><span class="line">5. make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>通过 pkg-config 命令无法找到。对于这类问题，我们可以使用下面的命 <code>pkg-config --cflags --lib libx264</code>看是否可以找到 libx264，如果找不到，就说明确实是这个问题。解决的办法是设置环境变量。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PKG_CONFIG_PATH&#x3D;$PKG_CONFIG_PATH:&#x2F;xxx&#x2F;xxx&#x2F;lib&#x2F;pkgconfig</span><br></pre></td></tr></table></figure>
其中 <code>xxx</code> 由你的实际路径代替。</li>
</ul>
<blockquote>
<p>注，有可能你的系统中并没有装 pkg-config工具，可以使用 brew/apt/yum install pkg-config进行安装。</p>
</blockquote>
<ul>
<li>无法链接上libx264, 这是由于通过环境变量 LD_LIBRARY_PATH 无法定位到 libx264库。解决的办法也很简单，与上面类似，可以通过设置环境变量来解决该问题。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export LD_LIBRARY_PATH&#x3D;$LIB_LIBRARY_PATH:&#x2F;xxx&#x2F;xxx&#x2F;lib</span><br></pre></td></tr></table></figure>
其中，<code>xxx</code>由你的实际路径代替。</li>
</ul>
<p>当然，你也可以将环境变量设置在脚本里，这样就不用每次都写export命令了。只需要将上面的两条语句加入到 <del>/.bashrc / 或</del>/.bash_profil 文件里，然后在控制台执行 <code>source ~/.bashrc</code> 或 <code>source ~/.bash_profile</code>即可。</p>
<h2 id="问：fdk-aac库找不到（-ERROR-libfdk-aac-not-found-）"><a href="#问：fdk-aac库找不到（-ERROR-libfdk-aac-not-found-）" class="headerlink" title="问：fdk-aac库找不到（[ERROR: libfdk_aac not found]）"></a>问：fdk-aac库找不到（[ERROR: libfdk_aac not found]）</h2><p>答：该问题与上面的 libx264 问题类似，所以只需要将上面的 libx264替换为libfdk-aac即可。这里不在赘述。</p>
<h2 id="问：speex库找不到（-ERROR-speex-not-found-）"><a href="#问：speex库找不到（-ERROR-speex-not-found-）" class="headerlink" title="问：speex库找不到（[ERROR: speex not found]）"></a>问：speex库找不到（[ERROR: speex not found]）</h2><p>答：该问题与上面的 libx264 问题类似，所以只需要将上面的 libx264替换为speex即可。这里不在赘述。</p>
<h2 id="问：编译不出ffplay"><a href="#问：编译不出ffplay" class="headerlink" title="问：编译不出ffplay"></a>问：编译不出ffplay</h2><p>答：引起该问题有以下几方面的原因：</p>
<ul>
<li>所使用的操作系统没有安装图形库。如有的同学在阿里的云服务器上想安装ffplay是肯定不行的。</li>
<li>没有安装 SDL2 库。解决办法是通过 brew/apt/yum install sdl2 即可 或 通过 SDL2 源码安装。<strong>安装完成后，要重新进行到 ffmpeg目录下，执行 ./configure…这指命令。</strong></li>
<li>有的同学编译ffmpeg时，在ffmpeg目录执行./configure … 之后，没有修改config.h文件，这样也编译不出ffplay来。解决办法是进入到 ffmpeg 目录下，打开 config.h文件找 FFPLAY 关键字，将其后面的 0 修改为 1，保存并退出该文件。在当前目录下执行 make &amp;&amp; sudo  make install。<strong>注意，修改 config.h文件后，不要再执行./configure …了，否则config.h中的值又都恢复为原来的值了。</strong></li>
<li>SDL2与最新的Mac系统 mojave不兼容。解决办法：<ul>
<li>方法一<ul>
<li>从 <a href="https://www.libsdl.org/tmp/release/SDL2-2.0.9.tar.gz" target="_blank" rel="noopener">SDL</a>下载 2.0.9版本或以后的SDL2代码。</li>
<li>执行 ./configure</li>
<li>执行 make &amp;&amp; sudo make install</li>
<li>执行 export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig</li>
<li>[重新]编译ffmpeg</li>
</ul>
</li>
<li>方法二<ul>
<li>从<a href="https://www.libsdl.org/tmp/release/SDL2-2.0.9.dmg" target="_blank" rel="noopener">SDL</a>下载dmg包。</li>
<li>执行 open SDL2-2.0.9.dmg</li>
<li>[重新]编译ffmpeg</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="SDL在windows的-cygwin下无法打印日志"><a href="#SDL在windows的-cygwin下无法打印日志" class="headerlink" title="SDL在windows的 cygwin下无法打印日志"></a>SDL在windows的 cygwin下无法打印日志</h2><p>在编译 SDL 时，将configure 中的 <code>-mwindows</code> 参数去掉。</p>
<h2 id="问：如何在Windows下编译ffmpeg问题"><a href="#问：如何在Windows下编译ffmpeg问题" class="headerlink" title="问：如何在Windows下编译ffmpeg问题"></a>问：如何在Windows下编译ffmpeg问题</h2><p>答：参见 <a href="https://www.imooc.com/article/247113" target="_blank" rel="noopener">Windows下编译ffmpeg问题</a></p>
<h2 id="问：在Windows下编译安装ffmpeg是不是特别麻烦？"><a href="#问：在Windows下编译安装ffmpeg是不是特别麻烦？" class="headerlink" title="问：在Windows下编译安装ffmpeg是不是特别麻烦？"></a>问：在Windows下编译安装ffmpeg是不是特别麻烦？</h2><p>答：确实是这样。所以建议在Window开发者最好装一个 Ubuntu的虚拟机，这样就方便很多了。如果条件允许的话，最好能用Mac开发。可以说Mac Pro是关专为开发者制造的，一旦你用上它会让你爱不释手。</p>
<h2 id="问：编译时，各种库找不到问题"><a href="#问：编译时，各种库找不到问题" class="headerlink" title="问：编译时，各种库找不到问题"></a>问：编译时，各种库找不到问题</h2><p>答：该问题与上面的 libx264类似，我们可以通过 <code>brew/apt/yum install xxx</code> 命令进行安装，一般情况下这种方式都可以满足我们的需求。如果始终不行的话，就需要源码安装了。源码安装的方法可以参见 <a href="https://www.imooc.com/article/247113" target="_blank" rel="noopener">Windows下编译ffmpeg问题</a> 里的说明。</p>
<h2 id="问：ffmpeg如何使用-libx265"><a href="#问：ffmpeg如何使用-libx265" class="headerlink" title="问：ffmpeg如何使用 libx265"></a>问：ffmpeg如何使用 libx265</h2><p>答：准确的讲ffmpeg应该是一个音视频框架，所有的音视频编解码器都是以插件的方式与ffmpeg联系起来的。换句话说，ffmpeg在上层提供了统一的 API，无法你使用的编解决是 x264, open264, x265, vp8/vp9/av1 上层用户都不管心，它仍然使用同样的 API， 只是在find_decoder 或 find_encoder时，指定具体的编解码器就可以了。也就是说在find_xxx时，你要设置了 x264 它最终就会调用 x264进行编解码，设置了 x265它就使用 x265进行编解码。如些而已。</p>
<h2 id="问：这门课有群吗？"><a href="#问：这门课有群吗？" class="headerlink" title="问：这门课有群吗？"></a>问：这门课有群吗？</h2><p>答：有的，群号：883069602，不过<a href="https://coding.imooc.com/class/279.html?mc_marking=59c321c0417e144904c49c366f94dd57&mc_channel=shouji" target="_blank" rel="noopener">需要购买课程</a>后输入验证码才可以进群。大家可以在群里讨论问题，也可以在课程的评论区里搜索答案。目前评论区里已经积累了大量问题的解决方案。</p>
<h2 id="问：为什么我使用课程中的程序无法成功抽取AAC音频？"><a href="#问：为什么我使用课程中的程序无法成功抽取AAC音频？" class="headerlink" title="问：为什么我使用课程中的程序无法成功抽取AAC音频？"></a>问：为什么我使用课程中的程序无法成功抽取AAC音频？</h2><p>答：<a href="https://www.imooc.com/article/254733" target="_blank" rel="noopener">详细回答在这里</a></p>
<h2 id="问：Android播放器例子为什么调API失败"><a href="#问：Android播放器例子为什么调API失败" class="headerlink" title="问：Android播放器例子为什么调API失败"></a>问：Android播放器例子为什么调API失败</h2><p>答：你目前使用的 NDK 版本与我编译时使用的 NDK 版本不一致造成的，换成 NDK10e试试。</p>
<h2 id="问：NDK10e-从哪里下载"><a href="#问：NDK10e-从哪里下载" class="headerlink" title="问：NDK10e 从哪里下载"></a>问：NDK10e 从哪里下载</h2><p>答：可以到<a href="https://developer.android.com/ndk/downloads/older_releases" target="_blank" rel="noopener">这里</a>下载。</p>
<ul>
<li><a href="https://dl.google.com/android/repository/android-ndk-r10e-darwin-x86_64.zip" target="_blank" rel="noopener">mac NDK10e</a></li>
<li><a href="https://dl.google.com/android/repository/android-ndk-r10e-windows-x86.zip" target="_blank" rel="noopener">windows 32 位 NDK10e</a></li>
<li><a href="https://dl.google.com/android/repository/android-ndk-r10e-windows-x86_64.zip" target="_blank" rel="noopener">windows 64位 NDK10e</a></li>
<li><a href="https://dl.google.com/android/repository/android-ndk-r10e-linux-x86_64.zip" target="_blank" rel="noopener">linux NDK10e</a></li>
</ul>
<h2 id="问：NDKr21-从哪里下载"><a href="#问：NDKr21-从哪里下载" class="headerlink" title="问：NDKr21 从哪里下载"></a>问：NDKr21 从哪里下载</h2><p>答：可以到这里下载。</p>
<ul>
<li><a href="https://dl.google.com/android/repository/android-ndk-r21-darwin-x86_64.zip" target="_blank" rel="noopener">mac NDKr21</a></li>
<li><a href="https://dl.google.com/android/repository/android-ndk-r21-windows-x86_64.zip" target="_blank" rel="noopener">windows NDKr21</a></li>
<li><a href="https://dl.google.com/android/repository/android-ndk-r21-linux-x86_64.zip" target="_blank" rel="noopener">linux NDKr21</a></li>
</ul>
<h2 id="问：ffmpeg安装好后，编译视频中的ffmpeg-log不成功"><a href="#问：ffmpeg安装好后，编译视频中的ffmpeg-log不成功" class="headerlink" title="问：ffmpeg安装好后，编译视频中的ffmpeg_log不成功"></a>问：ffmpeg安装好后，编译视频中的ffmpeg_log不成功</h2><p>答：执行下面的命令进行编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -g -o ffmpeg_log ffmpeg_log.c &#96;pkg-config --libs --cflags libavutil&#96;</span><br></pre></td></tr></table></figure>
<p><strong>注意：pkg-confg 前面的符号不是<code>&#39;</code>哟！它是键盘左上角 ESC键下面的键。</strong></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>该文章会不定期更新，我们将一些大家使用<a href="https://coding.imooc.com/class/279.html?mc_marking=59c321c0417e144904c49c366f94dd57&mc_channel=shouji" target="_blank" rel="noopener">ffmpeg</a>常见的问题更新到这里来。</p>
<h2 id="视频课地址"><a href="#视频课地址" class="headerlink" title="视频课地址"></a>视频课地址</h2><p><a href="https://www.imooc.com/u/4873493/courses?sort=publish" target="_blank" rel="noopener">课程主页地址</a></p>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
        <tag>音视频</tag>
        <tag>直播</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频系统入门常见问题</title>
    <url>/631d466a/</url>
    <content><![CDATA[<p>同学们在学习《音视频课小白系统入门》这门课的过程中，经常遇到一些问题，如Mac系统下为什么无法编译ffmpeg? Xcode编译课程中的程序为什么不成功? 为什么我从设备中读的数据很小?等等不足而一。</p>
<p>实际上，大部分同学提出的问题都是重复的。因此，我将一些最常见的问题整理出了答案放在这里，同学们可以根据自己的情况去查找相应的解决办法，以免我个人原因不能及时回答问题时，给大家的学习造成麻烦和不便。</p>
<a id="more"></a>

<p><img data-src="https://cdn.avdancedu.com/image/article/yiwen.jpg" alt=""></p>
<h2 id="Q-在-Mac-10-15-3-系统下编译-ffmpeg-成功后，在运行-ffmpeg-命令时出现crash"><a href="#Q-在-Mac-10-15-3-系统下编译-ffmpeg-成功后，在运行-ffmpeg-命令时出现crash" class="headerlink" title="Q: 在 Mac 10.15.3 系统下编译 ffmpeg 成功后，在运行 ffmpeg 命令时出现crash."></a>Q: 在 Mac 10.15.3 系统下编译 ffmpeg 成功后，在运行 ffmpeg 命令时出现crash.</h2><p>A: 重新编译ffmpeg，在执行 ./configure 时增加 –extra-cflags=”fno-static-check” 选项，注意该选项一定要放在前面，否则编译有问题。</p>
<h2 id="Q：添加-–extra-cflags-”fno-static-check”-选项-仍然-crash"><a href="#Q：添加-–extra-cflags-”fno-static-check”-选项-仍然-crash" class="headerlink" title="Q：添加 –extra-cflags=”fno-static-check” 选项 仍然 crash"></a>Q：添加 –extra-cflags=”fno-static-check” 选项 仍然 crash</h2><p>A: 编译时保持尽量少的参数，应该是与其它一些参数有突冲</p>
<h2 id="Q：Xcode-编译成功，但执行失败"><a href="#Q：Xcode-编译成功，但执行失败" class="headerlink" title="Q：Xcode 编译成功，但执行失败"></a>Q：Xcode 编译成功，但执行失败</h2><p>A：在执行课程的例子时，要将沙盒关闭掉，在info.list中增加访问mic phone 权限。</p>
<h2 id="Q：关闭沙盒后，程序仍然无法执行"><a href="#Q：关闭沙盒后，程序仍然无法执行" class="headerlink" title="Q：关闭沙盒后，程序仍然无法执行"></a>Q：关闭沙盒后，程序仍然无法执行</h2><p>A：要有开发者证书才可以。</p>
<h2 id="Q：引入ffmpeg库后，报code-signature…not-valid"><a href="#Q：引入ffmpeg库后，报code-signature…not-valid" class="headerlink" title="Q：引入ffmpeg库后，报code signature…not valid"></a>Q：引入ffmpeg库后，报code signature…not valid</h2><p>A：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 打开 Mac 中的 keychain Access.app, 选择“我的证书”</span><br><span class="line">2. 执行 codesign -f -s &quot;证书名&quot; xxx.dylib</span><br><span class="line">3. 为了避免逐个签名，可以进行批量操作 codesign -f -s &quot;证书名&quot; &#x2F;usr&#x2F;local&#x2F;ffmpeg&#x2F;lib&#x2F;*.dylib</span><br></pre></td></tr></table></figure>

<h2 id="Q-ffmpeg-执行时提示没有权限"><a href="#Q-ffmpeg-执行时提示没有权限" class="headerlink" title="Q: ffmpeg 执行时提示没有权限"></a>Q: ffmpeg 执行时提示没有权限</h2><p>A： 切目录切换到你自己的用户目录下再执行ffmpeg。</p>
<h2 id="虚似机中每次获取的数据很小，只有64个字节，如果进行重采样？"><a href="#虚似机中每次获取的数据很小，只有64个字节，如果进行重采样？" class="headerlink" title="虚似机中每次获取的数据很小，只有64个字节，如果进行重采样？"></a>虚似机中每次获取的数据很小，只有64个字节，如果进行重采样？</h2><p>A： ffmpeg中最低采样个数为32个，所以只有 64 字节数据时，是无进行重采样的。解决办法是将数据放到一个缓冲区中，积攒到一定大小后，再进行重采样。</p>
<h2 id="Q-在从设备采体数据时，返回错误-35"><a href="#Q-在从设备采体数据时，返回错误-35" class="headerlink" title="Q: 在从设备采体数据时，返回错误 -35"></a>Q: 在从设备采体数据时，返回错误 -35</h2><p>A: 说明你的设备现在暂时还没准备好，此时你应该等待它几秒，之后就可以正常读数据了。</p>
<h2 id="Q：在编码时，编码器返回-35-错误"><a href="#Q：在编码时，编码器返回-35-错误" class="headerlink" title="Q：在编码时，编码器返回 -35 错误"></a>Q：在编码时，编码器返回 -35 错误</h2><p>A：此时说明编码器没有准备好，需要等待几秒钟。</p>
<h2 id="Q-编译ffmpeg时没有ffplay"><a href="#Q-编译ffmpeg时没有ffplay" class="headerlink" title="Q: 编译ffmpeg时没有ffplay"></a>Q: 编译ffmpeg时没有ffplay</h2><p>A:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.首先安装 SDL2 库</span><br><span class="line">2. 在 ffmpeg源码中执行 .&#x2F;configure 时并增加 --enable-sdl2</span><br><span class="line">3. make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h2 id="Q-采集到的音频数据编码-AAC-时，报无法找到libfdk-aac库"><a href="#Q-采集到的音频数据编码-AAC-时，报无法找到libfdk-aac库" class="headerlink" title="Q: 采集到的音频数据编码 AAC 时，报无法找到libfdk-aac库"></a>Q: 采集到的音频数据编码 AAC 时，报无法找到libfdk-aac库</h2><p>A：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 安装好 fdk-aac库</span><br><span class="line">2. 重新在ffmpeg源码目录下执行.&#x2F;configure 并增加--enable-libfdk-aac 参数</span><br><span class="line">3. make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<h2 id="Q-在Linux中何采集音频数据"><a href="#Q-在Linux中何采集音频数据" class="headerlink" title="Q: 在Linux中何采集音频数据"></a>Q: 在Linux中何采集音频数据</h2><p>A: ffmpeg -f alsa -i hw:0,0 xxx.wav</p>
<h2 id="Q-在-Linux-中找不到-alsa-设备"><a href="#Q-在-Linux-中找不到-alsa-设备" class="headerlink" title="Q: 在 Linux 中找不到 alsa 设备"></a>Q: 在 Linux 中找不到 alsa 设备</h2><p>A：可以通过 arecord -l 查看你linux系统下有哪些音频设备。如果没有alsa, 可以使用  oss.</p>
<h2 id="Q：编译ffmpeg-时-filter-编译不过"><a href="#Q：编译ffmpeg-时-filter-编译不过" class="headerlink" title="Q：编译ffmpeg 时 filter 编译不过"></a>Q：编译ffmpeg 时 filter 编译不过</h2><p>A：选择使用 libstdc++ 库试试</p>
<h2 id="Q-Windows下编译ffmpeg"><a href="#Q-Windows下编译ffmpeg" class="headerlink" title="Q: Windows下编译ffmpeg"></a>Q: Windows下编译ffmpeg</h2><p>A:  <a href="https://trac.ffmpeg.org/wiki/CompilationGuide/MinGW" target="_blank" rel="noopener">https://trac.ffmpeg.org/wiki/CompilationGuide/MinGW</a></p>
<h2 id="Q-AAC-编码为-AAC-HE-V2-时，声音不对"><a href="#Q-AAC-编码为-AAC-HE-V2-时，声音不对" class="headerlink" title="Q: AAC 编码为 AAC_HE_V2 时，声音不对"></a>Q: AAC 编码为 AAC_HE_V2 时，声音不对</h2><p>A：这是因为我用的 AAC 版本比较老，老版本的 AAC 与新版本的 AAC 可能有一些差异，这个我会后面查找一下原因。大家测试时可以将profile修改为 AAC HE 或 AAC LC，这样就可以正常编码出 AAC 数据了。</p>
<h2 id="Q：库已经安装好了，但仍报找不到它的错误？"><a href="#Q：库已经安装好了，但仍报找不到它的错误？" class="headerlink" title="Q：库已经安装好了，但仍报找不到它的错误？"></a><a href="">Q：库已经安装好了，但仍报找不到它的错误？</a></h2><p>A：首先确认是否已经将 <code>pkg-config</code>工具安装好了。可以执行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pkg-config</span><br></pre></td></tr></table></figure>
<p>如果提示没有安装，则先将该工具安装好，安装命令如下：</p>
<ul>
<li>ubuntu  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt intall pkg-config</span><br></pre></td></tr></table></figure></li>
<li>mac  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install pkg-config</span><br></pre></td></tr></table></figure></li>
<li>cygwin  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-cyg install pkg-config</span><br></pre></td></tr></table></figure></li>
<li>centos  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install pkg-config</span><br></pre></td></tr></table></figure>
安装完该工具后仍然报错？那再按照具体的错误看下面的解决方案吧。</li>
</ul>
<h2 id="Q：libx264库找不到（-ERROR-libx264-not-found-）"><a href="#Q：libx264库找不到（-ERROR-libx264-not-found-）" class="headerlink" title="Q：libx264库找不到（[ERROR: libx264 not found]）"></a>Q：libx264库找不到（[ERROR: libx264 not found]）</h2><p>A:<br>该问题可能由下面三个方面的问题引起。</p>
<ul>
<li>libx264库没有安装。对于这种情况有两种解决办法:<ul>
<li>其一，是通过平台的安装工作进行安装，如 apt/brew/yum install x264。（注：在Linux下应该安装 libx264-dev）。</li>
<li>其二，是通过源码安装，步骤如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. wget https:&#x2F;&#x2F;code.videolan.org&#x2F;videolan&#x2F;x264&#x2F;-&#x2F;archive&#x2F;master&#x2F;x264-master.tar.bz2</span><br><span class="line">2. bunzip2 last_x264.tar.bz2</span><br><span class="line">3. tar -vxf last_x264.tar</span><br><span class="line">4. .&#x2F;configure --enable-static --enable-shared --disable-asm --disable-avs</span><br><span class="line">5. make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>通过 pkg-config 命令无法找到。对于这类问题，我们可以使用下面的命 <code>pkg-config --cflags --lib libx264</code>看是否可以找到 libx264，如果找不到，就说明确实是这个问题。解决的办法是设置环境变量。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PKG_CONFIG_PATH&#x3D;$PKG_CONFIG_PATH:&#x2F;xxx&#x2F;xxx&#x2F;lib&#x2F;pkgconfig</span><br></pre></td></tr></table></figure>
其中 <code>xxx</code> 由你的实际路径代替。</li>
</ul>
<blockquote>
<p>注，有可能你的系统中并没有装 pkg-config工具，可以使用 brew/apt/yum install pkg-config进行安装。</p>
</blockquote>
<ul>
<li>无法链接上libx264, 这是由于通过环境变量 LD_LIBRARY_PATH 无法定位到 libx264库。解决的办法也很简单，与上面类似，可以通过设置环境变量来解决该问题。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export LD_LIBRARY_PATH&#x3D;$LIB_LIBRARY_PATH:&#x2F;xxx&#x2F;xxx&#x2F;lib</span><br></pre></td></tr></table></figure>
其中，<code>xxx</code>由你的实际路径代替。</li>
</ul>
<p>当然，你也可以将环境变量设置在脚本里，这样就不用每次都写export命令了。只需要将上面的两条语句加入到 <del>/.bashrc / 或</del>/.bash_profil 文件里，然后在控制台执行 <code>source ~/.bashrc</code> 或 <code>source ~/.bash_profile</code>即可。</p>
<h2 id="Q：fdk-aac库找不到（-ERROR-libfdk-aac-not-found-）"><a href="#Q：fdk-aac库找不到（-ERROR-libfdk-aac-not-found-）" class="headerlink" title="Q：fdk-aac库找不到（[ERROR: libfdk_aac not found]）"></a>Q：fdk-aac库找不到（[ERROR: libfdk_aac not found]）</h2><p>A：该问题与上面的 libx264 问题类似，所以只需要将上面的 libx264替换为libfdk-aac即可。这里不在赘述。</p>
<h2 id="Q：通过-avcodec-find-encoder-by-name-无法找到编码器"><a href="#Q：通过-avcodec-find-encoder-by-name-无法找到编码器" class="headerlink" title="Q：通过 avcodec_find_encoder_by_name() 无法找到编码器"></a>Q：通过 avcodec_find_encoder_by_name() 无法找到编码器</h2><p>A：通过以下步骤进行解决</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0. 你使用的ffmpeg必须是经过源码编译的</span><br><span class="line">1. 你在编译 ffmpeg 时，执行.&#x2F;configure时是否将此编码器模块添加到 ffmpeg中了？以 fdk_aac 为例，在执行 .&#x2F;configure …时你应该加上 --enable-libfdk-aac 选项。</span><br><span class="line">2. 如果通过源码编译ffmpeg时有报错，请根据错误信息查看本文档的相应处理方法</span><br><span class="line">3. 确保 pkg-config 命令查询到的是你通过源码编译的ffmpeg库</span><br></pre></td></tr></table></figure>

<h2 id="Q：编译不出ffplay"><a href="#Q：编译不出ffplay" class="headerlink" title="Q：编译不出ffplay"></a>Q：编译不出ffplay</h2><p>A：引起该问题有以下几方面的原因：</p>
<ul>
<li>所使用的操作系统没有安装图形库。如有的同学在阿里的云服务器上想安装ffplay是肯定不行的。</li>
<li>没有安装 SDL2 库。解决办法是通过 brew/apt/yum install sdl2 即可 或 通过 SDL2 源码安装。<strong>安装完成后，要重新进行到 ffmpeg目录下，执行 ./configure…这指命令。</strong></li>
<li>有的同学编译ffmpeg时，在ffmpeg目录执行./configure …时没有添加 –enable-sdl2 选项也会导致无法编译出 ffplay</li>
<li>SDL2与最新的Mac系统 mojave不兼容。解决办法：<ul>
<li>方法一<ul>
<li>从 <a href="https://www.libsdl.org/tmp/release/SDL2-2.0.9.tar.gz" target="_blank" rel="noopener">SDL</a>下载 2.0.9版本或以后的SDL2代码。</li>
<li>执行 ./configure</li>
<li>执行 make &amp;&amp; sudo make install</li>
<li>执行 export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig</li>
<li>[重新]编译ffmpeg</li>
</ul>
</li>
<li>方法二<ul>
<li>从<a href="https://www.libsdl.org/tmp/release/SDL2-2.0.9.dmg" target="_blank" rel="noopener">SDL</a>下载dmg包。</li>
<li>执行 open SDL2-2.0.9.dmg</li>
<li>[重新]编译ffmpeg</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Q：非Mac同学如何学习本课程"><a href="#Q：非Mac同学如何学习本课程" class="headerlink" title="Q：非Mac同学如何学习本课程"></a>Q：非Mac同学如何学习本课程</h2><p>A：本课程中的例子的界面是由 Swift 编写的，如果你没有 Mac 系统的话，你可以用 Qt 甚至不用界面开发，代码中与ffmpeg相着的代码都是跨平台的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://coding.imooc.com/class/415.html?mc_marking=b587280c0c1c0e76c1092aa21406565a&mc_channel=syb6" target="_blank" rel="noopener">音视频小白系统入门课</a></p>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
        <tag>音视频</tag>
        <tag>直播</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用命令</title>
    <url>/423abe9e/</url>
    <content><![CDATA[<p>本文主要记录一些工作中常用的 git 命令，以及一些比较特殊的git用法，希望这些命令能对您有所帮助。</p>
<a id="more"></a>

<h2 id="git-的基本工作原理"><a href="#git-的基本工作原理" class="headerlink" title="git 的基本工作原理"></a>git 的基本工作原理</h2><p>这块待补充……</p>
<h2 id="已有代码该如何提效到仓库中"><a href="#已有代码该如何提效到仓库中" class="headerlink" title="已有代码该如何提效到仓库中"></a>已有代码该如何提效到仓库中</h2><p>第一步，在github 上创建一个仓库。<br>第二步，执行下面的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:avdance&#x2F;test.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<h2 id="本地与远程有突冲，想放弃本地修改"><a href="#本地与远程有突冲，想放弃本地修改" class="headerlink" title="本地与远程有突冲，想放弃本地修改"></a>本地与远程有突冲，想放弃本地修改</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard FETCH_HEAD</span><br></pre></td></tr></table></figure>

<h2 id="重新从远端拉取某个文件"><a href="#重新从远端拉取某个文件" class="headerlink" title="重新从远端拉取某个文件"></a>重新从远端拉取某个文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout a.c</span><br></pre></td></tr></table></figure>

<h2 id="撤消某次-add"><a href="#撤消某次-add" class="headerlink" title="撤消某次 add"></a>撤消某次 add</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rm --cached &lt;added_file_to_undo&gt;</span><br></pre></td></tr></table></figure>

<h2 id="撤消某次-commit"><a href="#撤消某次-commit" class="headerlink" title="撤消某次 commit"></a>撤消某次 commit</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --soft commitID  只是删除了commitId之后的commit记录,但是代码改动仍然存在</span><br><span class="line">git reset --hard commitID  彻底的回到CommitID13:39时候的版本,之后的改动不存在了</span><br></pre></td></tr></table></figure>

<h2 id="将本地修改先暂存起来"><a href="#将本地修改先暂存起来" class="headerlink" title="将本地修改先暂存起来"></a>将本地修改先暂存起来</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash 将本地修改暂存起来</span><br><span class="line">git stash pop 弹出暂存的修改</span><br></pre></td></tr></table></figure>

<h2 id="查看有冲突的文件"><a href="#查看有冲突的文件" class="headerlink" title="查看有冲突的文件"></a>查看有冲突的文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status -uno</span><br></pre></td></tr></table></figure>

<h2 id="不显示临时文件"><a href="#不显示临时文件" class="headerlink" title="不显示临时文件"></a>不显示临时文件</h2><p>在 .gitignore 中添加不想被 git staus 看到的文件或目录</p>
<h2 id="暂时回滚到某版本"><a href="#暂时回滚到某版本" class="headerlink" title="暂时回滚到某版本"></a>暂时回滚到某版本</h2><p>首先通过 git log查看你之前的提交码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log | more</span><br></pre></td></tr></table></figure>
<blockquote>
<p>commit 4adb3f0ecd9dbc79bd09666d88f8c2520305c001<br>Author: xxxxxx<br>Date:   Thu Jan 25 11:51:45 2018 +0800</p>
</blockquote>
<p>摘取 commit 码的前 7位，执行下面的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout 4adb3f0</span><br><span class="line">git reset --hard 4adb3f0</span><br></pre></td></tr></table></figure>
<h2 id="回滚到主分支"><a href="#回滚到主分支" class="headerlink" title="回滚到主分支"></a>回滚到主分支</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>
<h2 id="服务端有更新，但你却-commit了你的代码"><a href="#服务端有更新，但你却-commit了你的代码" class="headerlink" title="服务端有更新，但你却 commit了你的代码"></a>服务端有更新，但你却 commit了你的代码</h2><ul>
<li><p>先拉取服务端代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure></li>
<li><p>提交代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure></li>
<li><p>如果你在 dev分支，此时还要拉取master的代码<br><strong>1. 先 切换到 master 分支</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>

<p><strong>2. 拉取代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<p><strong>3. 重新切换到 dev 分支</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout dev</span><br></pre></td></tr></table></figure>
<h2 id="查看每次提交的文件列表"><a href="#查看每次提交的文件列表" class="headerlink" title="查看每次提交的文件列表"></a>查看每次提交的文件列表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --stat | more</span><br></pre></td></tr></table></figure>
<h2 id="查看某些提交代码的变化"><a href="#查看某些提交代码的变化" class="headerlink" title="查看某些提交代码的变化"></a>查看某些提交代码的变化</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git show &lt;commit id&gt; [&lt;filename&gt;]</span><br></pre></td></tr></table></figure>
<h2 id="显示所有本地与远端分支"><a href="#显示所有本地与远端分支" class="headerlink" title="显示所有本地与远端分支"></a>显示所有本地与远端分支</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure>
<p>#显示所有远程分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure>
<h2 id="显示远端地址"><a href="#显示远端地址" class="headerlink" title="显示远端地址"></a>显示远端地址</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>
<h2 id="创建一个新分支"><a href="#创建一个新分支" class="headerlink" title="创建一个新分支"></a>创建一个新分支</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b new_branch</span><br><span class="line">git --set-upstream origin new_branch</span><br><span class="line">git push origin new_branch</span><br></pre></td></tr></table></figure>
<h2 id="远程仓库已经删除，而本地仓库还在，如果清除？"><a href="#远程仓库已经删除，而本地仓库还在，如果清除？" class="headerlink" title="远程仓库已经删除，而本地仓库还在，如果清除？"></a>远程仓库已经删除，而本地仓库还在，如果清除？</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull -p</span><br></pre></td></tr></table></figure>
<h2 id="git-diff-不显示修改的内容"><a href="#git-diff-不显示修改的内容" class="headerlink" title="git diff 不显示修改的内容"></a>git diff 不显示修改的内容</h2><p>有些情况下，通过 <code>git status</code> 能查到某些文件有变化，但使用 <code>git diff</code> 却看不到修改的内容。可以使用下面的面试查看变化。</p>
</li>
<li><p>第一种方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff --cached 文件名</span><br></pre></td></tr></table></figure></li>
<li><p>或者<br>先将修改的文件重命名，然后执行下面的语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset HEAD</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="配置更好的-git-diff-工具"><a href="#配置更好的-git-diff-工具" class="headerlink" title="配置更好的 git diff 工具"></a>配置更好的 git diff 工具</h2><p>在使用 git diff 时，常常发现有很多不方便的地方。因为git diff 默认使用 patch 方式展示代码的不同。如果想看修改后代码的上下文就比较麻烦了（比如代码 review）。</p>
<p>其实 git 已经提供了扩展功能。可经将它的默认 diff 工具修改为vimdiff。配置如下：</p>
<ul>
<li>首先打开 git config 文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~&#x2F;.gitconfig</span><br></pre></td></tr></table></figure></li>
<li>增加配置项<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[difftool]</span><br><span class="line">    prompt &#x3D; false</span><br><span class="line">[diff]</span><br><span class="line">    vimdiff</span><br><span class="line">    tool &#x3D; vimdiff</span><br><span class="line">[difftool &quot;vimdiff&quot;]</span><br><span class="line">    path &#x3D; &#x2F;usr&#x2F;bin&#x2F;vimdiff</span><br></pre></td></tr></table></figure>
<h2 id="打tag"><a href="#打tag" class="headerlink" title="打tag"></a>打tag</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;为git打tag, 第一次需要在前面加一个v</span><br><span class="line">git tag &quot;v1.0.0&quot;</span><br><span class="line">&#x2F;&#x2F;将tag推送到远程仓库</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure>
<h2 id="git-merge-每次都生成一次commit"><a href="#git-merge-每次都生成一次commit" class="headerlink" title="git merge 每次都生成一次commit"></a>git merge 每次都生成一次commit</h2></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge --no-ff</span><br></pre></td></tr></table></figure>
<h2 id="拉某个-tag"><a href="#拉某个-tag" class="headerlink" title="拉某个 tag"></a>拉某个 tag</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout tag_name</span><br></pre></td></tr></table></figure>
<h2 id="查看某个人的所有提交"><a href="#查看某个人的所有提交" class="headerlink" title="查看某个人的所有提交"></a>查看某个人的所有提交</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --author&#x3D;“author”</span><br></pre></td></tr></table></figure>
<h2 id="为git设置默认用户名和密码"><a href="#为git设置默认用户名和密码" class="headerlink" title="为git设置默认用户名和密码"></a>为git设置默认用户名和密码</h2><p>在使用Git 的时候，经常会遇到需要频繁输入密码的情况，每次git push 和 git pull 都要求输入用户名和密码，如果提交频繁的话就十分不方便。</p>
<p>可以使用下面的方法，只需要第一次输入用户名和密码，以后都不用再输入了。</p>
<h3 id="进入Git-配置文件"><a href="#进入Git-配置文件" class="headerlink" title="进入Git 配置文件"></a>进入Git 配置文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~&#x2F;.gitconfig</span><br></pre></td></tr></table></figure>

<h3 id="修改配置文件，添加下面这一行。"><a href="#修改配置文件，添加下面这一行。" class="headerlink" title="修改配置文件，添加下面这一行。"></a>修改配置文件，添加下面这一行。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[credential]  </span><br><span class="line">    helper &#x3D; store</span><br></pre></td></tr></table></figure>

<p>##修改已提交的commit的用户名邮箱</p>
<ol>
<li><p>第一步</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;newName&quot;</span><br><span class="line">git config --global user.email &quot;newEmail&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改已提交commit的用户名邮箱</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit --amend --author&#x3D;&quot;userName &lt;userEmail&gt;&quot;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>注意不能缺少<code>&lt; &gt;</code></strong><br><strong>此指令仅能更新最近的一次commit的用户名邮箱</strong></p>
<h2 id="git-应用-patch"><a href="#git-应用-patch" class="headerlink" title="git 应用 patch"></a>git 应用 patch</h2><ol>
<li>预览patch的结是</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git apply --stat file.patch</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>检测patch后是否有错误</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git apply --check file.patch</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>打patch</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git am --signoff &lt; a_file.patch</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>执行commit</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git  commit -m &quot;&quot;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>提交代码</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>

<h2 id="循环克隆"><a href="#循环克隆" class="headerlink" title="循环克隆"></a>循环克隆</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone --recursive https:&#x2F;&#x2F;xxx.git</span><br></pre></td></tr></table></figure>
<h2 id="给代码设置两个不同的源"><a href="#给代码设置两个不同的源" class="headerlink" title="给代码设置两个不同的源"></a>给代码设置两个不同的源</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote set-url origin https:&#x2F;&#x2F;xxx.git</span><br></pre></td></tr></table></figure>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>命令在不断更新中…</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客系统的实现原理与搭建</title>
    <url>/2ef51851/</url>
    <content><![CDATA[<p>作为技术人员，定期写Blog是一个非常好的习惯。你可以通过它将自己的一些学习心得记录下来，也可以对平常的工作做一些经验总结等等。对于我来说Blog就更为重要了，因为Blog是我推广<strong>音视频技术</strong>的一块<strong>“阵地”</strong>，我需要将我写的一些<strong>音视频技术</strong>知识、视频课程中的问题解答等内容放在它上面，以便同学们交流学习。</p>
<a id="more"></a>
<p><img data-src="https://cdn.avdancedu.com/image/hexo/hexo-logo.png" alt=""></p>
<p>以前，我的文章一直都在<strong>简书</strong>上发布，可最近不知为何，简书将我的账户封掉了。我经多次申诉却依然无果，既不告之那里违规，也不给我解封，真让人无语！考虑到在其它平台也可能遇到类似情况，因此决心搭建自己的博客，这样才能放心。</p>
<p>如何才能快速搭建一套比较专业的博客系统呢？通过调研，我发现开源项目<strong>hexo</strong>完全可以满足我的要求。它既可以发布文章，还支持一些常见的功能，如阅览数、文章字数统计、本地搜索等等。下面我就来详细讲述一下我是如何通过<strong>hexo</strong>搭建自已的博客系统的。</p>
<h2 id="Blog系统"><a href="#Blog系统" class="headerlink" title="Blog系统"></a>Blog系统</h2><p>在搭建Blog系统之前，我们有必要先了解一下Blog系统是干什么的，它都应该有哪些功能。</p>
<p>Blog是在2000年左右出现的，原本的称法为weblog，即网络日志。后来逐渐被人们改为 we blog，进而简称为Blog。Blog中的每一篇文章/日志就是一个页面，Blog将这些页面聚集在一起就形成了现在的形式。</p>
<p>现在大家在写Blog时已经很少直接写在页面里了，而是改用Markdown语法，这种语法非常简洁，特别适合我们平常的写作。所以现今的Blog系统最重要的一个环节就是，将Markdown语法写成的文档转化成HTML页面，然后放到Web服务器上发布出来。除此之外，Blog还要有一个管理系统可以将这些页面管理起来，如生成目录、标签，分类、搜索等等。</p>
<p>如果要我们自己实现这样一套系统还是非常麻烦的，好在已经有开源项目实现了，这就是<strong>hexo</strong>。hexo 不但实现了这些功能，还实现了很多其它的功能，如文章浏览次数、打赏、接入评论系统等等。这些功能对于我们来说都是非常有用的，然而在讲解如何搭建这些功能之前，我们先来了解一下hexo的实现原理，这样可以让我们更容易理解后面的知识。</p>
<h2 id="hexo基本原理"><a href="#hexo基本原理" class="headerlink" title="hexo基本原理"></a>hexo基本原理</h2><p>要了解hexo的实现原理，我们首先要知清楚 hexo 的目录结构，这样可以更有助于了解hexo。</p>
<p>hexo由以下几个重要文件/目录组成：</p>
<ul>
<li>_config.yml，该文件是hexo 的<code>站</code>级配置文件。所谓<strong>站</strong>级配置文件是指，对整个站点起效果的配置文件。</li>
<li>source目录，该目录存放源文件。即用户编写的博文都放在该目录下。在该目录下又有几个子目录我们来分别看一下。<ul>
<li>_post，用于存放博文，基本上每篇文章都是由Markdown语法编写的。</li>
<li>tags，存放tag 的文件。hexo中的tags是自动生成的，所以我们不用手动修改tags目录下的index.md文件，在发布时它会自动生成。</li>
<li>categories，存放<strong>分类</strong>。它与tags是类似的，也是自动生成的，所以不需要我们手工修改。</li>
<li>…</li>
</ul>
</li>
<li>themes目录，该目录用于存放主题，目前hexo中最热门的主题就是<strong>next</strong>了。最近的 next release 版本是 7.8 。</li>
<li>public目录，该目录存放hexo转出的文件，如html、css、js等。</li>
<li>scaffolds目录，它里面存放了一些<strong>“脚手架”</strong>程序，用于生成模板页面，如执行<code>hexo new &quot;title&quot;</code>时，就会生成一个Markdown文件模板。</li>
</ul>
<p>上面就是hexo中最重要的几个文件和目录了。</p>
<p>清楚之hexo目录结构之后，我们再来看看hexo的基本原理。</p>
<p>hexo最基本的功能是将Markdown程序转成HTML页面，而这个转换并不是一次完成的，要经历两步:</p>
<ul>
<li><p>第一步，将Markdown翻译成下面格式的JSON对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">article: &#123;</span><br><span class="line">  title:</span><br><span class="line">  date:</span><br><span class="line">  tags:</span><br><span class="line">  categories:</span><br><span class="line">  content:</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步，根据上面生成的JSON对象生成 HTML 页面。</p>
</li>
</ul>
<p>对于我们来说，清楚了上面hexo将Markdown转HTML页面的过程后，我们就很容易理解hexo 在执行不同命令时它都在做什么事儿了。</p>
<p>下面我们再来看看<strong>hexo</strong>的组成，它由三部分组成: <strong>hexo-cli</strong>、<strong>hexo-core</strong>以及<strong>hexo plugs</strong>。在这三部分中最核心的是hexo-core模块，它的作用就是执行上面讲的两步转换，从而生成目标文件；hexo-cli为我们供了一些非常方便的命令。当我们敲入命令时，它会根据命令调用不同的模块；hexo plugin是hexo的扩展，当hexo本身不能完成某项任务时，它允许你自己开发一个插件来完成。当然你也可以使用其它人写好的插件。</p>
<p>上以就是hexo的基本原理。</p>
<h2 id="hexo的常用命令"><a href="#hexo的常用命令" class="headerlink" title="hexo的常用命令"></a>hexo的常用命令</h2><p><strong>hexo</strong> 提供了几个常用命令，如<code>hexo clean</code>、<code>hexo g</code>、<code>hexo s</code>等等。下面我们分别看一下这几个命令的具体作用是什么：</p>
<ul>
<li>hexo clean: 删除 hexo 生成的所有文档。当我们执行这个命令后，你会发现public目录被删除了。</li>
<li>hexo g: 根据 source 目录中的文件生成html等可以发布的文件。</li>
<li>hexo s: 在本地起动 <strong>http</strong> 服务，将生成的 html  等输出文件布署到本地服务器上。 </li>
<li>hexo d: 将生成的html代码推送到 github 上</li>
</ul>
<p>这几个命令的含义都非常清晰，我就不再做其它赘述了。</p>
<h2 id="hexo发布页面"><a href="#hexo发布页面" class="headerlink" title="hexo发布页面"></a>hexo发布页面</h2><p>如上面所介绍的，我们可以使用<code>hexo d</code>命令将生成的目标文件发布出来，但在使用它之前，你需要在站节点的_config.yml文件中配置发布的方法。我们举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">- type: git #leancloud_counter_security_sync #git</span><br><span class="line">  repo: git@github.com:avdance&#x2F;avdance.github.io.git</span><br></pre></td></tr></table></figure>

<p>当我们执行<code>hexo d</code>命令时，它会调用 hexo 中的 <code>hexo-deployer-git</code> 插件。在该插件内部会启动一个进程调用<code>git</code>命令，从而将生成的html等代码上传到 github上。</p>
<p>这里可能有些同学会有疑问，为什么上传到github上就算是发布了呢？这是因为github为我们提供了免费的个人博客空间。只要你在github上创建一个<code>用户名.github.io</code>的项目，github就会自动将这个项目中的文件发布出来。</p>
<p>当然你也可以采用传输的方式，自己购买台云主机，然后在云主机上用ngnix、nodejs等搭建一个Web服务，最终将页面发布出来。</p>
<h2 id="next主题的安装与配置"><a href="#next主题的安装与配置" class="headerlink" title="next主题的安装与配置"></a>next主题的安装与配置</h2><p>hexo中有很多的主题，但其中用的最多的、最著名的就是<strong>next</strong>主题了。下面我们就来介绍一下，如何安装next主题并对其做一些简单的配置。</p>
<p>next的安装比简单了，你只需要将next源码从github上下载下来，然后放到hexo的themes目录下即可。如下面这行语句:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone --branch v7.8.0 https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next.git themes&#x2F;next</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，我们在github中搜索关键字<code>hexo-theme-next</code>时，你会发现有两个github star数特别多，这两个地址分别是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;iissnan</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;theme-next</span><br></pre></td></tr></table></figure>
<p>上面的地址是next老版本的官方地址，下面这个是新版本的官方地址。你清楚他们之间的关系就不会给你造成混乱了。</p>
<p>next下载好后，下一步就是进行配置了。在themes/next目录下也有一个_config.yml文件，它是next主题的配置文件，千万不要将它与站点的_config.yml弄混了。</p>
<p>如果你要配置next主题时，需要修改的是themes/next目录下的_config.yml文件。</p>
<p>打开该文件，找到<code>Scheme</code>关键字，你会发现next支持多种Scheme。你可以根据喜好选择你自己喜欢的Scheme，我这里选择的是<code>Gemini</code>。选择好Scheme后，我们博客的基本结构就定下来了。接下来你可以对它进行配置了。具体的配置我会在下面再做详细论述。</p>
<p>当所有的配置都修改好后，你可以执行下面的命令将博客发布出来了。</p>
<blockquote>
<ul>
<li>hexo clean</li>
<li>hexo g</li>
<li>hexo s</li>
</ul>
</blockquote>
<h2 id="高级知识"><a href="#高级知识" class="headerlink" title="高级知识"></a>高级知识</h2><p>通过上面的操作，我们就将自己的Blog搭建好了。但此时这个Blog还只是一个最基本、最简单的Blog。如果你想让你的Blog更专业的话，还要对它进行细细的打磨。</p>
<p>接下来，我们就来看看还需要对我们的Blog做哪些处理?</p>
<ul>
<li>为文章设置摘要</li>
<li>增加图片床</li>
<li>统计阅读次数</li>
<li>显示文章字个数</li>
<li>添加评论区</li>
<li>文章置顶</li>
<li>设置标签</li>
<li>设置标签云</li>
<li>增加本地搜索</li>
<li>设置关于</li>
<li>设置404</li>
<li>SEO优化</li>
</ul>
<p>下面我们就按着这个清单细细打磨我们的Blog吧。</p>
<h3 id="为文章设置摘要"><a href="#为文章设置摘要" class="headerlink" title="为文章设置摘要"></a>为文章设置摘要</h3><p>在hexo中实现摘要有两种方法，一种主是在正文中加入如下代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure>

<p>它的作用是将<code>more</code>之前的文字作为摘要。</p>
<p>需要注意的是，一般情况下摘要都在 200 字以内，所以你自己要控制好放置<code>more</code>的位置。这种方式是我最常使用的方式，感觉非常方便。</p>
<p>第二种方法是，在文章头的 <code>description</code> 域写摘要，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: xxxx</span><br><span class="line">date: xxxx-xx-xx</span><br><span class="line">...</span><br><span class="line">description: xxxxxxx...</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>这处方式的好处是，可以将文中某一段设置为摘要，或者自己单独写一段摘要。所以这种方式更灵活，也更便于做 SEO 优化。</p>
<p>以上两种方法都可以，你可以根据自己的习惯选择最合适自已的方法。</p>
<h3 id="增加图片床"><a href="#增加图片床" class="headerlink" title="增加图片床"></a>增加图片床</h3><p>我们文章发布时，一般都是通过github发布出来，但必竟github给我们每个人的资源是有限的。如果你在github上放一些特别大的文件的话，那么你博客的访问速度一定很慢，甚至会严重影响用户的体验。</p>
<p>另外不论你在哪儿发布文章，一条必须遵守的原则是，尽量避免在主站上放置特别大的文件，尤其是图片。但现实是残酷的，有写作经验的同学都知道，在文章中放一些图片不但可以让读者更容易理解的要表达的思想，而且还有美化文章的作用。</p>
<p>如何解决上述的矛盾呢？ 答案就是使用<strong>图床</strong>。所谓图床，其实就是使用云存储(像阿里云、腾讯云、七牛云)来存储图片，然后用CDN进行加速。这样可以大大优化网站的访问速度。</p>
<p>我搭建的Blog使用的就是阿里云的云加速。对于使用阿里云加速的方法我这里就不赘述了，有兴趣的小伙伴可以到阿里的官网上自行查阅使用说明。</p>
<h3 id="统计阅读次数"><a href="#统计阅读次数" class="headerlink" title="统计阅读次数"></a>统计阅读次数</h3><p>由于hexo自己没有提供数据库的功能，因此对文章访问次数的统计需要通过第三方云服务来提供支持。</p>
<p>大多数情况下，我们使用leancloud做服务统计，而且hexo中也实现了与之相关的接入代码。当然，你也可以通过云数据库来实现这个功能，至于你选择那种方案就看你自己的喜好了。</p>
<p>下面我就来介绍一下通过leancloud如何实现统计阅读次数这一功能。</p>
<p>首先，你要注册一个leancloud账户。leancloud上提供了两种用户类型，一种是developer，一种是商业用户。developer用户是免费的，但有限制。不过这种限制对于我们这种访问量很少的Blog来说是无所谓的。</p>
<p>注册好用户后，我们需要在leancloud上创建一个<strong>class</strong>，这里的<code>class</code>类似于关系型数据库中的表。class的名子是固定的，必须是<code>Counter</code>，只有这样 hexo 才能将数据保存到leancloud上，也才能真正的实现阅读量的统计，</p>
<p>leancloud class创建好后，我们就要对hexo进行配置了。实际上，真正进行统计的模块是next。如果你使用的是其它主题的话，那就要找对应的统计方法。</p>
<p>对于next来说，它的V5版本与V7版本在使用leancloud的方法是不一样的。据说V5版本存在统计漏洞，很容易被黑客攻击，因此改为现然V7的方式了。</p>
<p>不过经我测试，V5的方式配置起来比较简单，V7的方式我没有验证通过。也就是说，通过V7的方法无法进行阅读量统计。我想一定是我那里没有配置对，希望有这方面经验的同学可以分享一下。</p>
<p>下面我们来看看如何修改next的配置使其与leancloud相联(这里讲的是V5的方法)。打开themes/next目录下的_config.yml文件，找到<code>leadcloud_visitors</code>关键字，修改其配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">leancloud\_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  app\_id: &lt;your app id&gt;</span><br><span class="line">  app\_key: &lt;your app key&gt;</span><br></pre></td></tr></table></figure>

<p>这三个字段的含义如下，<code>enable</code>表示是否开启leadcloud_visitors功能，所以这个选项我们要修改为true；<code>app_id</code>是你注册leancloud时分配给你的ID; <code>app_key</code>也是你注册leancloud时分配的。只要我们将上面的参数配置好后，当你再浏览你的文章时，就会发现访问次数发生变化了。</p>
<h3 id="统计文章字数"><a href="#统计文章字数" class="headerlink" title="统计文章字数"></a>统计文章字数</h3><p>hexo本身并不支持文章字数的统计，因此要想实现这一功能我们需要安装一个插件，即<code>hexo-symbols-count-time</code>。在以前，大家都使用wordcount插件，但到了next V6之后<code>hexo-symbols-count-time</code>逐渐替代了<code>wordcount</code>。</p>
<p>下面我们来看一下如何使用<code>hexo-symbols-count-time</code>插件。使用它之前我们需要先将其安装好，执行下面的命令即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>

<p>hexo-symbols-count-time插件安装完成后，我们要修改两个配置文件: hexo 中的_config.yml文件和next主题中的_config.yml文件。</p>
<p>第一步，修改hexo中的_config.xml的<code>symbols\_count\_time</code>项，修改配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置博客单词统计</span><br><span class="line">symbols_count_time:</span><br><span class="line">  # 文章字数统计</span><br><span class="line">  symbols: true</span><br><span class="line">  # 文章阅读时间统计</span><br><span class="line">  time: true</span><br><span class="line">  # 站点总字数统计</span><br><span class="line">  total_symbols: false</span><br><span class="line">  # 站点总阅读时间统计</span><br><span class="line">  total_time: false</span><br><span class="line">  exclude_codeblock: false</span><br></pre></td></tr></table></figure>
<p>第二步，修改 themes/next 目录下的 _config.yml 文件，仍然找 <code>symbols_count_time</code> 项，配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置博客单词统计</span><br><span class="line">symbols_count_time:</span><br><span class="line">  # 是否另起一行（true的话不和发表时间等同一行）</span><br><span class="line">  separated_meta: true</span><br><span class="line">  # 首页文章统计数量前是否显示文字描述（本文字数、阅读时长）</span><br><span class="line">  item_text_post: true</span><br><span class="line">  # 页面底部统计数量前是否显示文字描述（站点总字数、站点阅读时长）</span><br><span class="line">  item_text_total: false</span><br><span class="line">  # 平均字长</span><br><span class="line">  awl: 4</span><br><span class="line">  # 每分钟阅读字数</span><br><span class="line">  wpm: 275</span><br></pre></td></tr></table></figure>

<p>上面的配置修改后，文章字数统计功能就算配置好了，现在只要你重新生成静态页面，然后发布出来就可以看到效果了。</p>
<h3 id="如何添加评论系统"><a href="#如何添加评论系统" class="headerlink" title="如何添加评论系统"></a>如何添加评论系统</h3><p>hexo还可以接入评论系统，而且可以接入多种评论系统。在从多的评论系统中，Valine是其中一款比较出众的评论系统。</p>
<p>hexo接入valine非常容易，就像之前介绍的接入阅读统计系统一样，它也需要在leancloud系统上创建一个类，即 <code>Comment</code>类，用于保存用户的评论。</p>
<p>因此我们在接入用户评论系统时，需要经过以下几步:</p>
<ul>
<li>第一步，在leancloud上创建comment类；</li>
<li>第二步，修改 themes/next 目录下的_config.yml 文件，做如下配置：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">valine:</span><br><span class="line">  enable: true #是否接入valine 系统</span><br><span class="line">  appid:  #LeanClound获得的appid</span><br><span class="line">  appkey: #LeanClound获得的appkey</span><br><span class="line">  notify: false # 邮件提醒</span><br><span class="line">  verify: false # Verification code</span><br><span class="line">  placeholder: 欢迎畅所欲言 # 占位字符串 </span><br><span class="line">  avatar: mm #默认头像设置</span><br><span class="line">  guest_info: nick #评论区的title </span><br><span class="line">  pageSize: 10 # Pagination size</span><br><span class="line">  language: zh-cn # Language, available values: en, zh-cn # 语言，设为zh-cn</span><br><span class="line">  # 是否开启当前文章阅读量统计</span><br><span class="line">  visitor: false #这个要设置为false，以免与 leancloud_visitors 突冲 </span><br><span class="line">  comment_count: true #是否在主页里也显示评论个数，为false是不显示</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>通过上面的设置后，你就可以在文章中看到评论区了。</p>
<p>实际上，我们还可以真对每一篇文章单独设置是否显示评论区，如何做呢？</p>
<p>只要你在想要关闭评论区的文章头加上<code>comments: false</code>这句即可。具体例子如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">date: 2019-07-18 15:16:50</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure>

<p>到此为止，我们就将评论系统接入到我们的博客中了。</p>
<h3 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h3><p>文章写好后，有一些我们认为特别好的文章希望置顶，这该如何做呢？</p>
<p>hexo默认的方式是按时间顺序排放文章的，也就是最后写完的文章会放在最一个。如果要打破这个规则，我们就需要给它建立一个新规则。</p>
<p>应该定义个什么样的规则呢？实际上已经有人帮我们想好了，就是给文章做个编号，有编号的优先排序，并且按照编号进行排序；而没有编号的再按时间排序，这样就解决了我们想将文章顶置的需求。</p>
<p>更好的消息时，现在hexo已经有了这样一个新的排序插件叫<code>hexo-generator-index-pin-top</code>，我们只需要用它替换原来老的排序插件即可。具体操作步骤如下：</p>
<ul>
<li>先将老的排序插件删除掉<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn remove hexo-generator-index</span><br></pre></td></tr></table></figure></li>
<li>按装新插件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add hexo-generator-index-pin-top</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>光安装好插件还不行，我们要想让文章置顶还要修改文章的title域，在title域中增加一个<strong>top</strong> 域，这样这篇文章就会被置顶了。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----</span><br><span class="line">title: xxxx</span><br><span class="line">date: xxxx-xx-xx</span><br><span class="line">...</span><br><span class="line">top: 1</span><br><span class="line">...</span><br><span class="line">----</span><br></pre></td></tr></table></figure>
<p>经上面这样设置后，我们想置顶的文章就会跑到主页的顶部，马上去试试看吧。</p>
<p>不过这里还有一个小问题，文章是置顶了，但对于用户来说却感受不到。从用户的角度看，如果不仔细观察的话还真不会发现前面几篇文章是置顶文章。有没有办法可以将置顶文章做个标识呢？</p>
<p>当然有办法，不过我们需要修改一点next主题的代码了。我们进行到<code>next/layout/_macro</code>目录下，打开post.swig文件，找到 <code>&lt;div class=&quot;post-meta&quot;&gt;</code> 标记，然后在它下面添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">  &lt;i class&#x3D;&quot;fa fa-thumb-tack&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  &lt;font color&#x3D;7D26CD&gt;置顶&lt;&#x2F;font&gt;</span><br><span class="line">  &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>经过这样的设置后，我就可以在博客主页中看到前面被置顶的文章被打上标记了。打开<a href="https://blog.avdancedu.com">我的博客</a>你应该就可以看到真实的效果了。</p>
<h3 id="如何开启打赏功能"><a href="#如何开启打赏功能" class="headerlink" title="如何开启打赏功能"></a>如何开启打赏功能</h3><p>hexo 中 next 主题开启打赏功能非常简单，只要稍微配置一下就可以了。在里需要普及一些支付的基本知识，对于正常的支付来说，当用户点击打赏时，可以选择要打赏的金额，之后应该调用腾讯或阿里的支付接口，最终完成支付。但对于hexo来说，显然它做不了这么复杂的交互逻辑，那它是如何做的呢？</p>
<p>实际上，它只是将微信/支付完的收款二维码放到网页上面来实现打赏功能的。具体的步骤如下：</p>
<ul>
<li>生成收款二维码，打开微信/支付宝，将收款二维码保存成图片。</li>
<li>编辑next主题下面的_config.xmy文件，将该文件中的<code>reward\_settings</code>打开即可。具体配置如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Reward (Donate)</span><br><span class="line">reward\_settings:</span><br><span class="line">  enable: true</span><br><span class="line">  animation: true</span><br><span class="line">  comment: 只想买包辣条</span><br><span class="line"></span><br><span class="line">reward:</span><br><span class="line">  wechatpay: &#x2F;images&#x2F;wechatpay.png   #微信收款码</span><br><span class="line">  alipay: &#x2F;images&#x2F;alipay.png   #支付宝收款码</span><br><span class="line">  #bitcoin: &#x2F;images&#x2F;bitcoin.png</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>通过上面的设置，我们就将hexo的打赏功能设置好了。</p>
<h3 id="添加标签和分类"><a href="#添加标签和分类" class="headerlink" title="添加标签和分类"></a>添加标签和分类</h3><p>在hexo中给文章添加标签并给文章分类很容易，只要在文章头里加 <code>tags</code> 和<code>categories</code>域即可。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: xxx    &#x2F;&#x2F;在此处添加你的标题。</span><br><span class="line">date: 2016-10-07 13:38:49   &#x2F;&#x2F;在此处输入编辑这篇文章的时间。</span><br><span class="line">tags: [aaa, bbb, ccc]    &#x2F;&#x2F;在此处输入这篇文章的标签。</span><br><span class="line">categories: xxx, yyy    &#x2F;&#x2F;在此处输入这篇文章的分类。</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>通过上面的例子我们可以看到，可以给一篇文章增加多个tag，也可以将文章划分到多个不同的类别中去。</p>
<p>除了在文章中我们可以给文章打多个标签和分类外，我们还应该将hexo next中的标签/分类入口打开，这样可以方便用户查看博客中所有的标签和分类，从而可以快速找到它们感兴趣的文章。</p>
<p>具体做法如下，进入到 themes/next 目录，打开_config.yml 文件，找到<code>menu</code>项，配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">home: &#x2F;|| home</span><br><span class="line">tags: &#x2F;tags&#x2F;|| tags</span><br><span class="line">categories: &#x2F;categories&#x2F;|| th</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>通过上面的配置，我们就将<strong>标签</strong>和<strong>分类</strong>入口打开了。不过光打开入口还不行，我们还要创建 tag 和 categories 目录和文章，执行下面的命令即可完成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page tags&#x2F;categories</span><br></pre></td></tr></table></figure>

<p>执行完上述命令后，我们就可以在source目录下看到tags和categories目录了。</p>
<p>此时，我们重新执行<code>hexo g</code>生成页面，你就可以看到我们在文章中打的标签和分类被写到各目录的index文件中了。</p>
<h3 id="如何设置标签云"><a href="#如何设置标签云" class="headerlink" title="如何设置标签云"></a>如何设置标签云</h3><p>当我在浏览其它人使用hexo搭建的博客时，发现它的标签特别炫，有一些标签用的少就会是很小的字体，而一些经常用的标签则是很大的字体。经了解才知道这就是标签云。可以通过<code>hexo-tag-cloud</code>插件来实现。该插件除了可以实现我上面所说的功能外，还能在你的博客的左边或右边出现标签滚动的效果。</p>
<p>下面我们就来看看该如何设置标签云吧。第一步自然不必多说，一定是安装插件，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add hexo-tag-cloud --save</span><br></pre></td></tr></table></figure>
<p>插件安装好后，在站点的_config.yml文件中添加如下配置信息:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># hexo-tag-cloud 标签云 | see https:&#x2F;&#x2F;github.com&#x2F;MikeCoder&#x2F;hexo-tag-cloud</span><br><span class="line">tag_cloud:</span><br><span class="line">  textFont: Trebuchet MS, Helvetica # 字体</span><br><span class="line">  textColor: &#39;#555&#39; # 字体颜色</span><br><span class="line">  textHeight: 25 # 字体高度</span><br><span class="line">  outlineColor: &#39;#E2E1D1&#39; # 字体背景色</span><br><span class="line">  maxSpeed: 0.1 # 标签云最大移动速度</span><br></pre></td></tr></table></figure>
<p>上面的配置信息是用于控制标签云显示的效果的。其中，<code>maxSpeed</code>我们要介绍一下，该值为 1 时运转的速度最快，该值为0是基本处理不动的状态。当然如果你不喜欢标签滚动的效果，则可以不设置这些信息。</p>
<p>对于要达到滚动效果的标签云来说，光有这些信息还不够，还要修改一点代码。打开source/layout/_macro/sidevar.swig文件，在文中搜索找到<code>sidebar-inner</code> 的 div 元素，在其下面加入下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if site.tags.length &gt; 1 %&#125;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; charset&#x3D;&quot;utf-8&quot; src&#x3D;&quot;&#123;&#123; url_for(&#39;&#x2F;js&#x2F;tagcloud.js&#39;) &#125;&#125;&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; charset&#x3D;&quot;utf-8&quot; src&#x3D;&quot;&#123;&#123; url_for(&#39;&#x2F;js&#x2F;tagcanvas.js&#39;) &#125;&#125;&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;widget-wrap&quot;&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;myCanvasContainer&quot; class&#x3D;&quot;widget tagcloud&quot;&gt;</span><br><span class="line">    &lt;canvas width&#x3D;&quot;220&quot; height&#x3D;&quot;250&quot; id&#x3D;&quot;resCanvas&quot; style&#x3D;&quot;width&#x3D;100%&quot;&gt;</span><br><span class="line">        &#123;&#123; list_tags() &#125;&#125;</span><br><span class="line">    &lt;&#x2F;canvas&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的配置我们就将标签云设置好了。</p>
<h3 id="如何添加本地搜索"><a href="#如何添加本地搜索" class="headerlink" title="如何添加本地搜索"></a>如何添加本地搜索</h3><p>在hexo中支持很多种搜索，这里我就不一一介绍了，我只用到了其中的本地搜索，并感觉hexo本地搜索的表现还是不错的，所以我也推荐大家用本地搜索。hexo本地搜索的原理很简单，就是通过hexo-generator-search插件在本地生成一个search.xml/json文件，通过这个文件实现搜索功能。</p>
<p>为hexo添中本地搜索功能的步骤很简单，第一步是按装插件，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-search</span><br><span class="line">npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure>

<p>然后修改 hexo 下面的配置文件_config.yml，在其中增加下面配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>

<p>接下来我们把本地搜索入口打开，打开next/_config.yml文件，找到<code>local\_search</code>选项，将该选项设置为true就好了。具体设置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local\_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # if auto, trigger search by changing input</span><br><span class="line">  # if manual, trigger search by pressing enter key or search button</span><br><span class="line">  trigger: auto</span><br><span class="line">  # show top n results per article, show all results by setting to -1</span><br><span class="line">  top\_n\_per\_article: 1</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>上面都配置好后，使用hexo命令重新生成代码并重新进行布署，这样我们就可以看到搜索功能的效果了。</p>
<h3 id="设置关于"><a href="#设置关于" class="headerlink" title="设置关于"></a>设置关于</h3><p>hexo上设置关于与设置标签是类似的，首先执行下面的命令生成关于目录和源码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;about&quot;</span><br></pre></td></tr></table></figure>
<p>该命令执行后，你就可以在source/ 目录下面看到about目录了。然后向 about 目录中的index.md 写入关于的信息就好了。</p>
<p>除此之外，我们还应该像创建标签一样在 themes/next 目录下_config.yml文件中将 about 的入口打开。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">home: &#x2F;|| home</span><br><span class="line">tags: &#x2F;tags&#x2F;|| tags</span><br><span class="line">...</span><br><span class="line">about: &#x2F;about&#x2F;|| about</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这样我们就将关于页面加载好了。</p>
<h3 id="设置404"><a href="#设置404" class="headerlink" title="设置404"></a>设置404</h3><p>设置 404 与设置关于是类似的，也是首先执行 <code>hexo new page &#39;404&#39;</code>命令生成对应的目录和文件，之后是编写404页面。在编写 404 页面时有一点需要注意，就是在404页面的头部要加<code>permalink</code>关键字，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">...</span><br><span class="line">permalink: &#x2F;404</span><br><span class="line">...</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>这样当用户访问非发布的页面时，hexo会始终定位到 404 页面上。</p>
<h3 id="将文章名修改为数字码"><a href="#将文章名修改为数字码" class="headerlink" title="将文章名修改为数字码"></a>将文章名修改为数字码</h3><p>当我在hexo发布文件时发现一个问题，就是hexo生成的文章名如果有中文的话会被转码，这样就变成了一个特别长的字符串，让人看起来非常别拗。能不能将它修改为像简书一样的字符串呢？hexo同样提供了这样一个插件，叫<code>hexo-abbrlink</code>。我们只要装上这个插件再修改一下配置文件就OK了。下面我们就来偿试下吧。</p>
<p>首先还是安装插件，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add hexo-abbrlink --save</span><br></pre></td></tr></table></figure>
<p>插件安装好后，我们再来修改一下配置文件，打开站目录下的_config.yml文件，找到<code>permalink</code>并将它的值修改为 <code>post/:abbrlink/</code>，之后添加abbrlink属性。具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">permalink: posts&#x2F;:abbrlink&#x2F;</span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32</span><br><span class="line">  rep: hex</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>全部配置好后我们就可以重新生成静态文件了。当我们将静态文件发布出来后，你再访问文章时你就会发现以前一长号字符的地址现在已经变的非常短了。</p>
<h3 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h3><p>涉及的知识比较多，待进一步完成！</p>

 <!-- 引入 flv.js 库 -->
 <!--
 <video id="flv_file" controls autoplay>
          You Browser doesn't support video tag
 </video>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/flv.js/1.5.0/flv.min.js"></script>
 <script>
            //通过 JavaScript 脚本创建 FLV Player
            if (flvjs.isSupported()) {
                var videoElement = document.getElementById('flv_file');
                var flvPlayer = flvjs.createPlayer({
                    type: 'flv',
                    url: 'https://avdancevod.oss-cn-beijing.aliyuncs.com/vodio/killer.flv'
                });
                flvPlayer.attachMediaElement(videoElement);
                flvPlayer.load();
                flvPlayer.play();
            }
 </script>
 -->


<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文是我自己搭建博客的总结文章。该文记录的是从我对hexo有所了解，到逐步深入，再到一步一步搭建出我们自己比较满意的博客的过程。在整个过程中，我感触最多的是我在搭建过程中对博客技术的思考以及对技术的重新认知，这两个方面是我对hexo特别兴奋点。也正因于此，才使我写出这一万多字的文章。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>Blog</tag>
        <tag>博客</tag>
        <tag>标签</tag>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
</search>
